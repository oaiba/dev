<!doctype html><html lang=vi dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Nhật ký phát triển của Bob Phạm</title><meta name=keywords content><meta name=description content="https://vorixo.github.io/devtricks/stateful-events-multiplayer/#onreps
https://wizardcell.com/unreal/multiplayer-tips-and-tricks/
https://dev.epicgames.com/documentation/en-us/unreal-engine/epic-cplusplus-coding-standard-for-unreal-engine
https://www.tomlooman.com/unreal-engine-naming-convention-guide/
https://unrealdirective.com/resources/asset-naming-conventions
https://unrealdirective.com/tips
https://github.com/Allar/ue5-style-guide/tree/v2?tab=readme-ov-file
1. Yêu cầu tiên quyết: Xây dựng nền móng đúng đắn
Sử dụng phiên bản Unreal Engine từ mã nguồn (Source Build)


Tại sao lại làm như thế?

Khả năng biên dịch Server Target: Phiên bản Engine tải từ Epic Games Launcher (Binary build) đã được biên dịch
sẵn và không bao gồm các công cụ cần thiết để tạo ra một bản build hoàn toàn riêng biệt cho server (
Server Target). Chỉ có phiên bản từ mã nguồn mới cho phép chúng ta biên dịch mục tiêu này, tạo ra một file thực
thi .exe siêu nhẹ, không chứa mã nguồn đồ họa hay âm thanh không cần thiết.
Gỡ lỗi (Debug) Engine: Khi gặp phải các lỗi sâu bên trong Engine, việc có mã nguồn cho phép chúng ta debug
từng dòng lệnh, hiểu rõ nguyên nhân và thậm chí tự sửa lỗi nếu cần.
Tùy biến Engine: chúng ta có toàn quyền tùy chỉnh và mở rộng các tính năng của Engine để phù hợp với nhu cầu
đặc thù của dự án.
Tiếp cận các tính năng thử nghiệm: Một số tính năng mới nhất có thể chỉ tồn tại trên các nhánh nhất định của
mã nguồn.



Tip & Trick cho Team:"><meta name=author content="Bob Pham"><link rel=canonical href=https://oaiba.github.io/dev/vi/posts/tiptrick/scratch_1/><link crossorigin=anonymous href=/dev/assets/css/stylesheet.2c98de55bd3fc6df1bb365f4fd08052c7377847525222e274b197419de218394.css integrity="sha256-LJjeVb0/xt8bs2X0/QgFLHN3hHUlIi4nSxl0Gd4hg5Q=" rel="preload stylesheet" as=style><link rel=icon href=https://oaiba.github.io/dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://oaiba.github.io/dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://oaiba.github.io/dev/favicon-32x32.png><link rel=apple-touch-icon href=https://oaiba.github.io/dev/apple-touch-icon.png><link rel=mask-icon href=https://oaiba.github.io/dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=vi href=https://oaiba.github.io/dev/vi/posts/tiptrick/scratch_1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://oaiba.github.io/dev/vi/posts/tiptrick/scratch_1/"><meta property="og:site_name" content="Nhật ký phát triển của Bob Phạm"><meta property="og:title" content="Nhật ký phát triển của Bob Phạm"><meta property="og:description" content="https://vorixo.github.io/devtricks/stateful-events-multiplayer/#onreps
https://wizardcell.com/unreal/multiplayer-tips-and-tricks/ https://dev.epicgames.com/documentation/en-us/unreal-engine/epic-cplusplus-coding-standard-for-unreal-engine
https://www.tomlooman.com/unreal-engine-naming-convention-guide/
https://unrealdirective.com/resources/asset-naming-conventions
https://unrealdirective.com/tips
https://github.com/Allar/ue5-style-guide/tree/v2?tab=readme-ov-file
1. Yêu cầu tiên quyết: Xây dựng nền móng đúng đắn Sử dụng phiên bản Unreal Engine từ mã nguồn (Source Build) Tại sao lại làm như thế?
Khả năng biên dịch Server Target: Phiên bản Engine tải từ Epic Games Launcher (Binary build) đã được biên dịch sẵn và không bao gồm các công cụ cần thiết để tạo ra một bản build hoàn toàn riêng biệt cho server ( Server Target). Chỉ có phiên bản từ mã nguồn mới cho phép chúng ta biên dịch mục tiêu này, tạo ra một file thực thi .exe siêu nhẹ, không chứa mã nguồn đồ họa hay âm thanh không cần thiết. Gỡ lỗi (Debug) Engine: Khi gặp phải các lỗi sâu bên trong Engine, việc có mã nguồn cho phép chúng ta debug từng dòng lệnh, hiểu rõ nguyên nhân và thậm chí tự sửa lỗi nếu cần. Tùy biến Engine: chúng ta có toàn quyền tùy chỉnh và mở rộng các tính năng của Engine để phù hợp với nhu cầu đặc thù của dự án. Tiếp cận các tính năng thử nghiệm: Một số tính năng mới nhất có thể chỉ tồn tại trên các nhánh nhất định của mã nguồn. Tip & Trick cho Team:"><meta property="og:locale" content="vi"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="https://vorixo.github.io/devtricks/stateful-events-multiplayer/#onreps
https://wizardcell.com/unreal/multiplayer-tips-and-tricks/
https://dev.epicgames.com/documentation/en-us/unreal-engine/epic-cplusplus-coding-standard-for-unreal-engine
https://www.tomlooman.com/unreal-engine-naming-convention-guide/
https://unrealdirective.com/resources/asset-naming-conventions
https://unrealdirective.com/tips
https://github.com/Allar/ue5-style-guide/tree/v2?tab=readme-ov-file
1. Yêu cầu tiên quyết: Xây dựng nền móng đúng đắn
Sử dụng phiên bản Unreal Engine từ mã nguồn (Source Build)


Tại sao lại làm như thế?

Khả năng biên dịch Server Target: Phiên bản Engine tải từ Epic Games Launcher (Binary build) đã được biên dịch
sẵn và không bao gồm các công cụ cần thiết để tạo ra một bản build hoàn toàn riêng biệt cho server (
Server Target). Chỉ có phiên bản từ mã nguồn mới cho phép chúng ta biên dịch mục tiêu này, tạo ra một file thực
thi .exe siêu nhẹ, không chứa mã nguồn đồ họa hay âm thanh không cần thiết.
Gỡ lỗi (Debug) Engine: Khi gặp phải các lỗi sâu bên trong Engine, việc có mã nguồn cho phép chúng ta debug
từng dòng lệnh, hiểu rõ nguyên nhân và thậm chí tự sửa lỗi nếu cần.
Tùy biến Engine: chúng ta có toàn quyền tùy chỉnh và mở rộng các tính năng của Engine để phù hợp với nhu cầu
đặc thù của dự án.
Tiếp cận các tính năng thử nghiệm: Một số tính năng mới nhất có thể chỉ tồn tại trên các nhánh nhất định của
mã nguồn.



Tip & Trick cho Team:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://oaiba.github.io/dev/vi/posts/"},{"@type":"ListItem","position":2,"name":"","item":"https://oaiba.github.io/dev/vi/posts/tiptrick/scratch_1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"https://vorixo.github.io/devtricks/stateful-events-multiplayer/#onreps\nhttps://wizardcell.com/unreal/multiplayer-tips-and-tricks/ https://dev.epicgames.com/documentation/en-us/unreal-engine/epic-cplusplus-coding-standard-for-unreal-engine\nhttps://www.tomlooman.com/unreal-engine-naming-convention-guide/\nhttps://unrealdirective.com/resources/asset-naming-conventions\nhttps://unrealdirective.com/tips\nhttps://github.com/Allar/ue5-style-guide/tree/v2?tab=readme-ov-file\n1. Yêu cầu tiên quyết: Xây dựng nền móng đúng đắn Sử dụng phiên bản Unreal Engine từ mã nguồn (Source Build) Tại sao lại làm như thế?\nKhả năng biên dịch Server Target: Phiên bản Engine tải từ Epic Games Launcher (Binary build) đã được biên dịch sẵn và không bao gồm các công cụ cần thiết để tạo ra một bản build hoàn toàn riêng biệt cho server ( Server Target). Chỉ có phiên bản từ mã nguồn mới cho phép chúng ta biên dịch mục tiêu này, tạo ra một file thực thi .exe siêu nhẹ, không chứa mã nguồn đồ họa hay âm thanh không cần thiết. Gỡ lỗi (Debug) Engine: Khi gặp phải các lỗi sâu bên trong Engine, việc có mã nguồn cho phép chúng ta debug từng dòng lệnh, hiểu rõ nguyên nhân và thậm chí tự sửa lỗi nếu cần. Tùy biến Engine: chúng ta có toàn quyền tùy chỉnh và mở rộng các tính năng của Engine để phù hợp với nhu cầu đặc thù của dự án. Tiếp cận các tính năng thử nghiệm: Một số tính năng mới nhất có thể chỉ tồn tại trên các nhánh nhất định của mã nguồn. Tip \u0026amp; Trick cho Team:\n","keywords":[],"articleBody":"https://vorixo.github.io/devtricks/stateful-events-multiplayer/#onreps\nhttps://wizardcell.com/unreal/multiplayer-tips-and-tricks/ https://dev.epicgames.com/documentation/en-us/unreal-engine/epic-cplusplus-coding-standard-for-unreal-engine\nhttps://www.tomlooman.com/unreal-engine-naming-convention-guide/\nhttps://unrealdirective.com/resources/asset-naming-conventions\nhttps://unrealdirective.com/tips\nhttps://github.com/Allar/ue5-style-guide/tree/v2?tab=readme-ov-file\n1. Yêu cầu tiên quyết: Xây dựng nền móng đúng đắn Sử dụng phiên bản Unreal Engine từ mã nguồn (Source Build) Tại sao lại làm như thế?\nKhả năng biên dịch Server Target: Phiên bản Engine tải từ Epic Games Launcher (Binary build) đã được biên dịch sẵn và không bao gồm các công cụ cần thiết để tạo ra một bản build hoàn toàn riêng biệt cho server ( Server Target). Chỉ có phiên bản từ mã nguồn mới cho phép chúng ta biên dịch mục tiêu này, tạo ra một file thực thi .exe siêu nhẹ, không chứa mã nguồn đồ họa hay âm thanh không cần thiết. Gỡ lỗi (Debug) Engine: Khi gặp phải các lỗi sâu bên trong Engine, việc có mã nguồn cho phép chúng ta debug từng dòng lệnh, hiểu rõ nguyên nhân và thậm chí tự sửa lỗi nếu cần. Tùy biến Engine: chúng ta có toàn quyền tùy chỉnh và mở rộng các tính năng của Engine để phù hợp với nhu cầu đặc thù của dự án. Tiếp cận các tính năng thử nghiệm: Một số tính năng mới nhất có thể chỉ tồn tại trên các nhánh nhất định của mã nguồn. Tip \u0026 Trick cho Team:\nBiên dịch một lần, dùng cho cả team: Một người trong team (thường là lead hoặc build engineer) sẽ chịu trách nhiệm biên dịch Engine từ mã nguồn. Sau đó, toàn bộ thư mục Engine đã biên dịch có thể được nén lại và chia sẻ cho cả team thông qua một server nội bộ hoặc dịch vụ lưu trữ. Điều này giúp các thành viên khác không phải tốn thời gian biên dịch lại. Sử dụng Unreal Build System (UBT): Tận dụng UBT để tự động hóa quy trình build Engine, giúp đảm bảo tính nhất quán giữa các lần build. Dự án C++: Xây dựng một “Siêu đô thị” có Quy hoạch và Luật lệ Rõ ràng Việc lựa chọn C++ và cấu trúc dự án không chỉ là xây dựng một “bộ khung xương”; nó là việc thiết lập bản quy hoạch tổng thể và bộ luật xây dựng cho toàn bộ “siêu đô thị” game của chúng ta. Một bản quy hoạch tốt kết hợp với luật lệ nghiêm ngặt sẽ đảm bảo thành phố có thể phát triển bền vững, dễ dàng nâng cấp, và không bao giờ chìm trong hỗn loạn.\n“Allar’s UE5 Style Guide” chính là bộ luật xây dựng đó.\nHai Triết lý Quy hoạch “Siêu đô thị” Unreal Khi bắt đầu một dự án, chúng ta đứng trước một ngã rẽ quan trọng về cách tổ chức hàng ngàn, thậm chí hàng triệu file assets và code. Có hai trường phái tư duy chính, hai “bản quy hoạch tổng thể” khác biệt hoàn toàn.\nPhương pháp 1: Quy hoạch theo Chức năng (Functional-First Approach) Triết lý Hãy tưởng tượng một thành phố được quy hoạch một cách tuyệt đối theo ngành nghề và chức năng. Tất cả các ngân hàng nằm ở “Quận Tài chính”, tất cả các nhà máy nằm ở “Khu Công nghiệp”, tất cả các trường đại học nằm ở “Làng Đại học”. Nếu chúng ta muốn tìm một thứ gì đó, chúng ta chỉ cần biết “nó là loại gì” để đi đến đúng khu vực.\nTrong Unreal, triết lý này có nghĩa là tất cả các asset cùng loại sẽ được nhóm lại với nhau, bất kể chúng thuộc về tính năng hay nhân vật nào.\nCách làm (How-to) Cấu trúc thư mục Content sẽ được tổ chức theo loại asset:\nContent/ ├── Blueprints/ │ ├── Pawns/ │ │ ├── BP_PlayerCharacter.uasset │ │ └── BP_Enemy_Grunt.uasset │ ├── Actors/ │ │ ├── BP_Door.uasset │ │ └── BP_HealthPack.uasset │ └── Weapons/ │ └── BP_AK47.uasset │ ├── Maps/ │ ├── MainMenu.umap │ └── Jungle.umap │ ├── Materials/ │ ├── M_PlayerCharacter.uasset │ ├── M_Enemy_Grunt.uasset │ └── M_AK47.uasset │ ├── Meshes/ │ ├── StaticMeshes/ │ │ └── SM_HealthPack.uasset │ └── SkeletalMeshes/ │ ├── SK_PlayerCharacter.uasset │ ├── SK_Enemy_Grunt.uasset │ └── SK_AK47.uasset │ ├── Textures/ │ ├── T_PlayerCharacter_D.uasset │ ├── T_Enemy_Grunt_D.uasset │ └── T_AK47_D.uasset │ └── ... (Sounds, Particles, etc.) Ưu điểm (Pros) Dễ tìm theo loại: Nếu chúng ta cần tìm bất kỳ Material nào trong dự án, chúng ta biết chính xác phải vào thư mục Content/Materials. Điều này rất hữu ích cho các Technical Artist khi họ muốn kiểm tra và tối ưu hóa tất cả các material trong game. Thúc đẩy Tái sử dụng: Khi tất cả các texture được đặt chung một nơi, artist sẽ có xu hướng tìm kiếm một texture kim loại đã có sẵn trước khi tạo ra một cái mới, giúp giảm sự trùng lặp và tiết kiệm dung lượng. Rõ ràng cho Lập trình viên (Ban đầu): Cấu trúc này ban đầu có vẻ rất logic và sạch sẽ, đặc biệt đối với những người có tư duy lập trình, vì nó phân tách rõ ràng các “lớp” khác nhau của một thực thể (model, material, logic). Nhược điểm (Cons) Cơn ác mộng cho việc Di chuyển \u0026 Xóa bỏ: Đây là nhược điểm lớn nhất. Để xóa hoàn toàn nhân vật “Enemy Grunt”, chúng ta phải đi lùng sục trong ít nhất 5 thư mục khác nhau (Blueprints, Materials, Meshes, Textures, Animations) để xóa từng file một. Nguy cơ để lại các file “mồ côi” (orphan files) làm rác dự án là cực kỳ cao. Workflow rời rạc cho Artist \u0026 Designer: Để lắp ráp hoàn chỉnh một nhân vật, một artist phải liên tục nhảy giữa nhiều thư mục khác nhau để gán mesh, material, texture… Điều này làm gián đoạn dòng chảy công việc và tốn thời gian. Không thân thiện với DLC và Đóng gói (Chunking): Khi chúng ta muốn đóng gói một bản DLC chỉ chứa map “Desert” và các asset liên quan, làm thế nào chúng ta có thể chỉ định cho Unreal Build Tool biết file nào thuộc về map đó? Gần như là không thể một cách tự động. Chúng ta sẽ phải tạo danh sách thủ công, một công việc dễ sai sót và không có khả năng mở rộng. Phương pháp 2: Quy hoạch theo Nội dung (Content-First Approach) Triết lý Hãy tưởng tượng một thành phố được xây dựng như một tập hợp các “khu đô thị” hoặc “công viên chủ đề” hoàn toàn tự chủ. Mọi thứ chúng ta cần cho “Công viên Kỷ Jura” (khủng long, cây cối, xe jeep, hàng rào điện) đều nằm gọn bên trong bức tường của công viên đó. Nếu chúng ta muốn di chuyển cả công viên sang một địa điểm mới, chúng ta chỉ cần bứng cả khu đất đó đi.\nTrong Unreal, triết lý này có nghĩa là tất cả các asset liên quan đến một tính năng hoặc một thực thể cụ thể sẽ được nhóm lại với nhau trong một thư mục duy nhất.\nCách làm (How-to) Cấu trúc thư mục Content sẽ được tổ chức theo tính năng/thực thể:\nContent/ ├── Characters/ │ ├── Player/ │ │ ├── BP_PlayerCharacter.uasset │ │ ├── Meshes/ │ │ │ └── SK_PlayerCharacter.uasset │ │ ├── Materials/ │ │ │ └── M_PlayerCharacter.uasset │ │ └── Textures/ │ │ └── T_PlayerCharacter_D.uasset │ └── Enemies/ │ └── Grunt/ │ ├── BP_Enemy_Grunt.uasset │ ├── Meshes/ │ │ └── SK_Enemy_Grunt.uasset │ └── ... │ ├── Weapons/ │ └── Rifles/ │ └── AK47/ │ ├── BP_AK47.uasset │ ├── Meshes/ │ │ └── SK_AK47.uasset │ └── ... │ ├── Props/ │ └── HealthPack/ │ ├── BP_HealthPack.uasset │ ├── Meshes/ │ │ └── SM_HealthPack.uasset │ └── ... │ └── Maps/ ├── MainMenu/ │ └── Map_MainMenu.umap └── Jungle/ ├── Map_Jungle.umap ├── Meshes/ # Các mesh chỉ dùng trong map Jungle └── Materials/ # Các material chỉ dùng trong map Jungle Ưu điểm (Pros) Tính tự chứa và Di động (Self-Contained \u0026 Portable): Đây là ưu điểm tuyệt đối. Chúng ta có thể di chuyển toàn bộ nhân vật Player sang một dự án khác chỉ bằng cách sao chép thư mục Content/Characters/Player. Mọi thứ sẽ hoạt động vì tất cả các tham chiếu (references) đều nằm trong đó. Thiên đường cho DLC và Đóng gói (Chunking): Đây là cách duy nhất để quản lý các gói nội dung một cách hiệu quả. Chúng ta có thể dễ dàng nói với Unreal: “Hãy đóng gói toàn bộ thư mục Content/Maps/Jungle thành Chunk 10.” Khi người chơi muốn tải map này, game chỉ cần tải về file .pak của Chunk 10. Workflow liền mạch cho Artist \u0026 Designer: Khi làm việc trên nhân vật Player, mọi file họ cần đều nằm ngay trong một thư mục. Họ có thể dễ dàng duyệt qua, chỉnh sửa và liên kết các asset với nhau mà không cần rời khỏi “khu vực làm việc” của mình. Nhược điểm (Cons) Vấn đề nan giải về Asset dùng chung (The Shared Asset Dilemma): Đây là điểm yếu chí mạng. Một Material Master, một texture kim loại trầy xước, một bộ animation di chuyển cơ bản… được dùng cho TẤT CẢ các nhân vật sẽ được đặt ở đâu? Điều này thường dẫn đến sự ra đời của một thư mục Content/Shared, và nếu không được quản lý chặt chẽ, nó có thể trở thành một “bãi rác” chứa mọi thứ, làm phá vỡ triết lý ban đầu. Nguy cơ Trùng lặp cao: Vì sự tiện lợi, một artist có thể sẽ sao chép một texture từ thư mục Shared vào thư mục nhân vật của họ thay vì tạo một Material Instance. Điều này dẫn đến việc asset bị trùng lặp, làm tăng đáng kể kích thước của game. Có thể gây xung đột cho Lập trình viên: Nếu các lớp C++ cụ thể cho từng tính năng cũng được đặt trong các thư mục nội dung này, nó có thể làm xáo trộn cấu trúc Source và gây khó khăn cho việc quản lý code. I. Triết lý cốt lõi: Quy hoạch Thư mục là Luật! Trước khi đi vào chi tiết, nguyên tắc tối cao mà Allar’s Style Guide đặt ra là: Sự nhất quán và có tổ chức trong cấu trúc thư mục và quy tắc đặt tên là không thể thương lượng.\nTại sao? Khả năng dự đoán: Bất kỳ thành viên nào trong team, dù mới hay cũ, đều có thể tìm thấy một asset họ cần một cách nhanh chóng mà không cần phải hỏi ai. Họ biết rằng một Material sẽ nằm trong thư mục Materials và có tiền tố M_. Hiệu quả tìm kiếm: Content Browser của Unreal trở thành một công cụ cực kỳ mạnh mẽ khi chúng ta có thể lọc chính xác theo tiền tố (BP_, T_, M_…). Tránh sự hỗn loạn: Nó ngăn chặn việc các asset tạm thời, thử nghiệm, hoặc trùng lặp làm ô nhiễm dự án chính. II. Cấu trúc Lai Tối ưu - Phiên bản “Allar’s Certified” Chúng ta sẽ áp dụng mô hình “Hybrid City” nhưng với các quy tắc và tên thư mục cụ thể từ Allar’s Style Guide.\nA. Hạ tầng Ngầm (Code - Source/) - Nền móng Kỹ thuật Phần này vẫn tuân thủ nguyên tắc Quy hoạch theo Chức năng. Đây là nền móng C++ vững chắc, ít khi bị thay đổi bởi artist hay designer.\nSource/MyGameCore: Các hệ thống toàn cục, interfaces, các lớp helper. Source/MyGameFramework: Các lớp C++ cơ sở cho gameplay (CharacterBase, WeaponBase, GameStateBase…). Đây là cầu nối sang Content/Core. Source/GameFeatures/: Mỗi hệ thống gameplay lớn nên là một module riêng. Source/GameFeatures/Inventory Source/GameFeatures/AbilitySystem Source/GameFeatures/AI B. Bề nổi (Assets - Content/) - Các Khu phố và Tòa nhà Đây là nơi chúng ta áp dụng triệt để các quy tắc của Allar, kết hợp giữa Quy hoạch theo Chức năng và Quy hoạch theo Nội dung.\nContent/Core/: “Trung tâm Hành chính \u0026 Hạ tầng Chung”\nĐây là nơi chứa các asset nền tảng, được sử dụng trên toàn bộ dự án. Nó tương ứng trực tiếp với Source/MyGameFramework. Core/Blueprints/: Chứa các Blueprint cơ sở kế thừa trực tiếp từ C++ (BP_CharacterBase, BP_WeaponBase). Các designer sẽ tạo các Blueprint con từ những lớp này. Core/Data/: Chứa các Data Table và Data Asset định nghĩa các quy tắc game cơ bản. Core/Materials/: Chứa các Master Material, Material Function mà tất cả các asset khác sẽ tạo instance từ đó. Core/Input/: Chứa các Input Action và Input Mapping Context của hệ thống Enhanced Input. Content/Shared/: Sẽ được đặt ở cấp cao nhất của Content, và bản thân nó cũng cần có một cấu trúc bên trong rõ ràng, thường là theo chức năng:\nQuy tắc đóng gói: Khi thiết lập các quy tắc đóng gói (Packaging Rules) và Primary Asset Labels, toàn bộ thư mục Content/Shared sẽ được gán cho Chunk 0. Điều này đảm bảo rằng khi người chơi tải game lần đầu, họ sẽ có tất cả các asset nền tảng cần thiết để mọi gói nội dung khác (DLC, map mới) có thể hoạt động chính xác khi được tải về sau này.\nĐể giảm thiểu rủi ro, team phải tuân thủ các quy tắc nghiêm ngặt:\nQuy tắc #1: Phải có “Người gác cổng” (Strict Gatekeeping): Không ai được phép tự ý thêm asset vào Content/Shared. Phải có một hoặc vài người (thường là Art Director, Technical Art Lead, hoặc Lead Engineer) chịu trách nhiệm phê duyệt mọi thứ được đưa vào đây. Quy tắc #2: “Quy tắc Ba lần” (The Rule of Three): Một asset chỉ nên được xem xét để đưa vào Shared khi nó được yêu cầu sử dụng ở ba hoặc nhiều nơi khác nhau và riêng biệt. Nếu nó chỉ được dùng cho hai nhân vật, có thể tốt hơn là giữ nó ở một trong hai thư mục nhân vật đó và tham chiếu chéo. Quy tắc #3: Shared là “Chỉ đọc” với Hầu hết mọi người: Đối với đa số thành viên trong team, các asset trong Shared nên được coi là “read-only”. Họ chỉ nên tạo instance hoặc tham chiếu đến chúng. Việc chỉnh sửa một asset trong Shared phải là một quy trình có kiểm soát, có thể yêu cầu một buổi họp review ngắn. Quy tắc #4: Kiểm toán Định kỳ (Regular Audits): Cứ mỗi một hoặc hai tháng, “người gác cổng” nên rà soát lại thư mục Shared để tìm và loại bỏ các asset không còn được sử dụng hoặc những asset được thêm vào không đúng quy cách. Content/Characters/, Content/Weapons/, Content/Environments/, Content/Props/: “Các Khu Dân cư và Công trình Chuyên dụng”\nĐây là phần Quy hoạch theo Nội dung. Mỗi thư mục này chứa tất cả mọi thứ liên quan đến một thực thể cụ thể. Ví dụ với Content/Characters/CyberNinja/: BP_CyberNinja (kế thừa từ Core/Blueprints/BP_CharacterBase) Meshes/SK_CyberNinja Textures/T_CyberNinja_D, T_CyberNinja_N Materials/MI_CyberNinja (một instance của Core/Materials/M_Character_Master) Animations/A_CyberNinja_Attack Lợi ích cho Pak/Chunk: Cấu trúc tự chứa này làm cho việc đóng gói trở nên cực kỳ đơn giản. chúng ta có thể tạo một chunk ID cho toàn bộ thư mục Characters/CyberNinja. Nếu nhân vật này là một DLC, người chơi có thể tải về chỉ gói đó mà không ảnh hưởng đến phần còn lại của game. Tương tự với Maps/Jungle/. Content/Developers/: “Khu vực Thử nghiệm \u0026 Sandbox Cá nhân”\nĐây là một trong những quy tắc thiên tài nhất của Allar. Mỗi thành viên trong team sẽ có một thư mục con riêng trong này (ví dụ: Developers/JohnDoe/). Mục đích: Đây là nơi an toàn để mỗi người thử nghiệm, tạo các asset tạm thời, “chọc ngoáy” mà không làm ô nhiễm dự án chính. Quy tắc tối cao: Thư mục Content/Developers/ phải được thêm vào file .gitignore (hoặc các file ignore của Perforce). Nội dung trong này không bao giờ được commit lên version control. C. Sơ đồ Quy hoạch Tổng thể Đây là hình dung về cấu trúc lai cuối cùng của chúng ta:\n├── Source/ │ ├── MyGameCore/ │ └── GameFeatures/ │ └── Inventory/ │ └── Content/ ├── Core/ │ ├── Blueprints/ │ └── Materials/ │ ├── Characters/ │ └── CyberNinja/ │ ├── BP_CyberNinja.uasset │ ├── Meshes/ │ └── Textures/ │ ├── Maps/ │ └── Jungle/ │ ├── Map_Jungle.umap │ ├── Meshes/ │ └── Materials/ │ ├── GameFeatures/ │ └── Inventory/ │ ├── Data/ │ └── UI/ │ ├── Developers/ │ ├── JohnDoe/ (NEVER COMMIT) │ └── JaneSmith/ (NEVER COMMIT) │ └── _External/ # Chứa các asset từ bên ngoài (ví dụ: Megascans) │ ├── _Shared/ III. Ưu điểm Vượt trội của Mô hình Quy hoạch Lai này Tối ưu cho mọi vai trò: Lập trình viên có một cấu trúc code module hóa, sạch sẽ trong Source/. Artist/Designer có một cấu trúc nội dung trực quan, tự chứa trong Content/, cho phép họ làm việc độc lập. Technical Director có thể dễ dàng quản lý và tự động hóa quy trình đóng gói (packaging) dựa trên cấu trúc này. Sẵn sàng cho Tương lai (Future-Proof): DLC \u0026 Cập nhật: Việc thêm một gói nội dung mới (nhân vật, map) chỉ đơn giản là tạo một thư mục mới theo đúng quy chuẩn mà không cần tái cấu trúc lại toàn bộ dự án. Tối ưu hóa Phân phối: Cấu trúc này là nền tảng để chúng ta có thể phân phối game dưới dạng các “chunk” nhỏ. Người chơi có thể tải phần chơi chính trước, và tải các gói ngôn ngữ, các map độ phân giải cao, hoặc các phần chơi khác sau. Vận hành và Hỗ trợ đa nền tảng: Khi một lỗi xảy ra chỉ trên Android liên quan đến nhân vật CyberNinja, chúng ta biết chính xác cần phải kiểm tra các file trong Content/Characters/CyberNinja và các lớp C++ cơ sở mà nó kế thừa. Việc quản lý các phiên bản (develop, staging, production) trở nên dễ dàng hơn vì cấu trúc nhất quán giúp các công cụ CI/CD (như TeamCity) xác định và đóng gói các thay đổi một cách đáng tin cậy. Khả năng Mở rộng, Bảo trì và làm việc với Version Control Đây là lợi ích chiến lược lớn nhất khi chọn C++, quyết định khả năng “sống sót” và phát triển của dự án trong dài hạn.\nKiến trúc linh hoạt: Kết hợp Kế thừa (OOP) và Tập hợp (Composition) C++ cho phép chúng ta tận dụng triệt để các nguyên tắc OOP. Ví dụ, chúng ta có thể tạo một lớp ABaseWeapon định nghĩa các hành vi chung (bắn, nạp đạn). Sau đó, các lớp con ARifle, APistol có thể kế thừa và chuyên biệt hóa các hành vi đó.\nTuy nhiên, một kiến trúc hiện đại và linh hoạt hơn là kết hợp Kế thừa với Composition (Kiến trúc tập hợp các thành phần).\nTriển khai gợi ý của chúng ta: Thay vì một ARifle kế thừa mọi thứ từ ABaseWeapon, chúng ta tạo ra một lớp AWeapon cơ bản. Các chức năng cụ thể như “bắn đạn ghém” (ShotgunFireComponent), “ngắm bắn qua ống ngắm” ( ScopeComponent), hay “bắn tia laser” (LaserBeamComponent) sẽ được xây dựng dưới dạng các Actor Component. Tại sao đây là phương pháp vượt trội? “Cắm và Chạy” (Plug-and-Play): chúng ta có thể tạo ra một khẩu súng hoàn toàn mới trong Blueprint chỉ bằng cách lắp ghép các Component này lại với nhau, giống như lắp ráp các module Lego. Một khẩu súng trường tấn công có thể được tạo từ AWeapon + AutomaticFireComponent + ScopeComponent. Tái sử dụng tối đa: ScopeComponent không chỉ dùng cho súng, nó có thể được gắn vào cả ống nhòm hoặc các công cụ khác. Tránh “Địa ngục Kế thừa”: chúng ta sẽ không bị rơi vào tình huống tạo ra một cây kế thừa phức tạp, đa tầng, khó quản lý chỉ để chia sẻ một vài chức năng nhỏ. Cấu trúc Module và Version Control (Git): Xây dựng một “Thành phố” có quy hoạch Việc chia dự án thành các module (MyGameCore, MyGameInventory, MyGameAI…) giống như việc quy hoạch một thành phố thành các quận chuyên biệt.\nGiảm thiểu xung đột (Merge Conflicts): Khi các team làm việc trong các “quận” (module) riêng của mình, khả năng họ “xây dựng” chồng chéo lên nhau và gây ra xung đột trên Git sẽ giảm đi đáng kể. Đây là yếu tố sống còn để duy trì hiệu suất làm việc của một team lớn. Tăng tốc độ biên dịch: Unreal Build Tool có thể biên dịch các module song song. Một dự án được module hóa tốt sẽ có thời gian biên dịch nhanh hơn. chúng ta cũng có thể thiết lập để chỉ biên dịch lại những module có thay đổi. Sở hữu Code rõ ràng (Code Ownership): Mỗi module có thể có một “chủ sở hữu” hoặc team chịu trách nhiệm chính. Khi có lỗi phát sinh trong hệ thống túi đồ, mọi người đều biết cần phải liên hệ với team Inventory. Điều này tạo ra sự rõ ràng và trách nhiệm trong tổ chức. Tip \u0026 Trick cho Team: Tối ưu hóa quy trình làm việc 1. Hybrid Approach: “C++ xây Siêu xa lộ, Blueprint xây Nhà dân” Đây là triết lý làm việc cốt lõi giúp cân bằng giữa hiệu năng và tốc độ phát triển.\nVai trò của Lập trình viên C++:\nXây dựng các hệ thống nền tảng vững chắc và các “đường cao tốc” truyền dữ liệu hiệu năng cao. Không chỉ “phơi bày” các hàm (UFUNCTION), các biến (UPROPERTY) với các meta, property, họ còn định nghĩa các \" kênh sự kiện\" bằng delegate ( UPROPERTY(BlueprintAssignable)) để Blueprint có thể “lắng nghe” và phản ứng lại các sự kiện từ C++ (ví dụ: OnHealthChanged, OnItemAddedToInventory). Họ tạo ra các “hợp đồng” dữ liệu thông qua UDataAsset và UDataTable. Triển khai gợi ý của chúng ta (Tách biệt Dữ liệu và Logic):\nLập trình viên C++ sẽ tạo ra các lớp cơ sở như UItemData (kế thừa từ UDataAsset). Game Designer, thay vì chỉnh sửa BP_HealthPotion, giờ đây sẽ tạo và chỉnh sửa một asset dữ liệu là DA_HealthPotion. Asset này chứa mọi thông số: tên, icon, số lượng máu hồi phục, hiệu ứng âm thanh khi sử dụng. Lớp AItemActor (trong C++) hoặc BP_ItemActor (trong Blueprint) sẽ chỉ có một biến duy nhất là ItemData (một con trỏ tới UItemData). Toàn bộ hành vi và hiển thị của nó sẽ được điều khiển bởi dữ liệu trong asset đó. Kết quả: Dev và Designer có thể làm việc song song. Designer có thể tạo ra hàng trăm item mà không cần sự can thiệp của dev, và dev có thể tối ưu hóa logic xử lý item mà không sợ làm hỏng dữ liệu của Designer. Xung đột trên version control gần như bằng không. 2. Lựa chọn IDE: JetBrains Rider - Nâng cấp Trạm Tác chiến của chúng ta Việc lựa chọn Môi trường phát triển tích hợp (IDE) không đơn thuần là sở thích cá nhân. Đó là một quyết định chiến lược ảnh hưởng trực tiếp đến năng suất, chất lượng code và tốc độ làm việc của cả team. Trong thế giới Unreal Engine, việc chuyển từ Visual Studio sang JetBrains Rider không chỉ là thay đổi một công cụ, mà là nâng cấp từ một chiếc xe gia đình đáng tin cậy lên một siêu xe điện được trang bị AI, được thiết kế để chinh phục những chặng đường phức tạp nhất.\nTích hợp sâu với Unreal Engine: IDE “Nói” ngôn ngữ của Game Dev Rider không chỉ đọc code C++; nó “hiểu” cách Unreal Engine suy nghĩ.\nPhân tích Code thông minh: Rider phân tích code của chúng ta trong thời gian thực và đưa ra các cảnh báo mà chỉ người làm Unreal mới hiểu. Nó sẽ là người đồng đội mẫn cán, nhắc nhở chúng ta khi: “chúng ta đã quên gọi Super::BeginPlay()”, “UPROPERTY này thiếu GENERATED_BODY()”, hay thậm chí là phát hiện các lỗi sai chính tả, ngữ pháp trong comment và tên biến, giúp code base của chúng ta luôn sạch sẽ và chuyên nghiệp. Quản lý Dự án Tích hợp: Thay vì phải mở Unreal Editor để tạo một Module hay Plugin mới, chúng ta có thể thực hiện việc đó ngay trong Rider. Nó sẽ tự động tạo ra toàn bộ cấu trúc file cần thiết (.h, .cpp, Build.cs), cập nhật file .uproject và .uplugin. Đây là một sự tự động hóa quy trình giúp tiết kiệm thời gian và giảm thiểu sai sót do con người. Các tính năng “Thay đổi cuộc chơi”: Tối ưu hóa từng cú click chuột Kết nối Blueprint: “Cây cầu” ma thuật này cho phép chúng ta tìm kiếm một hàm C++ và xem nó được sử dụng ở đâu, không chỉ trong code mà còn ở tất cả các file Blueprint. Khi chúng ta đổi tên một UFUNCTION, Rider sẽ tự động cập nhật nó ở mọi nơi, giúp chúng ta tái cấu trúc code một cách tự tin mà không sợ làm hỏng logic của game designer. Unreal Engine Naming C++ Convention: Tích hợp Git liền mạch: Rider biến việc làm việc với Git từ một công việc dòng lệnh phức tạp thành một trải nghiệm trực quan. chúng ta có thể xem so sánh khác biệt (diff) ngay trong trình soạn thảo, xem ai đã viết từng dòng code ( git blame), và duyệt qua lịch sử commit dưới dạng biểu đồ. Quan trọng nhất, chúng ta có thể commit từng phần (partial commit) của một file. Điều này khuyến khích việc tạo ra các commit nhỏ, nguyên tử (atomic commits), giúp lịch sử dự án trở nên cực kỳ rõ ràng và dễ theo dõi. Trung tâm phát triển Android tất cả trong một: Rider tích hợp gần như hoàn chỉnh các công cụ của Android Studio. chúng ta có thể mở Logcat để xem log từ thiết bị, mở Terminal để chạy lệnh ADB, và quản lý Emulator trực tiếp trong IDE. Nó loại bỏ hoàn toàn nhu cầu phải chạy Android Studio song song, tiết kiệm tài nguyên máy và giúp chúng ta tập trung vào một môi trường duy nhất. AI Assistant \u0026 Local History: Trợ lý ảo và Cỗ máy thời gian AI Assistant: Đây là một lập trình viên cặp (pair programmer) ảo. Nó có thể giúp chúng ta viết code boilerplate, giải thích các đoạn code phức tạp, tìm lỗi, và đặc biệt là tự động viết tài liệu (documentation) cho các hàm của chúng ta theo chuẩn ngành, một công việc tốn nhiều thời gian nhưng cực kỳ quan trọng. Local History: Đây là lớp lưới an toàn cuối cùng của chúng ta. Nó tự động lưu lại lịch sử thay đổi của tất cả các file, hoàn toàn độc lập với Git. Nếu chúng ta vô tình xóa mất một file hay một đoạn code quan trọng mà chưa commit, Local History cho phép chúng ta quay ngược thời gian và khôi phục lại nó một cách dễ dàng. Sức mạnh của Hệ sinh thái JetBrains: Khi các công cụ kết hợp thành một Dàn nhạc Giá trị thực sự của Rider được nhân lên gấp bội khi chúng ta tích hợp nó với các công cụ khác trong hệ sinh thái JetBrains,tạo ra một quy trình làm việc chuyên nghiệp, khép kín.\nDataGrip (Quản lý Database): Rider có sẵn một trình quản lý database cơ bản. Khi chúng ta cần các công cụ mạnh mẽ hơn để làm việc với backend database của game (lưu trữ tài khoản, vật phẩm người chơi), DataGrip cung cấp một giao diện chuyên dụng. Vì cùng một hệ sinh thái, trải nghiệm người dùng và các phím tắt sẽ cực kỳ quen thuộc. TeamCity (CI/CD): Đây là máy chủ Tích hợp và Triển khai liên tục của JetBrains. chúng ta có thể cấu hình TeamCity để tự động theo dõi repository Git của chúng ta. Mỗi khi có commit mới, nó sẽ tự động build các bản Client và Server cho mọi nền tảng, chạy unit test, và triển khai lên server thử nghiệm. YouTrack (Quản lý dự án \u0026 Lỗi): Tích hợp YouTrack với Rider cho phép chúng ta xem thông tin ticket ngay trong IDE. Khi chúng ta làm việc trên một nhánh mới, chúng ta có thể liên kết nó với một ticket. Mỗi commit sẽ tự động được ghi nhận vào ticket đó, tạo ra một luồng thông tin minh bạch từ yêu cầu ban đầu của designer đến dòng code cuối cùng của developer. Thiết lập Target cho Dedicated Server: “Phòng phẫu thuật” tách Client và Server Phần này mô tả một trong những bước kỹ thuật quan trọng nhất.\nTip \u0026 Trick cho Team (Mở rộng) Sử dụng Preprocessor Directives một cách chiến lược: Triển khai gợi ý của chúng ta: Các chỉ thị tiền xử lý không chỉ giới hạn ở #if UE_SERVER. chúng ta có thể kết hợp chúng để tạo ra các logic cực kỳ linh hoạt: #if PLATFORM_WINDOWS \u0026\u0026 WITH_EDITOR: Code chỉ chạy trong Editor trên Windows. #if UE_BUILD_SHIPPING: Code sẽ bị loại bỏ trong bản build cuối cùng cho người chơi (dùng để loại bỏ các công cụ gian lận/debug). #if WITH_MYPLUGIN_NAME: Code chỉ được biên dịch nếu một plugin cụ thể nào đó đang được bật. Điều này giúp giữ cho code base của chúng ta duy nhất nhưng có thể thích ứng với mọi nền tảng và mọi cấu hình build, một yếu tố cực kỳ quan trọng để bảo trì dự án trong dài hạn. Giai đoạn 2.5: Kiến trúc Gameplay Multiplayer Nâng cao - Xây dựng những cỗ máy Lego phức tạp Chúng ta đã nắm vững các viên gạch Replication, Roles, và RPCs. Bây giờ là lúc tìm hiểu các bản thiết kế nâng cao để xây dựng những hệ thống phức tạp như hệ thống kỹ năng, trang bị, hay AI một cách hiệu quả và dễ mở rộng.\n1. Bộ Ba Quyền Lực: GameState, PlayerState và PlayerController Ngoài Character, Unreal cung cấp các lớp cốt lõi mà mọi lập trình viên multiplayer phải nắm vững.\nAGameStateBase (GameState): Bảng điểm của trận đấu\nNó là gì? Một Actor đặc biệt, tồn tại duy nhất trên server và được sao chép (replicate) đến tất cả client. Nó chứa trạng thái chung của toàn bộ trận đấu. Tại sao cần? Đây là nơi để lưu trữ các thông tin mà mọi người chơi cần biết: thời gian còn lại của trận đấu, danh sách người chơi, đội nào đang thắng, trạng thái của các mục tiêu trong map… Tip \u0026 Trick: Khi một client mới kết nối vào giữa trận, GameState là thứ đầu tiên họ nhận được để “bắt kịp” trạng thái hiện tại của game. Hãy đặt mọi thông tin công khai, toàn cục vào đây. APlayerState (PlayerState): “Căn cước công dân” của người chơi\nNó là gì? Một Actor đi kèm với mỗi người chơi, tồn tại trên server và được sao chép đến tất cả client. Nó chứa trạng thái cá nhân của một người chơi, tách biệt với nhân vật mà họ đang điều khiển. Tại sao cần? Đây là nơi lưu trữ các thông tin bền vững của người chơi trong suốt phiên chơi, ngay cả khi họ chết và hồi sinh (nhân vật cũ bị hủy, nhân vật mới được tạo ra). Ví dụ: tên người chơi, điểm số, số mạng giết được, ping, đội… Tip \u0026 Trick: Đừng bao giờ lưu điểm số hay tên người chơi trực tiếp trong lớp Character. Hãy lưu chúng trong PlayerState. Character chỉ nên chứa các thông tin tạm thời như máu, đạn. APlayerController (PlayerController): Linh hồn của người chơi\nNó là gì? Là đại diện cho người chơi con người trong game. Nó tồn tại trên server và client sở hữu nó. Nó nhận input và “chiếm hữu” (possess) một Pawn (như Character) để điều khiển. Tại sao cần? Đây là kênh giao tiếp chính từ client lên server. Các RPCs yêu cầu hành động (bắn súng, dùng kỹ năng) thường được đặt ở đây hoặc trong Character. Các logic không liên quan đến hình thể nhân vật (như hiển thị UI, quản lý menu) nên nằm ở PlayerController. 2. Gameplay Ability System (GAS): Bộ Lego Technic cho Kỹ năng và Thuộc tính Nó là gì? Một framework cực kỳ mạnh mẽ và phức tạp do chính Epic Games phát triển và sử dụng trong các game như Fortnite, Paragon. Nó cung cấp sẵn một bộ khung hoàn chỉnh để tạo ra các kỹ năng, hiệu ứng (buff/debuff), và thuộc tính (máu, mana, sức mạnh…). Tại sao nên dùng? Tối ưu cho mạng: GAS được thiết kế từ đầu cho game multiplayer, xử lý sẵn các vấn đề về dự đoán (prediction) trên client, giúp kỹ năng có cảm giác phản hồi ngay lập tức. Dễ mở rộng: Thay vì hard-code các kỹ năng, chúng ta có thể tạo ra chúng dưới dạng các asset riêng biệt. Game designer có thể tự do tạo và chỉnh sửa kỹ năng mà không cần đụng đến code. Quản lý phức tạp: Dễ dàng xử lý các tương tác phức tạp như: “Kỹ năng này gây 50 sát thương lửa, làm chậm 30% trong 5 giây, và hồi 10 mana cho người dùng nếu mục tiêu đang bị đóng băng.” Tip \u0026 Trick: Học GAS là một khoản đầu tư lớn nhưng cực kỳ xứng đáng cho các game có hệ thống combat phức tạp (RPG, MOBA, Action). Hãy bắt đầu tìm hiểu nó sớm. 3. Lag Compensation: Bắn trúng “bóng ma” Vấn đề là gì? Khi chúng ta (Client A) bắn vào địch (Client B), chúng ta bắn vào vị trí chúng ta nhìn thấy trên màn hình. Nhưng do ping, vị trí đó là vị trí của Client B cách đây 50ms. Khi gói tin của chúng ta đến server, Client B đã di chuyển đến một vị trí khác. Server sẽ nói chúng ta bắn trượt. Cảm giác cực kỳ khó chịu. Giải pháp (Lag Compensation): Khi Server nhận được yêu cầu bắn từ Client A, nó sẽ không kiểm tra ngay lập tức. Nó sẽ “quay ngược thời gian” của thế giới game lại một khoảng bằng đúng ping của Client A. Nó sẽ tạm thời di chuyển tất cả các nhân vật khác về vị trí của họ tại thời điểm đó. Bây giờ, nó mới thực hiện việc kiểm tra bắn. Kết quả sẽ khớp với những gì Client A đã thấy. Sau đó, nó trả thế giới game về lại thời điểm hiện tại. Tip \u0026 Trick: May mắn là CharacterMovementComponent đã tự động xử lý việc này cho chuyển động. Tuy nhiên, đối với việc bắn súng (line trace) hoặc các kỹ năng có mục tiêu, chúng ta phải tự mình xây dựng hệ thống này. Đây là một trong những kỹ thuật khó nhưng bắt buộc phải có cho các game hành động bắn súng. Hãy nghiên cứu sâu về nó. 3. Cấu hình Project Settings: Chỉ dẫn cho Server hoạt động Làm như thế nào?\nServer Default Map: Mở Edit \u003e Project Settings \u003e Maps \u0026 Modes. Tìm đến mục Server Default Map và chọn bản đồ mà chúng ta muốn server tự động tải khi nó khởi động. Thường đây sẽ là một bản đồ menu chính hoặc một “lobby map”. Packaging Maps: Trong Project Settings \u003e Packaging, cuộn xuống và nhấn vào mũi tên mở rộng ở dưới cùng để hiển thị các cài đặt nâng cao. Trong mục List of Maps to Include in a Packaged Build, thêm vào tất cả các bản đồ mà game của chúng ta sẽ sử dụng, bao gồm cả bản đồ default của server và tất cả các bản đồ gameplay khác. Tại sao lại làm như thế?\nTự động hóa khởi động server: Việc thiết lập Server Default Map cho phép chúng ta khởi động server mà không cần truyền thêm tham số dòng lệnh chỉ định bản đồ. Server sẽ tự biết phải tải bản đồ nào đầu tiên. Đảm bảo tài sản (assets) được đóng gói: Quá trình đóng gói (packaging) của Unreal chỉ tự động “nấu” (cook) và đưa vào bản build các assets được tham chiếu từ một “root” nào đó (thường là các bản đồ). Nếu chúng ta không thêm các bản đồ vào danh sách này, các assets chỉ được sử dụng trong bản đồ đó có thể sẽ không được đóng gói, dẫn đến lỗi \" Can’t find file for package…\" khi server cố gắng chuyển đến bản đồ đó. Tip \u0026 Trick cho Team:\nTạo một bản đồ “dummy” cho server: Đôi khi, chúng ta không muốn server khởi động ngay vào một bản đồ gameplay nặng nề. Hãy tạo một bản đồ trống, siêu nhẹ, đặt tên là Entry hoặc ServerEntry và đặt nó làm Server Default Map. Từ bản đồ này, server có thể thực hiện các tác vụ khởi tạo ban đầu trước khi chuyển sang bản đồ gameplay thực sự. Sử dụng Primary Asset Labels: Đối với các dự án lớn, việc quản lý danh sách map thủ công có thể trở nên khó khăn. Hãy tìm hiểu về hệ thống “Primary Asset Labels” trong Project Settings \u003e Asset Manager. Nó cho phép chúng ta tự động đưa các assets (bao gồm cả map) vào bản build dựa trên các quy tắc và nhãn mà chúng ta định nghĩa, thay vì phải thêm từng cái một vào danh sách. Phần 4: Git Submodule - Nghệ thuật lắp ghép “Lego” cho Dự án Hãy tưởng tượng dự án Unreal Engine của chúng ta là một công trình Lego phức tạp. Phần mã nguồn C++ và các assets chính củachúng ta là những viên gạch nền cơ bản. Các plugin và thư viện bên ngoài (ví dụ: plugin về AI, hệ thống UI nâng cao, OnlineSubsystem…) chính là những bộ Lego chuyên biệt, độc đáo mà chúng ta muốn gắn vào công trình của mình.\nGit Submodule không sao chép những bộ Lego đó vào thùng gạch của chúng ta. Thay vào đó, nó ghi lại một tờ giấy nhớ: “Tạivị trí này, hãy lấy bộ Lego ‘AwesomePlugin’ phiên bản 1.2 (chính xác là mảnh ghép có mã số abc1234) và lắp nó vào đây”.\nPhiên bản 1.2 hay mã số abc1234 chính là commit hash của repository plugin đó.\nĐây là nguyên tắc cốt lõi: Repo chính chỉ lưu trữ một con trỏ (pointer) đến một commit cụ thể của submodule, chứ không phải toàn bộ lịch sử của nó.\n1. Nền tảng không thể thiếu: Git LFS và .gitignore Trước khi lắp ghép, sàn nhà của chúng ta phải sạch sẽ.\nTại sao Git LFS là bắt buộc?\nGit được sinh ra để quản lý code (file text), nó sẽ lưu lại mọi thay đổi nhỏ nhất của file. Với các file nhị phân lớn như .uasset, .fbx, .png, chỉ cần thay đổi 1 pixel, Git sẽ coi đó là một file hoàn toàn mới và lưu trữ một bản sao đầy đủ. Điều này khiến repository phình to lên hàng chục, hàng trăm GB một cách chóng mặt, việc clone hay pull trở thành cực hình. Git LFS giải quyết bằng cách: Thay vì lưu file lớn vào Git, nó lưu file đó lên một server riêng và chỉ để lại một file text “con trỏ” vài trăm byte trong repository. Khi chúng ta checkout, LFS sẽ tự động tải file lớn đó về. Tại sao .gitignore lại quan trọng?\nUnreal Engine tự động sinh ra rất nhiều file và thư mục tạm thời trong quá trình làm việc (như Intermediate, Saved, DerivedDataCache). Các file này có dung lượng rất lớn, đặc thù cho từng máy và không nên được đưa vào quản lý phiên bản. Một file .gitignore chuẩn sẽ yêu cầu Git “làm lơ” các thư mục này, giữ cho repository của chúng ta gọn nhẹ và chỉ chứa những gì thực sự cần thiết. Tip Trick cho Team:\nThiết lập một lần: Lead của team nên là người thiết lập file .gitattributes (cho LFS) và .gitignore chuẩn ngay từ đầu. Mọi thành viên chỉ việc clone và làm theo. Kiểm tra trước khi commit: Luôn chạy git status trước khi commit để đảm bảo không có file rác nào (như các file trong thư mục Saved) vô tình được thêm vào. 2. Chiến lược sử dụng Submodule tối ưu Đây là phần nâng cao, giúp team của chúng ta không bị rối khi dự án phình to.\nChiến lược 1: “Fork First” - Luôn làm chủ các dependency của chúng ta Không bao giờ thêm submodule trực tiếp từ repository gốc của một plugin bên thứ ba. Hãy luôn fork nó về organisation GitHub/GitLab của team chúng ta trước.\nLàm như thế nào?\nVào trang GitHub của plugin, nhấn nút “Fork”. Khi thêm submodule, hãy dùng URL của repository chúng ta vừa fork: git submodule add https://github.com/MyTeam/AwesomePlugin_Fork.git Plugins/AwesomePlugin Tại sao lại làm như thế?\nToàn quyền kiểm soát: Điều gì xảy ra nếu plugin gốc có lỗi nghiêm trọng ảnh hưởng đến game của chúng ta, nhưng tác giả lại không sửa? Với bản fork, team chúng ta có thể tự mình vào sửa lỗi, commit và push lên bản fork đó. An toàn khi cập nhật: chúng ta có thể thoải mái kéo các cập nhật mới nhất từ repository gốc (upstream) về bản fork của mình, kiểm thử cẩn thận trước khi quyết định tích hợp vào dự án chính. chúng ta không bị ép phải cập nhật ngay lập tức. Tùy biến: chúng ta có thể thêm các tính năng riêng cho plugin để phù hợp với game của mình mà không ảnh hưởng đến ai. Chiến lược 2: “Plugin Meta-Repo” - Tạo một “Hộp dụng cụ” Plugin Khi dự án sử dụng 5-10 plugin trở lên, việc quản lý từng cái một trong repo chính sẽ rất lộn xộn. Giải pháp là tạo ra một repository trung gian.\nLàm như thế nào?\nTạo một repository mới, đặt tên là MyGame-Plugins. Trong repository này, hãy thêm tất cả các plugin chúng ta cần dưới dạng submodule của nó. # Bên trong repo MyGame-Plugins git submodule add https://github.com/MyTeam/AwesomePlugin_Fork.git AwesomePlugin git submodule add https://github.com/MyTeam/AnotherPlugin_Fork.git AnotherPlugin git commit -m \"Add required plugins\" Bây giờ, trong repository game chính, chúng ta chỉ cần thêm duy nhất một submodule: git submodule add https://github.com/MyTeam/MyGame-Plugins.git Plugins Tại sao lại làm như thế?\nGọn gàng: Repository chính của game sẽ cực kỳ sạch sẽ, chỉ có một submodule Plugins thay vì một danh sách dài. Quản lý tập trung: Một người (ví dụ Tech Lead) có thể chịu trách nhiệm quản lý repository MyGame-Plugins. Khi cần cập nhật một plugin nào đó, họ sẽ cập nhật trong “hộp dụng cụ” này, kiểm thử, rồi commit. Team dev chỉ cần cập nhật một submodule duy nhất là Plugins. Tái sử dụng: Nếu công ty chúng ta có nhiều dự án game, “hộp dụng cụ” plugin này có thể được tái sử dụng cho tất cả các dự án. Chiến lược 3: Cấu trúc Repo cho Dev và Artist - Monorepo là lựa chọn hàng đầu Phân chia folder như thế nào?\nCách tiếp cận hiệu quả nhất cho hầu hết các team làm game Unreal là Monorepo - tức là tất cả mọi thứ (code, art, sound…) đều nằm chung trong một repository lớn. Sự phân chia nên nằm ở cấp độ thư mục, với quy tắc rõ ràng: Content/Art/Characters: Chứa các model, texture, material của nhân vật. Content/Art/Environments: Chứa các assets môi trường. Content/Blueprints/Characters: Chứa các Blueprint liên quan đến nhân vật. Source/MyGame/Public: Chứa các file header C++. Source/MyGame/Private: Chứa các file cpp C++. Tại sao Monorepo lại hiệu quả?\nAtomic Commits (Commit nguyên tử): Một tính năng mới thường đòi hỏi cả sự thay đổi về code (dev) và art ( artist). Monorepo cho phép chúng ta thực hiện một commit duy nhất bao gồm cả hai thay đổi này. Điều này giúp lịch sử dự án cực kỳ dễ theo dõi. Khi cần revert một tính năng, chúng ta chỉ cần revert một commit là xong. Dễ dàng đồng bộ: Mọi người luôn ở trên cùng một phiên bản của tất cả mọi thứ. Không có chuyện code chạy được nhưng art lại là phiên bản cũ và gây lỗi. Submodule chỉ dành cho bên thứ ba: Trong mô hình này, submodule chỉ nên được sử dụng cho các code/thư viện/plugin từ bên ngoài, không phải để phân tách các phần nội bộ của dự án. 3. Quy trình làm việc (Workflow) hàng ngày với Submodule Đây là kim chỉ nam cho mọi thành viên trong team.\nA. Lần đầu tiên lấy dự án về: git clone --recurse-submodules Lệnh này sẽ clone repo chính, sau đó tự động clone tất cả các submodule được đăng ký.\nB. Bắt đầu một ngày làm việc (lấy code mới nhất về):\ngit pull (Lấy code mới nhất của repo chính. Có thể con trỏ submodule đã bị thay đổi bởi người khác). git submodule update --recursive (Đọc con trỏ mới và cập nhật code của submodule cho khớp). Đây là quy trình 2 bước bắt buộc. Nếu chỉ git pull, code submodule của chúng ta sẽ bị cũ và gây lỗi biên dịch. C. Cập nhật một plugin lên phiên bản mới (Dành cho Lead):\ncd Plugins/AwesomePlugin (Đi vào thư mục của submodule). git checkout main (Chuyển sang nhánh chính). git pull (Kéo code mới nhất của plugin về). cd ../.. (Quay trở lại thư mục gốc của dự án chính). git status (chúng ta sẽ thấy dòng modified: Plugins/AwesomePlugin (new commits)). git add Plugins/AwesomePlugin git commit -m \"Feat: Update AwesomePlugin to version 2.0 for new feature X\" git push (Đẩy “tờ giấy nhớ” mới lên cho cả team). Sau khi Lead push, các thành viên khác sẽ thực hiện quy trình B để nhận bản cập nhật. D. Sửa lỗi/thêm tính năng tùy chỉnh vào plugin (Dành cho Dev):\ncd Plugins/AwesomePlugin (Đi vào thư mục của submodule đã fork). Thực hiện các thay đổi code… git add . git commit -m \"Fix: Fixed a critical crash when...\" git push (Push thay đổi lên repository fork của plugin). Làm theo các bước từ 4 đến 8 của quy trình C để cập nhật con trỏ trong repo chính. Giai đoạn 2: Xây dựng và Phát triển - Lắp ráp các khối Lego Gameplay Nếu Giai đoạn 1 là việc chuẩn bị “xưởng lắp ráp” và “bản thiết kế” (Project Setup, Git), thì Giai đoạn 2 chính là lúc chúng ta thực sự lắp ráp các cỗ máy phức tạp từ những viên gạch Lego cơ bản. Mỗi tính năng, từ việc di chuyển, bắn súng, đến nhặt đồ, đều là một cỗ máy nhỏ được lắp ráp từ 3 loại “gạch Lego” mạng cốt lõi: Replication, Network Roles, và RPCs.\n1. Lập trình Gameplay cho Multiplayer: Bộ gạch Lego nền tảng Hãy tưởng tượng Server là người Thợ Cả (Master Builder), người duy nhất có bản thiết kế gốc và quyền quyết định cuối cùng. Mỗi Client là một người Học Việc, đang cố gắng xây một bản sao y hệt mô hình của Thợ Cả.\nA. Replication (Sao chép): “Thợ Cả thông báo sự thay đổi” Đây là loại gạch Lego cơ bản nhất, dùng để đồng bộ hóa trạng thái (state) của các vật thể.\nPhép loại suy Lego: Khi Thợ Cả (Server) thay đổi màu của một viên gạch trên mô hình gốc từ xanh sang đỏ, họ sẽ hô lên cho tất cả Học Việc (Clients): “Viên gạch ở vị trí XYZ giờ là màu đỏ!”. Mọi người Học Việc nghe thấy và thay đổi viên gạch tương ứng trên bản sao của họ.\nTại sao nó quan trọng?\nNó đảm bảo rằng thế giới game của mọi người chơi trông giống nhau. Máu của một nhân vật, số đạn trong băng, vị trí của một cánh cửa… tất cả đều là “trạng thái” cần được đồng bộ. Đây là cách hiệu quả nhất để giữ cho dữ liệu nhất quán mà không cần gửi tin nhắn liên tục. Làm như thế nào trong C++?\nTrong file .h của Actor, chúng ta phải bật chế độ replication: bReplicates = true; trong Constructor. Đánh dấu các biến cần đồng bộ bằng UPROPERTY(Replicated) hoặc UPROPERTY(ReplicatedUsing=FunctionName). Override hàm GetLifetimeReplicatedProps. // MyCharacter.h #pragma once #include \"GameFramework/Character.h\" #include \"MyCharacter.generated.h\" UCLASS() class MYGAME_API AMyCharacter : public ACharacter { GENERATED_BODY() public: AMyCharacter(); // Biến này sẽ được đồng bộ từ Server xuống các Client UPROPERTY(ReplicatedUsing = OnRep_CurrentHealth) float CurrentHealth; UFUNCTION() void OnRep_CurrentHealth(); // Hàm này sẽ được gọi trên Client mỗi khi CurrentHealth thay đổi protected: virtual void GetLifetimeReplicatedProps(TArray\u003cFLifetimeProperty\u003e\u0026 OutLifetimeProps) const override; }; // MyCharacter.cpp #include \"Net/UnrealNetwork.h\" AMyCharacter::AMyCharacter() { bReplicates = true; // Bật chức năng \"Lego\" cho Actor này } void AMyCharacter::GetLifetimeReplicatedProps(TArray\u003cFLifetimeProperty\u003e\u0026 OutLifetimeProps) const { Super::GetLifetimeReplicatedProps(OutLifetimeProps); // Đăng ký biến CurrentHealth vào hệ thống replication DOREPLIFETIME(AMyCharacter, CurrentHealth); } void AMyCharacter::OnRep_CurrentHealth() { // Đây là nơi hoàn hảo để cập nhật thanh máu trên UI của Client // Vì nó chỉ chạy trên Client khi máu thực sự thay đổi. } OOP \u0026 Tip Trick:\nNguyên tắc Đóng gói (Encapsulation): Không bao giờ để Client trực tiếp thay đổi các biến Replicated. Hãy làm cho CurrentHealth thành private hoặc protected và tạo ra một hàm public như TakeDamage(float Damage) để xử lý. Việc thay đổi máu thực sự chỉ nên xảy ra trên Server. ReplicatedUsing là người chúng ta tốt nhất của chúng ta: Dùng nó để kích hoạt các hiệu ứng hình ảnh/âm thanh trên Client (như cập nhật UI, chạy hiệu ứng máu bắn ra) ngay khi một biến được cập nhật. Điều này giúp tách biệt logic gameplay (trên server) và logic hiển thị (trên client). B. Network Roles (Vai trò mạng): “Ai là Thợ Cả?” Hệ thống này xác định quyền hạn của mỗi máy tính đối với một Actor cụ thể.\nPhép loại suy Lego:\nAuthority (Thợ Cả): Máy tính có bản thiết kế gốc của một Actor (luôn là Server cho các Actor trong thế giới game). Chỉ nó mới có quyền thay đổi Actor đó. Autonomous Proxy (Học Việc tự chủ): Client đang điều khiển trực tiếp Actor đó (ví dụ: nhân vật của chính chúng ta). Client này có thể gửi yêu cầu cho Thợ Cả nhanh hơn. Simulated Proxy (Học Việc quan sát): Client chỉ đang nhìn thấy một Actor do người khác điều khiển. Họ chỉ nhận thông tin cập nhật từ Thợ Cả. Tại sao nó quan trọng?\nChống gian lận (Anti-Cheat): Đây là nền tảng của mô hình Server-Authoritative. Một Client không thể tự quyết định “OK, máu của tôi bây giờ là 1000” vì nó không có Authority. Mọi quyết định quan trọng về gameplay (trừ máu, tính sát thương, cho vật phẩm) đều phải được kiểm tra qua HasAuthority(). Tối ưu hóa: Logic AI, các tính toán phức tạp chỉ cần chạy trên Server (Authority), không cần chạy trên Client. Làm như thế nào?\nSử dụng if (HasAuthority()) hoặc if (GetLocalRole() == ROLE_Authority) để bao bọc các đoạn code chỉ Server mới được phép thực thi. void AMyCharacter::TakeDamage(float DamageAmount) { // Chỉ Thợ Cả (Server) mới có quyền trừ máu if (HasAuthority()) { CurrentHealth = FMath::Max(0.0f, CurrentHealth - DamageAmount); // Server thay đổi giá trị. Sau đó, hệ thống Replication sẽ tự động // gửi giá trị CurrentHealth mới này xuống cho tất cả các Client. } } OOP \u0026 Tip Trick:\nAuthority Pattern: Đây là một Design Pattern cơ bản trong lập trình mạng. Hãy tập thói quen luôn tự hỏi: “Đoạn code này có thay đổi trạng thái của game không? Nếu có, nó có đang được bọc trong if (HasAuthority()) không?”. Trong Blueprint, chúng ta có thể dùng node Switch Has Authority. C. Remote Procedure Calls (RPCs): “Kênh giao tiếp giữa Thợ Cả và Học Việc” RPCs là các “mệnh lệnh” hoặc “yêu cầu” dưới dạng hàm được gọi qua mạng. Chúng dùng cho các sự kiện (events), không phải trạng thái.\nPhép loại suy Lego:\nServer RPC (Yêu cầu lên Thợ Cả): Người Học Việc (Client) nói với Thợ Cả (Server): “Thưa ngài, tôi muốn bắn khẩu súng này!”. Client RPC (Mệnh lệnh cho một Học Việc): Thợ Cả nói riêng với người Học Việc vừa yêu cầu: “OK, khẩu súng của cậu bị giật mạnh, hãy hiển thị hiệu ứng đó trên màn hình của cậu đi!”. Multicast RPC (Thông báo cho tất cả): Thợ Cả hô to cho tất cả mọi người: “Mọi người chú ý! Vừa có một tiếng súng nổ ở vị trí XYZ, hãy chạy hiệu ứng và âm thanh!”. Tại sao nó quan trọng?\nĐây là cách duy nhất để Client có thể yêu cầu Server thực hiện một hành động. Client không thể tự mình bắn súng, họ phải “xin phép” Server. Dùng để kích hoạt các hiệu ứng tức thời, không đáng tin cậy (unreliable) như tiếng bước chân, hoặc các sự kiện quan trọng, đáng tin cậy (reliable) như sử dụng một kỹ năng. Làm như thế nào?\nSử dụng các macro UFUNCTION đặc biệt trong file .h. // MyCharacter.h // Client gọi hàm này, nhưng nó sẽ thực thi trên Server UFUNCTION(Server, Reliable, WithValidation) void Server_FireWeapon(); // Server gọi hàm này, nó sẽ thực thi trên tất cả các Client UFUNCTION(NetMulticast, Unreliable) void Multicast_PlayFireFX(); // MyCharacter.cpp // Hàm kiểm tra xem yêu cầu từ Client có hợp lệ không bool AMyCharacter::Server_FireWeapon_Validate() { return true; /* Thêm logic kiểm tra chống spam ở đây */ } // Logic thực thi trên Server sau khi Client yêu cầu void AMyCharacter::Server_FireWeapon_Implementation() { // Kiểm tra xem nhân vật có đủ đạn, có đang bị khống chế không... // -\u003e Logic gameplay cốt lõi chỉ chạy trên Server if (CanFire()) { // Bắn một tia đạn (line trace) // Trừ đạn // Gây sát thương nếu trúng đích //... // Sau khi xử lý xong, thông báo cho tất cả mọi người Multicast_PlayFireFX(); } } void AMyCharacter::Multicast_PlayFireFX_Implementation() { // Chạy hiệu ứng tia lửa đầu nòng, âm thanh súng nổ... // Đoạn code này sẽ chạy trên Server VÀ tất cả các Client } void AMyCharacter::Fire() // Hàm này được gọi từ input của người chơi { // Người chơi (Client) không trực tiếp bắn. // Họ gửi yêu cầu lên Server. Server_FireWeapon(); } OOP \u0026 Tip Trick:\nCommand Pattern: RPCs, đặc biệt là Server RPC, hoạt động rất giống Command Pattern. Client đóng gói một \" lệnh\" (bắn súng, dùng item) và gửi nó đi, Server là người nhận và thực thi lệnh đó. Reliable vs Unreliable: Chỉ sử dụng Reliable cho những gì bắt buộc phải đến nơi (bắn súng, dùng kỹ năng). Sử dụng Unreliable cho các hiệu ứng phụ, không quan trọng (tiếng bước chân, tia lửa…). Gửi quá nhiều RPC Reliable có thể làm nghẽn mạng. 2. Các Plugin cần thiết: Những bộ Lego Technic chuyên dụng Đây là những “bộ Lego” làm sẵn, cực kỳ phức tạp mà chúng ta không muốn tự mình xây dựng từ đầu.\nOnline Subsystem (OSS):\nNó là gì? Một lớp trừu tượng (Interface) của Unreal Engine, hoạt động như một “đầu cắm Lego đa năng”. chúng ta chỉ cần lập trình với đầu cắm này, nó sẽ tự động tương thích với các “ổ cắm” khác nhau như Steam, Epic Online Services, Xbox Live… Tại sao cần? Để chúng ta không phải viết code riêng cho từng nền tảng. Viết code tạo phòng chờ (session) một lần, chạy được cả trên Steam và Epic Games Store. Lưu ý: Việc cấu hình OSS trong file DefaultEngine.ini khá phức tạp và đặc thù cho từng nền tảng. Hãy đọc kỹ tài liệu của Epic và nền tảng chúng ta chọn. Advanced Sessions Plugin:\nNó là gì? Một plugin miễn phí giúp việc sử dụng OSS trở nên đơn giản hơn rất nhiều bằng cách cung cấp các node Blueprint tiện lợi. Tại sao cần? Nó là một “bộ chuyển đổi” giúp việc cắm các “đầu cắm Lego” trở nên dễ dàng hơn, đặc biệt nếu chúng ta muốn các game designer có thể tự tạo logic phòng chờ bằng Blueprint. Voice Chat / Anti-Cheat:\nĐây là những “bộ Lego” chuyên dụng khác. Việc tích hợp chúng thường đòi hỏi làm việc với SDK riêng của nhà cung cấp (Vivox, EAC…). Hãy coi chúng như những submodule riêng biệt trong dự án. 3. Biên dịch (Build) và Đóng gói (Package): Tạo ra hai bộ Lego để bán Sau khi lắp ráp xong mô hình, chúng ta cần tạo ra hai phiên bản “hộp sản phẩm” khác nhau.\nBiên dịch Server:\nNó là gì? Là quá trình tạo ra một file .exe chỉ chứa logic gameplay, không có đồ họa, âm thanh. Tại sao? Vì server không cần render thế giới game, nó chỉ cần tính toán. File .exe này siêu nhẹ, giúp chúng ta chạy nhiều phòng game trên một máy chủ vật lý để tiết kiệm chi phí. Làm như thế nào? Trong Visual Studio, ở thanh dropdown Solution Configurations, thay vì chọn Development Editor, hãy chọn Development Server và nhấn Build. Đóng gói (Packaging):\nNó là gì? Là quá trình “nấu” (cook) tất cả các assets của chúng ta (model, texture, map…) thành định dạng tối ưu và đóng gói chúng cùng với file .exe để tạo ra một sản phẩm hoàn chỉnh có thể phân phối. Sự khác biệt cốt lõi: Đóng gói Client: File \u003e Package Project \u003e Windows. Đây là phiên bản đầy đủ cho người chơi, chứa cả đồ họa và gameplay. Đóng gói Server: File \u003e Package Project \u003e Build Target \u003e [TênDựÁn] Server. Thao tác này sẽ tạo ra một thư mục riêng (ví dụ WindowsServer) chỉ chứa những gì server cần. Nó sẽ không có các texture 4K hay các file âm thanh nặng nề. Tip \u0026 Trick cho Team:\nTự động hóa: Viết một file script .bat đơn giản sử dụng RunUAT.bat của Unreal để tự động hóa toàn bộ quá trình đóng gói cho cả Client và Server. Điều này đảm bảo tính nhất quán và tiết kiệm thời gian, đặc biệt khi chúng ta cần build thường xuyên. Mỗi lần cần build mới, chỉ cần chạy một file batch là xong. Tuyệt vời! Chúng ta sẽ đi sâu vào hai giai đoạn cuối cùng, tập trung vào việc biến sản phẩm trong môi trường phát triển thành một hệ thống hoạt động thực tế, ổn định và có thể mở rộng. Đây là lúc công trình Lego của chúng ta được kiểm tra độ bền và đưa ra thế giới.\nGiai đoạn 3: Kiểm thử và Tối ưu hóa - Thử nghiệm và Gia cố công trình Lego Đây là giai đoạn chúng ta “lắc mạnh” công trình Lego của mình để xem có mảnh nào rơi ra không, và tìm cách gia cố những điểm yếu trước khi giao cho người khác chơi.\n1. Chạy và kiểm thử Dedicated Server cục bộ: Sân chơi thử nghiệm tại nhà Trước khi đưa server lên mây, việc kiểm thử tại chính máy của chúng ta là bước nhanh nhất và hiệu quả nhất để tìm ra các lỗi gameplay.\nLàm như thế nào?\nTạo file Batch (.bat) để tự động hóa: Thay vì tạo shortcut và chỉnh tay, hãy tạo các file .bat. Đây là một “Tip \u0026 Trick” cực kỳ tiết kiệm thời gian cho cả team. StartServer.bat: @echo off echo Starting Server... start Binaries\\Win64\\[TênDựÁn]Server.exe /Game/Maps/TenMap_Gameplay?listen -log exit ?listen: Báo cho server biết nó cần mở cổng và lắng nghe kết nối từ client. -log: Mở một cửa sổ console riêng để chúng ta có thể xem log của server theo thời gian thực. StartClient.bat: @echo off echo Starting Client... start Binaries\\Win64\\[TênDựÁn].exe 127.0.0.1 -game exit 127.0.0.1: Địa chỉ IP “localhost”, tức là kết nối đến server đang chạy trên cùng máy. -game: Chạy game ở chế độ cửa sổ độc lập thay vì mở editor. Kiểm thử trong Editor: Để debug nhanh hơn, hãy vào Play \u003e Advanced Settings.... Tại đây, chúng ta có thể thiết lập: Number of Players: Đặt là 2 hoặc hơn. Multiplayer Options \u003e Run Dedicated Server: Đánh dấu tick vào đây. Khi chúng ta nhấn Play, Unreal Editor sẽ tự động khởi chạy một server và nhiều client, cho phép chúng ta đặt breakpoint và debug trực tiếp. Tại sao lại làm như thế?\nVòng lặp nhanh (Fast Iteration): Việc chạy và kiểm thử cục bộ cho phép chúng ta tìm và sửa lỗi logic gameplay ( replication, RPCs…) trong vài phút, thay vì mất hàng giờ để build, tải lên server đám mây rồi mới phát hiện lỗi. Tách biệt vấn đề: Nếu game chạy đúng ở local nhưng lỗi khi lên server, chúng ta biết vấn đề nằm ở môi trường mạng hoặc cấu hình máy chủ, chứ không phải ở code gameplay. Tip \u0026 Trick cần thiết:\nGiả lập mạng kém: Mạng ở local luôn hoàn hảo. Để kiểm thử game trong điều kiện thực tế, hãy sử dụng các lệnh console trong client để giả lập lag và mất gói tin: Net PktLag=[miligiây]: Ví dụ Net PktLag=100 để giả lập ping 100ms. Net PktLoss=[phần trăm]: Ví dụ Net PktLoss=5 để giả lập mất 5% gói tin. Đây là bước bắt buộc để tìm ra các lỗi liên quan đến dự đoán chuyển động (movement prediction) và các sự kiện không đáng tin cậy (unreliable RPCs). Sử dụng nhiều file .bat: Tạo nhiều file StartClient_Player2.bat, StartClient_Player3.bat… để nhanh chóng mở nhiều client cho một lần test. 2. Tối ưu hóa hiệu năng: Đảm bảo công trình Lego không bị sập khi có nhiều người chơi Network Relevancy and Culling: “Chỉ gửi những viên Lego mà người chơi nhìn thấy”\nNó là gì? Theo mặc định, Unreal sẽ không gửi cập nhật về một Actor cho một người chơi nếu Actor đó ở quá xa. Đây là “Distance-based culling”. Tuy nhiên, chúng ta có thể kiểm soát nó một cách tinh vi hơn. Làm như thế nào? Override hàm bool AActor::IsNetRelevantFor(const FRealViewer\u0026 RealViewer) trong Actor của chúng ta. Tại sao nó quan trọng? Tưởng tượng một game battle royale 100 người. Nếu server gửi thông tin của tất cả 99 người chơi khác đến máy chúng ta, băng thông sẽ tắc nghẽn ngay lập tức. Bằng cách chỉ gửi thông tin của 5-10 người chơi gần nhất, chúng ta đã giảm tải mạng xuống hơn 90%. Tip \u0026 Trick: Ví dụ thực tế: Một đơn vị tàng hình (invisible). Hàm IsNetRelevantFor của nó nên được viết để trả về false đối với những người chơi thuộc đội đối phương (trừ khi họ có item phát hiện tàng hình). Tần suất cập nhật: Tinh chỉnh biến NetUpdateFrequency của Actor. Các Actor di chuyển nhanh (như nhân vật) cần tần suất cao (ví dụ: 100 lần/giây), nhưng các Actor tĩnh hoặc ít thay đổi (như một cánh cửa) chỉ cần tần suất rất thấp (ví dụ: 2 lần/giây). Server-side Optimization: “Thợ Cả không cần quan tâm đến màu sắc”\nNó là gì? Server chỉ quan tâm đến logic: Vị trí ở đâu? Máu bao nhiêu? Có bắn trúng không? Nó không cần biết hiệu ứng cháy nổ trông đẹp thế nào, hay âm thanh nghe ra sao. Làm như thế nào? Sử dụng preprocessor directive một cách triệt để. void AMyProjectile::OnHit(...) { // Logic gây sát thương luôn chạy ApplyDamage(...); // Logic hiệu ứng chỉ chạy trên các máy có thể \"thấy\" được #if !UE_SERVER UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), HitFX, GetActorLocation()); UGameplayStatics::PlaySoundAtLocation(GetWorld(), HitSound, GetActorLocation()); #endif } Tại sao? Mỗi chu kỳ CPU được tiết kiệm trên server có nghĩa là server có thể xử lý nhiều người chơi hơn, hoặc chạy các thuật toán AI phức tạp hơn. Việc loại bỏ các tác vụ đồ họa/âm thanh là cách tiết kiệm tài nguyên hiệu quả nhất. Profiling: “Dùng kính lúp soi từng viên gạch”\nNó là gì? Là quá trình đo lường để tìm ra chính xác phần nào của game đang gây chậm. Làm như thế nào? Unreal Insights: Đây là công cụ mạnh nhất. chúng ta chạy nó song song với game, nó sẽ ghi lại mọi thứ, từ thời gian thực thi của từng hàm C++, dữ liệu mạng được gửi đi, đến việc tải assets. Lệnh Console: Stat Unit: Hiển thị thời gian xử lý của Frame, Game Thread, Render Thread, GPU. Trên server, Game Thread là quan trọng nhất. Stat Net: Hiển thị chi tiết thông tin mạng đang được gửi/nhận. Tại sao? “Phỏng đoán là nguồn gốc của mọi sai lầm trong tối ưu hóa”. Đừng đoán xem cái gì đang chậm, hãy đo lường nó. chúng ta có thể ngạc nhiên khi thấy một hàm tưởng chừng vô hại lại đang chiếm 30% tài nguyên CPU của server. Giai đoạn 4: Triển khai và Vận hành - Đóng hộp và vận chuyển Lego đi khắp thế giới Đây là giai đoạn biến game của chúng ta từ một sản phẩm chạy trên máy cá nhân thành một dịch vụ toàn cầu.\n1. Chuẩn bị cho việc triển khai: Xây dựng dây chuyền sản xuất Cross-Compilation (Biên dịch chéo cho Linux):\nNó là gì? Sử dụng Visual Studio trên Windows để tạo ra một file thực thi có thể chạy trên Linux. Làm như thế nào? Mở Epic Games Launcher, tìm đến phiên bản Engine của chúng ta, chọn Options. Trong Target Platforms, tick vào Linux. Launcher sẽ tải về bộ công cụ (toolchain) cần thiết. Sau khi cài xong, chúng ta chỉ cần mở Visual Studio, chọn cấu hình Development Server và nền tảng Linux để biên dịch. Tại sao? Chi phí thuê máy chủ Windows thường cao hơn đáng kể so với máy chủ Linux do chi phí bản quyền. Linux cũng được coi là ổn định và hiệu quả hơn cho các tác vụ máy chủ. Hầu hết các nhà cung cấp dịch vụ game server đều chạy trên Linux. Containerization (Đóng gói bằng Docker): “Đóng gói Lego vào hộp tiêu chuẩn”\nNó là gì? Docker gói ứng dụng server của chúng ta và tất cả những gì nó cần để chạy (thư viện, file cấu hình…) vào một “container” duy nhất. Container này giống như một máy ảo siêu nhẹ. Làm như thế nào? Tạo một file tên là Dockerfile trong thư mục dự án của chúng ta. # Sử dụng một ảnh Linux cơ bản FROM ubuntu:20.04 # Đặt thư mục làm việc bên trong container WORKDIR /app # Sao chép thư mục server đã được đóng gói từ máy của chúng ta vào container COPY ./LinuxServer ./ # Mở cổng 7777 cho kết nối game (giao thức UDP) EXPOSE 7777/udp # Lệnh sẽ được chạy khi container khởi động # Thêm cờ -nohomedir để tránh lỗi ghi log vào thư mục không tồn tại CMD [\"./MyGame/Binaries/Linux/MyGameServer-Linux-Shipping\", \"MyMap?listen\", \"-log\", \"-nohomedir\"] Tại sao? Tính nhất quán: Container đảm bảo server của chúng ta sẽ chạy y hệt trên máy của dev, trên server thử nghiệm, và trên server sản phẩm. Loại bỏ hoàn toàn lỗi “Ủa, trên máy em chạy được mà!”. Khả năng mở rộng: Các công cụ quản lý đám mây như Kubernetes và Agones được thiết kế để làm việc với container. Chúng có thể tự động tạo ra, khởi động, và xóa đi hàng trăm container server của chúng ta dựa trên nhu cầu của người chơi. 2. Triển khai lên các nền tảng đám mây: Chọn nhà kho và hệ thống vận chuyển Các lựa chọn: Cơ bản (IaaS - Infrastructure as a Service): Thuê máy ảo (VM) trên AWS EC2, Google Cloud Compute Engine, Azure VMs. chúng ta sẽ phải tự cài đặt mọi thứ, tự quản lý việc khởi động server, cập nhật phiên bản. Phù hợp để bắt đầu và học hỏi. Nâng cao (PaaS - Platform as a Service / Fleet Management): Sử dụng các dịch vụ chuyên dụng như **AWS Gamelift ** hoặc Google Cloud Agones (trên nền Kubernetes). Tại sao nên dùng Fleet Management? chúng ta chỉ cần đưa cho chúng container server của mình. Chúng sẽ tự động: Tự động co giãn (Autoscaling): Khi có nhiều người chơi, chúng tự tạo thêm server. Khi người chơi nghỉ, chúng tự động xóa bớt để tiết kiệm tiền. Phân phối toàn cầu: Đặt server ở gần người chơi (ví dụ: người chơi ở châu Âu sẽ kết nối tới server ở Frankfurt) để giảm ping. Kiểm tra sức khỏe (Health Checks): Tự động khởi động lại các server bị treo. Tip \u0026 Trick: Đừng cố tự xây dựng một hệ thống quản lý server (fleet management). Đó là một công việc cực kỳ phức tạp. Hãy tận dụng các giải pháp đã có sẵn như Agones (mã nguồn mở) hoặc Gamelift. 3. Tích hợp và Deploy lên Store (Ví dụ: Steam): Đưa sản phẩm lên kệ Cấu hình App và Depot: “Hai hộp sản phẩm khác nhau”\nchúng ta cần liên hệ với Valve để yêu cầu tạo hai App ID: App ID chính (Type: Game): Đây là game mà người chơi sẽ mua. App ID phụ (Type: Tool): Đây là “Dedicated Server” của chúng ta, nó sẽ miễn phí. Trong mỗi App, chúng ta tạo “Depot” (kho chứa file): Depot của game sẽ chứa các bản build cho Windows, Mac, Linux của client. Depot của server sẽ chỉ chứa bản build Linux server. Tại sao? Điều này cho phép người chơi chỉ tải về client (khoảng 20GB), và những người muốn host server (hoặc chính chúng ta) chỉ cần tải về server (khoảng 500MB). SteamPipe: “Cỗ máy đóng gói và dán nhãn”\nNó là một công cụ dòng lệnh để tải các file build của chúng ta lên các depot tương ứng. chúng ta sẽ tạo các file kịch bản .vdf để chỉ định “thư mục build client” sẽ được tải lên “depot client”, và \" thư mục build server\" sẽ được tải lên “depot server”. Tip \u0026 Trick (Quan trọng): Sử dụng các nhánh (branch) khác nhau trong Steamworks. development branch: Tải các bản build hàng ngày lên đây để team nội bộ và QA kiểm thử. public branch (mặc định): Chỉ khi bản build ở nhánh development đã ổn định, chúng ta mới “promote” nó sang nhánh này cho tất cả người chơi. Đây là quy trình phát hành an toàn, tránh việc đẩy một bản build lỗi ra cho toàn bộ cộng đồng. Kịch bản cài đặt (Install Script):\nTrong cấu hình depot của server trên Steamworks, chúng ta cần thêm một kịch bản cài đặt. Nó sẽ chạy khi ai đó tải server của chúng ta qua SteamCMD, đảm bảo các thư viện cần thiết trên Linux được cài đặt. Giai đoạn 5: Vận hành Chuyên nghiệp - Dây chuyền lắp ráp tự động và Trung tâm điều khiển Ra mắt game mới chỉ là sự khởi đầu. Để vận hành một game online thành công, chúng ta cần các quy trình tự động hóa và các công cụ giám sát mạnh mẽ.\n1. CI/CD (Continuous Integration/Continuous Deployment): Dây chuyền lắp ráp tự động Nó là gì? CI/CD là một phương pháp mà mỗi khi một lập trình viên đẩy code lên một nhánh nhất định (ví dụ: develop), một hệ thống tự động sẽ: CI (Tích hợp liên tục): Lấy code mới về, biên dịch game, chạy các bài test tự động để đảm bảo không có lỗi nào mới được thêm vào. CD (Triển khai liên tục): Nếu CI thành công, nó sẽ tự động đóng gói (package) bản build Client và Server, sau đó tải chúng lên Steam (vào nhánh development) và triển khai container server mới lên môi trường thử nghiệm ( staging environment) trên đám mây. Tại sao nó là chân lý? Loại bỏ sai sót con người: Không còn cảnh “quên build server” hay “đóng gói nhầm phiên bản”. Mọi thứ đều tự động và nhất quán. Tăng tốc độ phát triển: Team có thể có bản build mới để test mỗi ngày, thậm chí mỗi giờ, thay vì chờ đợi một người build thủ công. An toàn: Các bài test tự động hoạt động như một lớp bảo vệ, ngăn chặn lỗi nghiêm trọng được đưa vào game. Làm như thế nào? Sử dụng các dịch vụ như GitHub Actions (tích hợp sẵn với GitHub), Jenkins, hoặc GitLab CI/CD. chúng ta sẽ viết các file kịch bản (ví dụ .yml cho GitHub Actions) để định nghĩa các bước trên. 2. Backend Services và Matchmaking: Bộ não đằng sau cuộc vui Game Server vs. Backend Server: Game Server (Dedicated Server): Xử lý logic game thời gian thực (real-time). Vòng đời của nó ngắn, chỉ tồn tại trong một trận đấu. Backend Services: Một tập hợp các dịch vụ chạy 24/7, không xử lý real-time. Chúng là nơi lưu trữ dữ liệu bền vững và xử lý các logic meta-game. Các dịch vụ Backend cốt lõi: Identity/Account Service: Quản lý tài khoản, đăng nhập, liên kết với Steam/Epic. Player Data Storage: Lưu trữ kho đồ, tiền tệ, tiến trình của người chơi trong một cơ sở dữ liệu (Database). Matchmaking Service: Đây là dịch vụ “mai mối”. Người chơi gửi yêu cầu “tìm trận” đến đây. Matchmaker sẽ dựa trên các quy tắc (ping, rank/skill, chế độ chơi) để tập hợp một nhóm người chơi và ra lệnh cho hệ thống Fleet Management (như Agones) khởi động một Game Server mới cho họ. Tip \u0026 Trick: Đừng cố tự xây dựng tất cả từ đầu. Hãy xem xét các giải pháp “Backend-as-a-Service” (BaaS) như AccelByte, * Pragma Platform*, hoặc Amazon GameSparks. Chúng cung cấp sẵn các dịch vụ trên. Đối với matchmaking, Open Match của Google là một framework mã nguồn mở mạnh mẽ. 3. Ghi log, Giám sát và Vận hành trực tiếp (Live Ops): Trung tâm điều khiển Structured Logging (Ghi log có cấu trúc):\nĐừng chỉ ghi log dưới dạng text thông thường: Player John connected.. Hãy ghi log dưới dạng JSON: {\"timestamp\": \"...\", \"event\": \"PlayerConnect\", \"playerId\": \"12345\", \"playerName\": \"John\", \"serverIp\": \"...\"}. Tại sao? Log có cấu trúc có thể được tự động thu thập và đưa vào các hệ thống phân tích. chúng ta có thể dễ dàng truy vấn: “Cho tôi xem tất cả các sự kiện PlayerConnect trong 24 giờ qua” hoặc “Vẽ biểu đồ số lượng người chơi trên từng server”. Monitoring \u0026 Alerting (Giám sát \u0026 Cảnh báo):\nSử dụng các công cụ như Prometheus (thu thập số liệu), Grafana (vẽ biểu đồ), và Alertmanager. Thiết lập các Dashboard để theo dõi sức khỏe của toàn bộ hệ thống theo thời gian thực: Số lượng người chơi đang online (CCU). Số lượng server đang hoạt động. CPU/RAM trung bình của các server. Thời gian tìm trận trung bình. Thiết lập các Cảnh báo (Alerts) tự động gửi tin nhắn vào Slack/Email cho team khi có sự cố: “Cảnh báo: Server X có CPU đạt 95% trong 5 phút!” hoặc “Số lượng server bị crash tăng đột biến!”. Live Ops:\nĐây là tư duy vận hành game như một dịch vụ. Team của chúng ta có thể: Theo dõi các chỉ số để hiểu hành vi người chơi. Phát hiện và xử lý sự cố nhanh chóng nhờ hệ thống giám sát. Bật/tắt các sự kiện trong game, thay đổi các thông số (ví dụ: sát thương của một khẩu súng) mà không cần deploy bản build mới, thông qua một hệ thống quản lý từ xa. Chắc chắn rồi! Để biến tài liệu này thành một cẩm nang “từ A đến Á” thực thụ, việc bổ sung các “Tip \u0026 Trick” chuyên sâu, được đúc kết từ kinh nghiệm thực chiến của các nhà phát triển đi trước, là vô cùng cần thiết.\nDưới đây là một danh sách các mẹo và thủ thuật quan trọng, được sắp xếp theo từng giai đoạn, mà chúng ta nên thêm vào tài liệu của mình.\nCác Tip \u0026 Trick Nâng cao cho Team Chuyên nghiệp Những kỹ thuật này là sự khác biệt giữa một game multiplayer “chạy được” và một game multiplayer “chạy tốt” - ổn định, dễ bảo trì, và có khả năng mở rộng.\nI. Mẹo về Kiến trúc \u0026 Thiết kế (Giai đoạn 1 \u0026 2) 1. “Gầy” Character, “Béo” Component (Lean Character, Fat Components) Vấn đề: Rất nhiều người mới bắt đầu có xu hướng nhồi nhét tất cả logic vào lớp ACharacter: logic túi đồ, hệ thống kỹ năng, quản lý máu, năng lượng… Điều này tạo ra một “God Class” khổng lồ, khó đọc, khó bảo trì và không thể tái sử dụng. Giải pháp: Áp dụng triệt để kiến trúc Component. Tạo các UActorComponent riêng biệt cho từng hệ thống: UInventoryComponent, UHealthComponent, UAbilityComponent… Trong ACharacter, chỉ cần thêm các component này vào. ACharacter chỉ nên chịu trách nhiệm về những gì cốt lõi của một nhân vật: di chuyển và hoạt hình. Tại sao lại là “Trick” hay? Tính Module: chúng ta có thể dễ dàng thêm hoặc bớt UInventoryComponent cho bất kỳ Actor nào (ví dụ: một cái rương). Dễ Test: chúng ta có thể kiểm thử UHealthComponent một cách độc lập mà không cần tạo ra cả một ACharacter hoàn chỉnh. Làm việc nhóm: Team A làm InventoryComponent, team B làm AbilityComponent mà không sợ đụng code của nhau. 2. Sử dụng Interfaces cho Tương tác (Interfaces for Interaction) Vấn đề: Làm thế nào để nhân vật có thể tương tác với nhiều loại vật thể khác nhau (cửa, item, NPC) mà không cần phải kiểm tra kiểu (cast) liên tục? Giải pháp: Tạo một C++ Interface, ví dụ UInteractableInterface. Interface này định nghĩa các hàm như OnInteract(AController* Interactor) và GetInteractionText(). Bất kỳ Actor nào (cửa, item…) muốn có thể tương tác được chỉ cần implement Interface này. Khi nhân vật nhìn vào một vật thể, họ chỉ cần kiểm tra: if (LookAtActor-\u003eImplements()), sau đó gọi hàm IInteractableInterface::Execute_OnInteract(LookAtActor, GetController()); mà không cần quan tâm Actor đó là loại gì. Tại sao lại là “Trick” hay? Nó giúp tách biệt hoàn toàn (decoupling) logic tương tác khỏi các lớp cụ thể, giúp code của chúng ta sạch sẽ, linh hoạt và cực kỳ dễ mở rộng. 3. Data-Driven Design với Data Assets và Curve Tables Vấn đề: Các thông số game (sát thương súng, máu của quái vật, lượng kinh nghiệm cần để lên cấp) bị hard-code trong C++ hoặc trong từng Blueprint riêng lẻ, khiến việc cân bằng game trở thành một cơn ác mộng. Giải pháp: UDataAsset: Tạo một lớp C++ kế thừa từ UDataAsset, ví dụ UWeaponDataAsset. Lớp này chứa tất cả các thuộc tính của một vũ khí (sát thương, tốc độ bắn, số đạn…). Sau đó, trong Editor, các designer có thể tạo ra vô số asset DA_AK47, DA_Pistol… từ lớp này. ABaseWeapon của chúng ta chỉ cần một con trỏ UPROPERTY đến UWeaponDataAsset là có thể lấy toàn bộ thông tin. UCurveTable: Sử dụng Curve Table để định nghĩa sự phát triển của các chỉ số theo cấp độ. Ví dụ, tạo một Curve Table cho “HealthPerLevel”. Cấp 1 có 100 máu, cấp 2 có 110 máu… Code C++ chỉ cần đọc giá trị từ bảng này dựa trên cấp độ hiện tại. Tại sao lại là “Trick” hay? Nó chuyển quyền cân bằng game từ lập trình viên sang cho game designer. Họ có thể tinh chỉnh hàng trăm vật phẩm mà không cần một dòng code nào, tăng tốc độ phát triển và thử nghiệm lên gấp nhiều lần. II. Mẹo về Workflow \u0026 Debugging (Giai đoạn 2 \u0026 3) 1. Bậc thầy Debug Mạng (Network Debugging Mastery) Việc debug mạng không chỉ là print string. Hãy sử dụng các công cụ chuyên dụng: Các lệnh Console cốt lõi: showdebug abilitysystem: Hiển thị thông tin debug của GAS ngay trên màn hình. showdebug animation: Hiển thị trạng thái của Animation Blueprint. Net PktLag=[ms], Net PktLoss=[%], Net PktOrder=[0|1]: Các lệnh “thần thánh” để giả lập môi trường mạng xấu ngay trong Editor. Network Profiler: Mở Unreal Insights (Shift+Alt+I) và chạy game. Tab “Networking” sẽ cho chúng ta thấy chính xác từng packet được gửi đi, chứa thông tin gì, thuộc tính nào được replicate, RPC nào được gọi, và chúng tốn bao nhiêu băng thông. Đây là công cụ tối thượng để tìm ra nguyên nhân gây lag. 2. Tận dụng Gameplay Debugger Vấn đề: Làm sao để xem trạng thái của một Actor (đặc biệt là AI) một cách nhanh chóng mà không cần đặt breakpoint? Giải pháp: Bật Gameplay Debugger (Project Settings \u003e Gameplay Debugger \u003e Bật ). Trong game, nhấn phím Apostrophe ('). Một giao diện sẽ hiện ra, cung cấp vô số thông tin về Actor chúng ta đang nhìn vào: trạng thái Behavior Tree của AI, các Gameplay Tag đang active, thông tin của Ability System… Tại sao lại là “Trick” hay? Nó cho phép chúng ta debug “sống” (live) mà không cần dừng game, cực kỳ hữu ích khi debug các hệ thống phức tạp như AI và GAS. 3. Hot Reload và Live Coding Đừng tắt Editor mỗi khi chúng ta thay đổi một dòng code C++. Hot Reload (Cũ): Nhấn Ctrl+Alt+F11 trong Editor. Nó sẽ biên dịch lại code và “vá” vào phiên Editor đang chạy. Live Coding (Mới \u0026 Tốt hơn): Nhấn Ctrl+Alt+F11. Live Coding là một hệ thống mới hơn, ổn định và nhanh hơn Hot Reload. Hãy đảm bảo nó được bật trong Editor Preferences \u003e Live Coding. Tại sao lại là “Trick” hay? Nó giảm thời gian chờ đợi biên dịch từ vài phút xuống còn vài giây, giúp chúng ta duy trì dòng chảy công việc và tăng năng suất lập trình C++ lên đáng kể. III. Mẹo về Tối ưu hóa Mạng (Giai đoạn 3 \u0026 4) 1. AActor::NetDormancy - “Ru ngủ” các Actor Vấn đề: Có những Actor ít khi thay đổi (ví dụ: một item nằm trên đất). Việc server liên tục kiểm tra và gửi cập nhật (dù không có gì thay đổi) cho chúng là một sự lãng phí. Giải pháp: Sử dụng NetDormancy. chúng ta có thể đặt trạng thái của một Actor thành “ngủ đông”. Khi ở trạng thái này, server sẽ hoàn toàn không gửi bất kỳ cập nhật nào về nó nữa cho đến khi có một sự kiện “đánh thức” nó dậy (ví dụ: một người chơi đi lại gần). Tại sao lại là “Trick” hay? Trong một map có hàng ngàn vật thể, việc “ru ngủ” 90% trong số chúng có thể giảm tải băng thông của server một cách đáng kinh ngạc. 2. Nén dữ liệu trong RPCs (RPC Data Quantization) Vấn đề: Gửi các RPC với nhiều tham số FVector hoặc FRotator (mỗi float là 4 byte) có thể rất tốn băng thông. Giải pháp: Nén dữ liệu (Quantization). Thay vì gửi một giá trị float đầy đủ, hãy gửi một phiên bản nén của nó. Vị trí: chúng ta có thực sự cần độ chính xác đến 6 chữ số thập phân? Có thể chúng ta chỉ cần gửi 3 số nguyên int16 và tính toán lại ở phía nhận. Hướng (Rotation): Một FRotator tốn 12 byte. Nhưng chúng ta có thể nén nó xuống chỉ còn 2-4 byte bằng cách chỉ gửi 1 hoặc 2 thành phần và tính toán lại phần còn lại, hoặc sử dụng các kỹ thuật nén Quaternion. Tại sao lại là “Trick” hay? Đây là một kỹ thuật tối ưu hóa nâng cao, giúp giảm kích thước của các RPC quan trọng ( như bắn súng), cho phép server xử lý nhiều hành động hơn mỗi giây. 3. FNetSerialize và Fast TArray Replication Vấn đề: Làm sao để replicate một TArray chứa các UObject* hoặc các struct phức tạp một cách hiệu quả? Giải pháp: Fast TArray Replication: Đối với TArray chứa các struct, hãy sử dụng TArray","wordCount":"14196","inLanguage":"vi","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Bob Pham"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://oaiba.github.io/dev/vi/posts/tiptrick/scratch_1/"},"publisher":{"@type":"Organization","name":"Nhật ký phát triển của Bob Phạm","logo":{"@type":"ImageObject","url":"https://oaiba.github.io/dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://oaiba.github.io/dev/vi/ accesskey=h title="Nhật ký phát triển của Bob Phạm (Alt + H)">Nhật ký phát triển của Bob Phạm</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://oaiba.github.io/dev/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://oaiba.github.io/dev/vi/gameroadmap/ title="Lộ trình Game"><span>Lộ trình Game</span></a></li><li><a href=https://oaiba.github.io/dev/vi/about/ title="Giới Thiệu"><span>Giới Thiệu</span></a></li><li><a href=https://oaiba.github.io/dev/vi/resume/ title="Hồ Sơ Năng Lực"><span>Hồ Sơ Năng Lực</span></a></li><li><a href=https://oaiba.github.io/dev/vi/posts/ title="Bài Viết"><span>Bài Viết</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent"></h1><div class=post-meta>67 phút&nbsp;·&nbsp;14196 từ&nbsp;·&nbsp;Bob Pham</div></header><div class=post-content><p><a href=https://vorixo.github.io/devtricks/stateful-events-multiplayer/#onreps>https://vorixo.github.io/devtricks/stateful-events-multiplayer/#onreps</a><br><a href=https://wizardcell.com/unreal/multiplayer-tips-and-tricks/>https://wizardcell.com/unreal/multiplayer-tips-and-tricks/</a>
<a href=https://dev.epicgames.com/documentation/en-us/unreal-engine/epic-cplusplus-coding-standard-for-unreal-engine>https://dev.epicgames.com/documentation/en-us/unreal-engine/epic-cplusplus-coding-standard-for-unreal-engine</a><br><a href=https://www.tomlooman.com/unreal-engine-naming-convention-guide/>https://www.tomlooman.com/unreal-engine-naming-convention-guide/</a><br><a href=https://unrealdirective.com/resources/asset-naming-conventions>https://unrealdirective.com/resources/asset-naming-conventions</a><br><a href=https://unrealdirective.com/tips>https://unrealdirective.com/tips</a><br><a href="https://github.com/Allar/ue5-style-guide/tree/v2?tab=readme-ov-file">https://github.com/Allar/ue5-style-guide/tree/v2?tab=readme-ov-file</a></p><h3 id=1-yêu-cầu-tiên-quyết-xây-dựng-nền-móng-đúng-đắn>1. Yêu cầu tiên quyết: Xây dựng nền móng đúng đắn<a hidden class=anchor aria-hidden=true href=#1-yêu-cầu-tiên-quyết-xây-dựng-nền-móng-đúng-đắn>#</a></h3><h4 id=sử-dụng-phiên-bản-unreal-engine-từ-mã-nguồn-source-build><strong>Sử dụng phiên bản Unreal Engine từ mã nguồn (Source Build)</strong><a hidden class=anchor aria-hidden=true href=#sử-dụng-phiên-bản-unreal-engine-từ-mã-nguồn-source-build>#</a></h4><ul><li><p><strong>Tại sao lại làm như thế?</strong></p><ul><li><strong>Khả năng biên dịch Server Target:</strong> Phiên bản Engine tải từ Epic Games Launcher (Binary build) đã được biên dịch
sẵn và không bao gồm các công cụ cần thiết để tạo ra một bản build hoàn toàn riêng biệt cho server (
<code>Server Target</code>). Chỉ có phiên bản từ mã nguồn mới cho phép chúng ta biên dịch mục tiêu này, tạo ra một file thực
thi <code>.exe</code> siêu nhẹ, không chứa mã nguồn đồ họa hay âm thanh không cần thiết.</li><li><strong>Gỡ lỗi (Debug) Engine:</strong> Khi gặp phải các lỗi sâu bên trong Engine, việc có mã nguồn cho phép chúng ta debug
từng dòng lệnh, hiểu rõ nguyên nhân và thậm chí tự sửa lỗi nếu cần.</li><li><strong>Tùy biến Engine:</strong> chúng ta có toàn quyền tùy chỉnh và mở rộng các tính năng của Engine để phù hợp với nhu cầu
đặc thù của dự án.</li><li><strong>Tiếp cận các tính năng thử nghiệm:</strong> Một số tính năng mới nhất có thể chỉ tồn tại trên các nhánh nhất định của
mã nguồn.</li></ul></li><li><p><strong>Tip & Trick cho Team:</strong></p><ul><li><strong>Biên dịch một lần, dùng cho cả team:</strong> Một người trong team (thường là lead hoặc build engineer) sẽ chịu trách
nhiệm biên dịch Engine từ mã nguồn. Sau đó, toàn bộ thư mục Engine đã biên dịch có thể được nén lại và chia sẻ cho
cả team thông qua một server nội bộ hoặc dịch vụ lưu trữ. Điều này giúp các thành viên khác không phải tốn thời
gian biên dịch lại.</li><li><strong>Sử dụng Unreal Build System (UBT):</strong> Tận dụng UBT để tự động hóa quy trình build Engine, giúp đảm bảo tính nhất
quán giữa các lần build.</li></ul></li></ul><hr><h3 id=dự-án-c-xây-dựng-một><strong>Dự án C++: Xây dựng một &ldquo;Siêu đô thị&rdquo; có Quy hoạch và Luật lệ Rõ ràng</strong><a hidden class=anchor aria-hidden=true href=#dự-án-c-xây-dựng-một>#</a></h3><p>Việc lựa chọn C++ và cấu trúc dự án không chỉ là xây dựng một &ldquo;bộ khung xương&rdquo;; nó là việc <strong>thiết lập bản quy hoạch
tổng thể và bộ luật xây dựng</strong> cho toàn bộ &ldquo;siêu đô thị&rdquo; game của chúng ta. Một bản quy hoạch tốt kết hợp với luật lệ
nghiêm ngặt sẽ đảm bảo thành phố có thể phát triển bền vững, dễ dàng nâng cấp, và không bao giờ chìm trong hỗn loạn.</p><p>&ldquo;Allar&rsquo;s UE5 Style Guide&rdquo; chính là bộ luật xây dựng đó.</p><hr><h3 id=hai-triết-lý-quy-hoạch><strong>Hai Triết lý Quy hoạch &ldquo;Siêu đô thị&rdquo; Unreal</strong><a hidden class=anchor aria-hidden=true href=#hai-triết-lý-quy-hoạch>#</a></h3><p>Khi bắt đầu một dự án, chúng ta đứng trước một ngã rẽ quan trọng về cách tổ chức hàng ngàn, thậm chí hàng triệu file
assets và code. Có hai trường phái tư duy chính, hai &ldquo;bản quy hoạch tổng thể&rdquo; khác biệt hoàn toàn.</p><hr><h3 id=phương-pháp-1-quy-hoạch-theo-chức-năng-functional-first-approach><strong>Phương pháp 1: Quy hoạch theo Chức năng (Functional-First Approach)</strong><a hidden class=anchor aria-hidden=true href=#phương-pháp-1-quy-hoạch-theo-chức-năng-functional-first-approach>#</a></h3><h4 id=triết-lý><strong>Triết lý</strong><a hidden class=anchor aria-hidden=true href=#triết-lý>#</a></h4><p>Hãy tưởng tượng một thành phố được quy hoạch một cách tuyệt đối theo ngành nghề và chức năng. Tất cả các ngân hàng nằm
ở &ldquo;Quận Tài chính&rdquo;, tất cả các nhà máy nằm ở &ldquo;Khu Công nghiệp&rdquo;, tất cả các trường đại học nằm ở &ldquo;Làng Đại học&rdquo;. Nếu
chúng ta muốn tìm một thứ gì đó, chúng ta chỉ cần biết &ldquo;nó là loại gì&rdquo; để đi đến đúng khu vực.</p><p>Trong Unreal, triết lý này có nghĩa là <strong>tất cả các asset cùng loại sẽ được nhóm lại với nhau, bất kể chúng thuộc về
tính năng hay nhân vật nào.</strong></p><h4 id=cách-làm-how-to><strong>Cách làm (How-to)</strong><a hidden class=anchor aria-hidden=true href=#cách-làm-how-to>#</a></h4><p>Cấu trúc thư mục <code>Content</code> sẽ được tổ chức theo loại asset:</p><pre tabindex=0><code>Content/
├── Blueprints/
│   ├── Pawns/
│   │   ├── BP_PlayerCharacter.uasset
│   │   └── BP_Enemy_Grunt.uasset
│   ├── Actors/
│   │   ├── BP_Door.uasset
│   │   └── BP_HealthPack.uasset
│   └── Weapons/
│       └── BP_AK47.uasset
│
├── Maps/
│   ├── MainMenu.umap
│   └── Jungle.umap
│
├── Materials/
│   ├── M_PlayerCharacter.uasset
│   ├── M_Enemy_Grunt.uasset
│   └── M_AK47.uasset
│
├── Meshes/
│   ├── StaticMeshes/
│   │   └── SM_HealthPack.uasset
│   └── SkeletalMeshes/
│       ├── SK_PlayerCharacter.uasset
│       ├── SK_Enemy_Grunt.uasset
│       └── SK_AK47.uasset
│
├── Textures/
│   ├── T_PlayerCharacter_D.uasset
│   ├── T_Enemy_Grunt_D.uasset
│   └── T_AK47_D.uasset
│
└── ... (Sounds, Particles, etc.)
</code></pre><h4 id=ưu-điểm-pros><strong>Ưu điểm (Pros)</strong><a hidden class=anchor aria-hidden=true href=#ưu-điểm-pros>#</a></h4><ol><li><strong>Dễ tìm theo loại:</strong> Nếu chúng ta cần tìm <em>bất kỳ</em> Material nào trong dự án, chúng ta biết chính xác phải vào thư
mục <code>Content/Materials</code>. Điều này rất hữu ích cho các Technical Artist khi họ muốn kiểm tra và tối ưu hóa tất cả các
material trong game.</li><li><strong>Thúc đẩy Tái sử dụng:</strong> Khi tất cả các texture được đặt chung một nơi, artist sẽ có xu hướng tìm kiếm một texture
kim loại đã có sẵn trước khi tạo ra một cái mới, giúp giảm sự trùng lặp và tiết kiệm dung lượng.</li><li><strong>Rõ ràng cho Lập trình viên (Ban đầu):</strong> Cấu trúc này ban đầu có vẻ rất logic và sạch sẽ, đặc biệt đối với những
người có tư duy lập trình, vì nó phân tách rõ ràng các &ldquo;lớp&rdquo; khác nhau của một thực thể (model, material, logic).</li></ol><h4 id=nhược-điểm-cons><strong>Nhược điểm (Cons)</strong><a hidden class=anchor aria-hidden=true href=#nhược-điểm-cons>#</a></h4><ol><li><strong>Cơn ác mộng cho việc Di chuyển & Xóa bỏ:</strong> Đây là nhược điểm lớn nhất. Để xóa hoàn toàn nhân vật &ldquo;Enemy Grunt&rdquo;,
chúng ta phải đi lùng sục trong ít nhất 5 thư mục khác nhau (<code>Blueprints</code>, <code>Materials</code>, <code>Meshes</code>, <code>Textures</code>,
<code>Animations</code>) để xóa từng file một. Nguy cơ để lại các file &ldquo;mồ côi&rdquo; (orphan files) làm rác dự án là cực kỳ cao.</li><li><strong>Workflow rời rạc cho Artist & Designer:</strong> Để lắp ráp hoàn chỉnh một nhân vật, một artist phải liên tục nhảy giữa
nhiều thư mục khác nhau để gán mesh, material, texture&mldr; Điều này làm gián đoạn dòng chảy công việc và tốn thời
gian.</li><li><strong>Không thân thiện với DLC và Đóng gói (Chunking):</strong> Khi chúng ta muốn đóng gói một bản DLC chỉ chứa map &ldquo;Desert&rdquo; và
các asset liên quan, làm thế nào chúng ta có thể chỉ định cho Unreal Build Tool biết file nào thuộc về map đó? Gần
như là không thể một cách tự động. Chúng ta sẽ phải tạo danh sách thủ công, một công việc dễ sai sót và không có khả
năng mở rộng.</li></ol><hr><h3 id=phương-pháp-2-quy-hoạch-theo-nội-dung-content-first-approach><strong>Phương pháp 2: Quy hoạch theo Nội dung (Content-First Approach)</strong><a hidden class=anchor aria-hidden=true href=#phương-pháp-2-quy-hoạch-theo-nội-dung-content-first-approach>#</a></h3><h4 id=triết-lý-1><strong>Triết lý</strong><a hidden class=anchor aria-hidden=true href=#triết-lý-1>#</a></h4><p>Hãy tưởng tượng một thành phố được xây dựng như một tập hợp các &ldquo;khu đô thị&rdquo; hoặc &ldquo;công viên chủ đề&rdquo; hoàn toàn tự chủ.
Mọi thứ chúng ta cần cho &ldquo;Công viên Kỷ Jura&rdquo; (khủng long, cây cối, xe jeep, hàng rào điện) đều nằm gọn bên trong bức
tường của công viên đó. Nếu chúng ta muốn di chuyển cả công viên sang một địa điểm mới, chúng ta chỉ cần bứng cả khu đất
đó đi.</p><p>Trong Unreal, triết lý này có nghĩa là <strong>tất cả các asset liên quan đến một tính năng hoặc một thực thể cụ thể sẽ được
nhóm lại với nhau trong một thư mục duy nhất.</strong></p><h4 id=cách-làm-how-to-1><strong>Cách làm (How-to)</strong><a hidden class=anchor aria-hidden=true href=#cách-làm-how-to-1>#</a></h4><p>Cấu trúc thư mục <code>Content</code> sẽ được tổ chức theo tính năng/thực thể:</p><pre tabindex=0><code>Content/
├── Characters/
│   ├── Player/
│   │   ├── BP_PlayerCharacter.uasset
│   │   ├── Meshes/
│   │   │   └── SK_PlayerCharacter.uasset
│   │   ├── Materials/
│   │   │   └── M_PlayerCharacter.uasset
│   │   └── Textures/
│   │       └── T_PlayerCharacter_D.uasset
│   └── Enemies/
│       └── Grunt/
│           ├── BP_Enemy_Grunt.uasset
│           ├── Meshes/
│           │   └── SK_Enemy_Grunt.uasset
│           └── ...
│
├── Weapons/
│   └── Rifles/
│       └── AK47/
│           ├── BP_AK47.uasset
│           ├── Meshes/
│           │   └── SK_AK47.uasset
│           └── ...
│
├── Props/
│   └── HealthPack/
│       ├── BP_HealthPack.uasset
│       ├── Meshes/
│       │   └── SM_HealthPack.uasset
│       └── ...
│
└── Maps/
    ├── MainMenu/
    │   └── Map_MainMenu.umap
    └── Jungle/
        ├── Map_Jungle.umap
        ├── Meshes/         # Các mesh chỉ dùng trong map Jungle
        └── Materials/      # Các material chỉ dùng trong map Jungle
</code></pre><h4 id=ưu-điểm-pros-1><strong>Ưu điểm (Pros)</strong><a hidden class=anchor aria-hidden=true href=#ưu-điểm-pros-1>#</a></h4><ol><li><strong>Tính tự chứa và Di động (Self-Contained & Portable):</strong> Đây là ưu điểm tuyệt đối. Chúng ta có thể <strong>di chuyển toàn
bộ nhân vật Player sang một dự án khác chỉ bằng cách sao chép thư mục <code>Content/Characters/Player</code></strong>. Mọi thứ sẽ hoạt
động vì tất cả các tham chiếu (references) đều nằm trong đó.</li><li><strong>Thiên đường cho DLC và Đóng gói (Chunking):</strong> Đây là cách duy nhất để quản lý các gói nội dung một cách hiệu quả.
Chúng ta có thể dễ dàng nói với Unreal: &ldquo;Hãy đóng gói toàn bộ thư mục <code>Content/Maps/Jungle</code> thành Chunk 10.&rdquo; Khi
người chơi muốn tải map này, game chỉ cần tải về file .pak của Chunk 10.</li><li><strong>Workflow liền mạch cho Artist & Designer:</strong> Khi làm việc trên nhân vật Player, mọi file họ cần đều nằm ngay trong
một thư mục. Họ có thể dễ dàng duyệt qua, chỉnh sửa và liên kết các asset với nhau mà không cần rời khỏi &ldquo;khu vực làm
việc&rdquo; của mình.</li></ol><h4 id=nhược-điểm-cons-1><strong>Nhược điểm (Cons)</strong><a hidden class=anchor aria-hidden=true href=#nhược-điểm-cons-1>#</a></h4><ol><li><strong>Vấn đề nan giải về Asset dùng chung (The Shared Asset Dilemma):</strong> Đây là điểm yếu chí mạng. Một Material Master,
một texture kim loại trầy xước, một bộ animation di chuyển cơ bản&mldr; được dùng cho TẤT CẢ các nhân vật sẽ được đặt ở
đâu? Điều này thường dẫn đến sự ra đời của một thư mục <code>Content/Shared</code>, và nếu không được quản lý chặt chẽ, nó có
thể trở thành một &ldquo;bãi rác&rdquo; chứa mọi thứ, làm phá vỡ triết lý ban đầu.</li><li><strong>Nguy cơ Trùng lặp cao:</strong> Vì sự tiện lợi, một artist có thể sẽ sao chép một texture từ thư mục <code>Shared</code> vào thư mục
nhân vật của họ thay vì tạo một Material Instance. Điều này dẫn đến việc asset bị trùng lặp, làm tăng đáng kể kích
thước của game.</li><li><strong>Có thể gây xung đột cho Lập trình viên:</strong> Nếu các lớp C++ cụ thể cho từng tính năng cũng được đặt trong các thư mục
nội dung này, nó có thể làm xáo trộn cấu trúc <code>Source</code> và gây khó khăn cho việc quản lý code.</li></ol><h4 id=i-triết-lý-cốt-lõi-quy-hoạch-thư-mục-là-luật><strong>I. Triết lý cốt lõi: Quy hoạch Thư mục là Luật!</strong><a hidden class=anchor aria-hidden=true href=#i-triết-lý-cốt-lõi-quy-hoạch-thư-mục-là-luật>#</a></h4><p>Trước khi đi vào chi tiết, nguyên tắc tối cao mà Allar&rsquo;s Style Guide đặt ra là: <strong>Sự nhất quán và có tổ chức trong cấu
trúc thư mục và quy tắc đặt tên là không thể thương lượng.</strong></p><ul><li><strong>Tại sao?</strong><ul><li><strong>Khả năng dự đoán:</strong> Bất kỳ thành viên nào trong team, dù mới hay cũ, đều có thể tìm thấy một asset họ cần một
cách nhanh chóng mà không cần phải hỏi ai. Họ biết rằng một Material sẽ nằm trong thư mục <code>Materials</code> và có tiền
tố <code>M_</code>.</li><li><strong>Hiệu quả tìm kiếm:</strong> Content Browser của Unreal trở thành một công cụ cực kỳ mạnh mẽ khi chúng ta có thể lọc
chính xác theo tiền tố (<code>BP_</code>, <code>T_</code>, <code>M_</code>&mldr;).</li><li><strong>Tránh sự hỗn loạn:</strong> Nó ngăn chặn việc các asset tạm thời, thử nghiệm, hoặc trùng lặp làm ô nhiễm dự án chính.</li></ul></li></ul><h4 id=ii-cấu-trúc-lai-tối-ưu---phiên-bản><strong>II. Cấu trúc Lai Tối ưu - Phiên bản &ldquo;Allar&rsquo;s Certified&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#ii-cấu-trúc-lai-tối-ưu---phiên-bản>#</a></h4><p>Chúng ta sẽ áp dụng mô hình &ldquo;Hybrid City&rdquo; nhưng với các quy tắc và tên thư mục cụ thể từ Allar&rsquo;s Style Guide.</p><h5 id=a-hạ-tầng-ngầm-code--><strong>A. Hạ tầng Ngầm (Code - <code>Source/</code>) - Nền móng Kỹ thuật</strong><a hidden class=anchor aria-hidden=true href=#a-hạ-tầng-ngầm-code-->#</a></h5><p>Phần này vẫn tuân thủ nguyên tắc <strong>Quy hoạch theo Chức năng</strong>. Đây là nền móng C++ vững chắc, ít khi bị thay đổi bởi
artist hay designer.</p><ul><li><code>Source/MyGameCore</code>: Các hệ thống toàn cục, interfaces, các lớp helper.</li><li><code>Source/MyGameFramework</code>: Các lớp C++ cơ sở cho gameplay (<code>CharacterBase</code>, <code>WeaponBase</code>, <code>GameStateBase</code>&mldr;). Đây là
cầu nối sang <code>Content/Core</code>.</li><li><code>Source/GameFeatures/</code>: Mỗi hệ thống gameplay lớn nên là một module riêng.<ul><li><code>Source/GameFeatures/Inventory</code></li><li><code>Source/GameFeatures/AbilitySystem</code></li><li><code>Source/GameFeatures/AI</code></li></ul></li></ul><h5 id=b-bề-nổi-assets--><strong>B. Bề nổi (Assets - <code>Content/</code>) - Các Khu phố và Tòa nhà</strong><a hidden class=anchor aria-hidden=true href=#b-bề-nổi-assets-->#</a></h5><p>Đây là nơi chúng ta áp dụng triệt để các quy tắc của Allar, kết hợp giữa <strong>Quy hoạch theo Chức năng</strong> và <strong>Quy hoạch
theo Nội dung</strong>.</p><ul><li><p><code>Content/Core/</code>: <strong>&ldquo;Trung tâm Hành chính & Hạ tầng Chung&rdquo;</strong></p><ul><li>Đây là nơi chứa các asset nền tảng, được sử dụng trên toàn bộ dự án. Nó tương ứng trực tiếp với
<code>Source/MyGameFramework</code>.</li><li><code>Core/Blueprints/</code>: Chứa các Blueprint cơ sở kế thừa trực tiếp từ C++ (<code>BP_CharacterBase</code>, <code>BP_WeaponBase</code>). Các
designer sẽ tạo các Blueprint con từ những lớp này.</li><li><code>Core/Data/</code>: Chứa các Data Table và Data Asset định nghĩa các quy tắc game cơ bản.</li><li><code>Core/Materials/</code>: Chứa các Master Material, Material Function mà tất cả các asset khác sẽ tạo instance từ đó.</li><li><code>Core/Input/</code>: Chứa các Input Action và Input Mapping Context của hệ thống Enhanced Input.</li></ul></li><li><p><code>Content/Shared/</code>: Sẽ được đặt ở cấp cao nhất của Content, và bản thân nó cũng cần có một cấu trúc bên trong rõ
ràng, thường là theo chức năng:</p><ul><li><p><strong>Quy tắc đóng gói:</strong> Khi thiết lập các quy tắc đóng gói (Packaging Rules) và Primary Asset Labels, toàn bộ thư
mục <code>Content/Shared</code> sẽ được gán cho <strong>Chunk 0</strong>. Điều này đảm bảo rằng khi người chơi tải game lần đầu, họ sẽ có
tất cả các asset nền tảng cần thiết để mọi gói nội dung khác (DLC, map mới) có thể hoạt động chính xác khi được
tải về sau này.</p></li><li><p><strong>Để giảm thiểu rủi ro, team phải tuân thủ các quy tắc nghiêm ngặt:</strong></p><ul><li><strong>Quy tắc #1: Phải có &ldquo;Người gác cổng&rdquo; (Strict Gatekeeping):</strong> Không ai được phép tự ý thêm asset vào
<code>Content/Shared</code>. Phải có một hoặc vài người (thường là Art Director, Technical Art Lead, hoặc Lead Engineer)
chịu trách nhiệm phê duyệt mọi thứ được đưa vào đây.</li><li><strong>Quy tắc #2: &ldquo;Quy tắc Ba lần&rdquo; (The Rule of Three):</strong> Một asset chỉ nên được xem xét để đưa vào <code>Shared</code> khi
nó được yêu cầu sử dụng ở <strong>ba hoặc nhiều nơi khác nhau và riêng biệt</strong>. Nếu nó chỉ được dùng cho hai nhân
vật, có thể tốt hơn là giữ nó ở một trong hai thư mục nhân vật đó và tham chiếu chéo.</li><li><strong>Quy tắc #3: <code>Shared</code> là &ldquo;Chỉ đọc&rdquo; với Hầu hết mọi người:</strong> Đối với đa số thành viên trong team, các asset
trong <code>Shared</code> nên được coi là &ldquo;read-only&rdquo;. Họ chỉ nên tạo instance hoặc tham chiếu đến chúng. Việc
chỉnh sửa một asset trong <code>Shared</code> phải là một quy trình có kiểm soát, có thể yêu cầu một buổi họp review
ngắn.</li><li><strong>Quy tắc #4: Kiểm toán Định kỳ (Regular Audits):</strong> Cứ mỗi một hoặc hai tháng, &ldquo;người gác cổng&rdquo; nên rà soát
lại thư mục <code>Shared</code> để tìm và loại bỏ các asset không còn được sử dụng hoặc những asset được thêm vào không
đúng quy cách.</li></ul></li></ul></li><li><p><code>Content/Characters/</code>, <code>Content/Weapons/</code>, <code>Content/Environments/</code>, <code>Content/Props/</code>: <strong>&ldquo;Các Khu Dân cư và Công trình
Chuyên dụng&rdquo;</strong></p><ul><li>Đây là phần <strong>Quy hoạch theo Nội dung</strong>. Mỗi thư mục này chứa tất cả mọi thứ liên quan đến một thực thể cụ thể.</li><li><em>Ví dụ với <code>Content/Characters/CyberNinja/</code></em>:<ul><li><code>BP_CyberNinja</code> (kế thừa từ <code>Core/Blueprints/BP_CharacterBase</code>)</li><li><code>Meshes/SK_CyberNinja</code></li><li><code>Textures/T_CyberNinja_D</code>, <code>T_CyberNinja_N</code></li><li><code>Materials/MI_CyberNinja</code> (một instance của <code>Core/Materials/M_Character_Master</code>)</li><li><code>Animations/A_CyberNinja_Attack</code></li></ul></li><li><strong>Lợi ích cho Pak/Chunk:</strong> Cấu trúc tự chứa này làm cho việc đóng gói trở nên cực kỳ đơn giản. chúng ta có thể tạo
một chunk ID cho toàn bộ thư mục <code>Characters/CyberNinja</code>. Nếu nhân vật này là một DLC, người chơi có thể tải về
chỉ gói đó mà không ảnh hưởng đến phần còn lại của game. Tương tự với <code>Maps/Jungle/</code>.</li></ul></li><li><p><code>Content/Developers/</code>: <strong>&ldquo;Khu vực Thử nghiệm & Sandbox Cá nhân&rdquo;</strong></p><ul><li>Đây là một trong những quy tắc thiên tài nhất của Allar. Mỗi thành viên trong team sẽ có một thư mục con riêng
trong này (ví dụ: <code>Developers/JohnDoe/</code>).</li><li><strong>Mục đích:</strong> Đây là nơi an toàn để mỗi người thử nghiệm, tạo các asset tạm thời, &ldquo;chọc ngoáy&rdquo; mà <strong>không làm ô
nhiễm</strong> dự án chính.</li><li><strong>Quy tắc tối cao:</strong> Thư mục <code>Content/Developers/</code> phải được thêm vào file <code>.gitignore</code> (hoặc các file ignore của
Perforce). <strong>Nội dung trong này không bao giờ được commit lên version control.</strong></li></ul></li></ul><h5 id=c-sơ-đồ-quy-hoạch-tổng-thể><strong>C. Sơ đồ Quy hoạch Tổng thể</strong><a hidden class=anchor aria-hidden=true href=#c-sơ-đồ-quy-hoạch-tổng-thể>#</a></h5><p>Đây là hình dung về cấu trúc lai cuối cùng của chúng ta:</p><pre tabindex=0><code>├── Source/
│   ├── MyGameCore/
│   └── GameFeatures/
│       └── Inventory/
│
└── Content/
    ├── Core/
    │   ├── Blueprints/
    │   └── Materials/
    │
    ├── Characters/
    │   └── CyberNinja/
    │       ├── BP_CyberNinja.uasset
    │       ├── Meshes/
    │       └── Textures/
    │
    ├── Maps/
    │   └── Jungle/
    │       ├── Map_Jungle.umap
    │       ├── Meshes/
    │       └── Materials/
    │
    ├── GameFeatures/
    │   └── Inventory/
    │       ├── Data/
    │       └── UI/
    │
    ├── Developers/
    │   ├── JohnDoe/    (NEVER COMMIT)
    │   └── JaneSmith/  (NEVER COMMIT)
    │
    └── _External/      # Chứa các asset từ bên ngoài (ví dụ: Megascans)
    │
    ├── _Shared/
    
</code></pre><h4 id=iii-ưu-điểm-vượt-trội-của-mô-hình-quy-hoạch-lai-này><strong>III. Ưu điểm Vượt trội của Mô hình Quy hoạch Lai này</strong><a hidden class=anchor aria-hidden=true href=#iii-ưu-điểm-vượt-trội-của-mô-hình-quy-hoạch-lai-này>#</a></h4><ul><li><strong>Tối ưu cho mọi vai trò:</strong><ul><li><strong>Lập trình viên</strong> có một cấu trúc code module hóa, sạch sẽ trong <code>Source/</code>.</li><li><strong>Artist/Designer</strong> có một cấu trúc nội dung trực quan, tự chứa trong <code>Content/</code>, cho phép họ làm việc độc lập.</li><li><strong>Technical Director</strong> có thể dễ dàng quản lý và tự động hóa quy trình đóng gói (packaging) dựa trên cấu trúc này.</li></ul></li><li><strong>Sẵn sàng cho Tương lai (Future-Proof):</strong><ul><li><strong>DLC & Cập nhật:</strong> Việc thêm một gói nội dung mới (nhân vật, map) chỉ đơn giản là tạo một thư mục mới theo đúng
quy chuẩn mà không cần tái cấu trúc lại toàn bộ dự án.</li><li><strong>Tối ưu hóa Phân phối:</strong> Cấu trúc này là nền tảng để chúng ta có thể phân phối game dưới dạng các &ldquo;chunk&rdquo; nhỏ.
Người chơi có thể tải phần chơi chính trước, và tải các gói ngôn ngữ, các map độ phân giải cao, hoặc các phần chơi
khác sau.</li></ul></li><li><strong>Vận hành và Hỗ trợ đa nền tảng:</strong><ul><li>Khi một lỗi xảy ra chỉ trên Android liên quan đến nhân vật CyberNinja, chúng ta biết chính xác cần phải kiểm tra
các file trong <code>Content/Characters/CyberNinja</code> và các lớp C++ cơ sở mà nó kế thừa.</li><li>Việc quản lý các phiên bản (develop, staging, production) trở nên dễ dàng hơn vì cấu trúc nhất quán giúp các công
cụ CI/CD (như TeamCity) xác định và đóng gói các thay đổi một cách đáng tin cậy.</li></ul></li></ul><hr><h3 id=khả-năng-mở-rộng-bảo-trì-và-làm-việc-với-version-control><strong>Khả năng Mở rộng, Bảo trì và làm việc với Version Control</strong><a hidden class=anchor aria-hidden=true href=#khả-năng-mở-rộng-bảo-trì-và-làm-việc-với-version-control>#</a></h3><p>Đây là lợi ích chiến lược lớn nhất khi chọn C++, quyết định khả năng &ldquo;sống sót&rdquo; và phát triển của dự án trong dài hạn.</p><h4 id=kiến-trúc-linh-hoạt-kết-hợp-kế-thừa-oop-và-tập-hợp-composition><strong>Kiến trúc linh hoạt: Kết hợp Kế thừa (OOP) và Tập hợp (Composition)</strong><a hidden class=anchor aria-hidden=true href=#kiến-trúc-linh-hoạt-kết-hợp-kế-thừa-oop-và-tập-hợp-composition>#</a></h4><p>C++ cho phép chúng ta tận dụng triệt để các nguyên tắc OOP. Ví dụ, chúng ta có thể tạo một lớp <code>ABaseWeapon</code> định nghĩa
các hành vi chung (bắn, nạp đạn). Sau đó, các lớp con <code>ARifle</code>, <code>APistol</code> có thể kế thừa và chuyên biệt hóa các hành vi
đó.</p><p>Tuy nhiên, một kiến trúc hiện đại và linh hoạt hơn là kết hợp Kế thừa với <strong>Composition (Kiến trúc tập hợp các thành
phần)</strong>.</p><ul><li><strong>Triển khai gợi ý của chúng ta:</strong> Thay vì một <code>ARifle</code> kế thừa mọi thứ từ <code>ABaseWeapon</code>, chúng ta tạo ra một lớp
<code>AWeapon</code> cơ bản. Các chức năng cụ thể như &ldquo;bắn đạn ghém&rdquo; (<code>ShotgunFireComponent</code>), &ldquo;ngắm bắn qua ống ngắm&rdquo; (
<code>ScopeComponent</code>), hay &ldquo;bắn tia laser&rdquo; (<code>LaserBeamComponent</code>) sẽ được xây dựng dưới dạng các <strong>Actor Component</strong>.</li><li><strong>Tại sao đây là phương pháp vượt trội?</strong><ul><li><strong>&ldquo;Cắm và Chạy&rdquo; (Plug-and-Play):</strong> chúng ta có thể tạo ra một khẩu súng hoàn toàn mới trong Blueprint chỉ bằng
cách lắp ghép các Component này lại với nhau, giống như lắp ráp các module Lego. Một khẩu súng trường tấn công có
thể được tạo từ <code>AWeapon</code> + <code>AutomaticFireComponent</code> + <code>ScopeComponent</code>.</li><li><strong>Tái sử dụng tối đa:</strong> <code>ScopeComponent</code> không chỉ dùng cho súng, nó có thể được gắn vào cả ống nhòm hoặc các công
cụ khác.</li><li><strong>Tránh &ldquo;Địa ngục Kế thừa&rdquo;:</strong> chúng ta sẽ không bị rơi vào tình huống tạo ra một cây kế thừa phức tạp, đa tầng,
khó quản lý chỉ để chia sẻ một vài chức năng nhỏ.</li></ul></li></ul><h4 id=cấu-trúc-module-và-version-control-git-xây-dựng-một><strong>Cấu trúc Module và Version Control (Git): Xây dựng một &ldquo;Thành phố&rdquo; có quy hoạch</strong><a hidden class=anchor aria-hidden=true href=#cấu-trúc-module-và-version-control-git-xây-dựng-một>#</a></h4><p>Việc chia dự án thành các module (<code>MyGameCore</code>, <code>MyGameInventory</code>, <code>MyGameAI</code>&mldr;) giống như việc quy hoạch một thành phố
thành các quận chuyên biệt.</p><ul><li><strong>Giảm thiểu xung đột (Merge Conflicts):</strong> Khi các team làm việc trong các &ldquo;quận&rdquo; (module) riêng của mình, khả năng
họ &ldquo;xây dựng&rdquo; chồng chéo lên nhau và gây ra xung đột trên Git sẽ giảm đi đáng kể. Đây là yếu tố sống còn để duy trì
hiệu suất làm việc của một team lớn.</li><li><strong>Tăng tốc độ biên dịch:</strong> Unreal Build Tool có thể biên dịch các module song song. Một dự án được module hóa tốt sẽ
có thời gian biên dịch nhanh hơn. chúng ta cũng có thể thiết lập để chỉ biên dịch lại những module có thay đổi.</li><li><strong>Sở hữu Code rõ ràng (Code Ownership):</strong> Mỗi module có thể có một &ldquo;chủ sở hữu&rdquo; hoặc team chịu trách nhiệm chính. Khi
có lỗi phát sinh trong hệ thống túi đồ, mọi người đều biết cần phải liên hệ với team <code>Inventory</code>. Điều này tạo ra sự
rõ ràng và trách nhiệm trong tổ chức.</li></ul><hr><h3 id=tip--trick-cho-team-tối-ưu-hóa-quy-trình-làm-việc><strong>Tip & Trick cho Team: Tối ưu hóa quy trình làm việc</strong><a hidden class=anchor aria-hidden=true href=#tip--trick-cho-team-tối-ưu-hóa-quy-trình-làm-việc>#</a></h3><h4 id=1-hybrid-approach><strong>1. Hybrid Approach: &ldquo;C++ xây Siêu xa lộ, Blueprint xây Nhà dân&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#1-hybrid-approach>#</a></h4><p>Đây là triết lý làm việc cốt lõi giúp cân bằng giữa hiệu năng và tốc độ phát triển.</p><ul><li><p><strong>Vai trò của Lập trình viên C++:</strong></p><ul><li>Xây dựng các hệ thống nền tảng vững chắc và các &ldquo;đường cao tốc&rdquo; truyền dữ liệu hiệu năng cao.</li><li>Không chỉ &ldquo;phơi bày&rdquo; các hàm (<code>UFUNCTION</code>), các biến (<code>UPROPERTY</code>) với các meta, property, họ còn định nghĩa các "
kênh sự kiện" bằng delegate (
<code>UPROPERTY(BlueprintAssignable)</code>) để Blueprint có thể &ldquo;lắng nghe&rdquo; và phản ứng lại các sự kiện từ C++ (ví dụ:
<code>OnHealthChanged</code>, <code>OnItemAddedToInventory</code>).</li><li>Họ tạo ra các &ldquo;hợp đồng&rdquo; dữ liệu thông qua <code>UDataAsset</code> và <code>UDataTable</code>.</li></ul></li><li><p><strong>Triển khai gợi ý của chúng ta (Tách biệt Dữ liệu và Logic):</strong></p><ul><li>Lập trình viên C++ sẽ tạo ra các lớp cơ sở như <code>UItemData</code> (kế thừa từ <code>UDataAsset</code>).</li><li>Game Designer, thay vì chỉnh sửa <code>BP_HealthPotion</code>, giờ đây sẽ tạo và chỉnh sửa một asset dữ liệu là
<code>DA_HealthPotion</code>. Asset này chứa mọi thông số: tên, icon, số lượng máu hồi phục, hiệu ứng âm thanh khi sử dụng.</li><li>Lớp <code>AItemActor</code> (trong C++) hoặc <code>BP_ItemActor</code> (trong Blueprint) sẽ chỉ có một biến duy nhất là <code>ItemData</code> (một
con trỏ tới <code>UItemData</code>). Toàn bộ hành vi và hiển thị của nó sẽ được điều khiển bởi dữ liệu trong asset đó.</li><li><strong>Kết quả:</strong> Dev và Designer có thể làm việc song song. Designer có thể tạo ra hàng trăm item mà không cần sự can
thiệp của dev, và dev có thể tối ưu hóa logic xử lý item mà không sợ làm hỏng dữ liệu của Designer. <strong>Xung đột
trên version control gần như bằng không.</strong></li></ul></li></ul><hr><h3 id=2-lựa-chọn-ide-jetbrains-rider---nâng-cấp-trạm-tác-chiến-của-chúng-ta><strong>2. Lựa chọn IDE: JetBrains Rider - Nâng cấp Trạm Tác chiến của chúng ta</strong><a hidden class=anchor aria-hidden=true href=#2-lựa-chọn-ide-jetbrains-rider---nâng-cấp-trạm-tác-chiến-của-chúng-ta>#</a></h3><p>Việc lựa chọn Môi trường phát triển tích hợp (IDE) không đơn thuần là sở thích cá nhân. Đó là một quyết định chiến lược
ảnh hưởng trực tiếp đến năng suất, chất lượng code và tốc độ làm việc của cả team. Trong thế giới Unreal Engine, việc
chuyển từ Visual Studio sang <strong>JetBrains Rider</strong> không chỉ là thay đổi một công cụ, mà là nâng cấp từ một chiếc xe gia
đình đáng tin cậy lên một <strong>siêu xe điện được trang bị AI</strong>, được thiết kế để chinh phục những chặng đường phức tạp
nhất.</p><h4 id=tích-hợp-sâu-với-unreal-engine-ide><strong>Tích hợp sâu với Unreal Engine: IDE &ldquo;Nói&rdquo; ngôn ngữ của Game Dev</strong><a hidden class=anchor aria-hidden=true href=#tích-hợp-sâu-với-unreal-engine-ide>#</a></h4><p>Rider không chỉ đọc code C++; nó &ldquo;hiểu&rdquo; cách Unreal Engine suy nghĩ.</p><ul><li><strong>Phân tích Code thông minh:</strong> Rider phân tích code của chúng ta trong thời gian thực và đưa ra các cảnh báo mà chỉ
người làm Unreal mới hiểu. Nó sẽ là người đồng đội mẫn cán, nhắc nhở chúng ta khi: &ldquo;chúng ta đã quên gọi
<code>Super::BeginPlay()</code>&rdquo;, &ldquo;<code>UPROPERTY</code> này thiếu <code>GENERATED_BODY()</code>&rdquo;, hay thậm chí là phát hiện các lỗi sai chính tả, ngữ
pháp trong comment và tên biến, giúp code base của chúng ta luôn sạch sẽ và chuyên nghiệp.</li><li><strong>Quản lý Dự án Tích hợp:</strong> Thay vì phải mở Unreal Editor để tạo một Module hay Plugin mới, chúng ta có thể thực hiện
việc đó ngay trong Rider. Nó sẽ tự động tạo ra toàn bộ cấu trúc file cần thiết (<code>.h</code>, <code>.cpp</code>, <code>Build.cs</code>), cập nhật
file <code>.uproject</code> và <code>.uplugin</code>. Đây là một sự tự động hóa quy trình giúp tiết kiệm thời gian và giảm thiểu sai sót do
con người.</li></ul><h4 id=các-tính-năng><strong>Các tính năng &ldquo;Thay đổi cuộc chơi&rdquo;: Tối ưu hóa từng cú click chuột</strong><a hidden class=anchor aria-hidden=true href=#các-tính-năng>#</a></h4><ul><li><strong>Kết nối Blueprint:</strong> &ldquo;Cây cầu&rdquo; ma thuật này cho phép chúng ta tìm kiếm một hàm C++ và xem nó được sử dụng ở đâu,
không chỉ trong code mà còn ở <strong>tất cả các file Blueprint</strong>. Khi chúng ta đổi tên một <code>UFUNCTION</code>, Rider sẽ tự động
cập nhật nó ở mọi nơi, giúp chúng ta tái cấu trúc code một cách tự tin mà không sợ làm hỏng logic của game designer.</li><li><strong>Unreal Engine Naming C++ Convention:</strong></li><li><strong>Tích hợp Git liền mạch:</strong> Rider biến việc làm việc với Git từ một công việc dòng lệnh phức tạp thành một trải nghiệm
trực quan.<ul><li>chúng ta có thể xem so sánh khác biệt (diff) ngay trong trình soạn thảo, xem ai đã viết từng dòng code (
<code>git blame</code>), và duyệt qua lịch sử commit dưới dạng biểu đồ.</li><li>Quan trọng nhất, chúng ta có thể <strong>commit từng phần (partial commit)</strong> của một file. Điều này khuyến khích việc
tạo ra các commit nhỏ, nguyên tử (atomic commits), giúp lịch sử dự án trở nên cực kỳ rõ ràng và dễ theo dõi.</li></ul></li><li><strong>Trung tâm phát triển Android tất cả trong một:</strong> Rider tích hợp gần như hoàn chỉnh các công cụ của Android Studio.
chúng ta có thể mở <strong>Logcat</strong> để xem log từ thiết bị, mở <strong>Terminal</strong> để chạy lệnh ADB, và quản lý <strong>Emulator</strong> trực
tiếp trong IDE. Nó loại bỏ hoàn toàn nhu cầu phải chạy Android Studio song song, tiết kiệm tài nguyên máy và giúp
chúng ta tập trung vào một môi trường duy nhất.</li><li><strong>AI Assistant & Local History: Trợ lý ảo và Cỗ máy thời gian</strong><ul><li><strong>AI Assistant:</strong> Đây là một lập trình viên cặp (pair programmer) ảo. Nó có thể giúp chúng ta viết code
boilerplate, giải thích các đoạn code phức tạp, tìm lỗi, và đặc biệt là <strong>tự động viết tài liệu (documentation)</strong>
cho các hàm của chúng ta theo chuẩn ngành, một công việc tốn nhiều thời gian nhưng cực kỳ quan trọng.</li><li><strong>Local History:</strong> Đây là lớp lưới an toàn cuối cùng của chúng ta. Nó tự động lưu lại lịch sử thay đổi của tất cả
các file, hoàn toàn độc lập với Git. Nếu chúng ta vô tình xóa mất một file hay một đoạn code quan trọng mà chưa
commit, Local History cho phép chúng ta quay ngược thời gian và khôi phục lại nó một cách dễ dàng.</li></ul></li></ul><h4 id=sức-mạnh-của-hệ-sinh-thái-jetbrains-khi-các-công-cụ-kết-hợp-thành-một-dàn-nhạc><strong>Sức mạnh của Hệ sinh thái JetBrains: Khi các công cụ kết hợp thành một Dàn nhạc</strong><a hidden class=anchor aria-hidden=true href=#sức-mạnh-của-hệ-sinh-thái-jetbrains-khi-các-công-cụ-kết-hợp-thành-một-dàn-nhạc>#</a></h4><p>Giá trị thực sự của Rider được nhân lên gấp bội khi chúng ta tích hợp nó với các công cụ khác trong hệ sinh thái
JetBrains,tạo ra một quy trình làm việc chuyên nghiệp, khép kín.</p><ul><li><strong>DataGrip (Quản lý Database):</strong> Rider có sẵn một trình quản lý database cơ bản. Khi chúng ta cần các công cụ mạnh mẽ
hơn để làm việc với backend database của game (lưu trữ tài khoản, vật phẩm người chơi), DataGrip cung cấp một giao
diện chuyên dụng. Vì cùng một hệ sinh thái, trải nghiệm người dùng và các phím tắt sẽ cực kỳ quen thuộc.</li><li><strong>TeamCity (CI/CD):</strong> Đây là máy chủ Tích hợp và Triển khai liên tục của JetBrains. chúng ta có thể cấu hình TeamCity
để tự động theo dõi repository Git của chúng ta. Mỗi khi có commit mới, nó sẽ tự động build các bản Client và Server
cho mọi nền tảng, chạy unit test, và triển khai lên server thử nghiệm.</li><li><strong>YouTrack (Quản lý dự án & Lỗi):</strong> Tích hợp YouTrack với Rider cho phép chúng ta xem thông tin ticket ngay trong IDE.
Khi chúng ta làm việc trên một nhánh mới, chúng ta có thể liên kết nó với một ticket. Mỗi commit sẽ tự động được ghi
nhận vào ticket đó, tạo ra một luồng thông tin minh bạch từ yêu cầu ban đầu của designer đến dòng code cuối cùng của
developer.</li></ul><h3 id=thiết-lập-target-cho-dedicated-server><strong>Thiết lập Target cho Dedicated Server: &ldquo;Phòng phẫu thuật&rdquo; tách Client và Server</strong><a hidden class=anchor aria-hidden=true href=#thiết-lập-target-cho-dedicated-server>#</a></h3><p>Phần này mô tả một trong những bước kỹ thuật quan trọng nhất.</p><h4 id=tip--trick-cho-team-mở-rộng><strong>Tip & Trick cho Team (Mở rộng)</strong><a hidden class=anchor aria-hidden=true href=#tip--trick-cho-team-mở-rộng>#</a></h4><ul><li><strong>Sử dụng Preprocessor Directives một cách chiến lược:</strong><ul><li><strong>Triển khai gợi ý của chúng ta:</strong> Các chỉ thị tiền xử lý không chỉ giới hạn ở <code>#if UE_SERVER</code>. chúng ta có thể
kết hợp chúng để tạo ra các logic cực kỳ linh hoạt:<ul><li><code>#if PLATFORM_WINDOWS && WITH_EDITOR</code>: Code chỉ chạy trong Editor trên Windows.</li><li><code>#if UE_BUILD_SHIPPING</code>: Code sẽ bị loại bỏ trong bản build cuối cùng cho người chơi (dùng để loại bỏ các công
cụ gian lận/debug).</li><li><code>#if WITH_MYPLUGIN_NAME</code>: Code chỉ được biên dịch nếu một plugin cụ thể nào đó đang được bật.</li></ul></li><li>Điều này giúp giữ cho code base của chúng ta duy nhất nhưng có thể thích ứng với mọi nền tảng và mọi cấu hình
build, một yếu tố cực kỳ quan trọng để bảo trì dự án trong dài hạn.</li></ul></li></ul><h3 id=giai-đoạn-25-kiến-trúc-gameplay-multiplayer-nâng-cao---xây-dựng-những-cỗ-máy-lego-phức-tạp><strong>Giai đoạn 2.5: Kiến trúc Gameplay Multiplayer Nâng cao - Xây dựng những cỗ máy Lego phức tạp</strong><a hidden class=anchor aria-hidden=true href=#giai-đoạn-25-kiến-trúc-gameplay-multiplayer-nâng-cao---xây-dựng-những-cỗ-máy-lego-phức-tạp>#</a></h3><p>Chúng ta đã nắm vững các viên gạch Replication, Roles, và RPCs. Bây giờ là lúc tìm hiểu các bản thiết kế nâng cao để xây
dựng những hệ thống phức tạp như hệ thống kỹ năng, trang bị, hay AI một cách hiệu quả và dễ mở rộng.</p><h4 id=1-bộ-ba-quyền-lực-gamestate-playerstate-và-playercontroller><strong>1. Bộ Ba Quyền Lực: GameState, PlayerState và PlayerController</strong><a hidden class=anchor aria-hidden=true href=#1-bộ-ba-quyền-lực-gamestate-playerstate-và-playercontroller>#</a></h4><p>Ngoài <code>Character</code>, Unreal cung cấp các lớp cốt lõi mà mọi lập trình viên multiplayer phải nắm vững.</p><ul><li><p><strong><code>AGameStateBase</code> (GameState): Bảng điểm của trận đấu</strong></p><ul><li><strong>Nó là gì?</strong> Một Actor đặc biệt, tồn tại duy nhất trên server và được sao chép (replicate) đến tất cả client. Nó
chứa trạng thái <strong>chung</strong> của toàn bộ trận đấu.</li><li><strong>Tại sao cần?</strong> Đây là nơi để lưu trữ các thông tin mà mọi người chơi cần biết: thời gian còn lại của trận đấu,
danh sách người chơi, đội nào đang thắng, trạng thái của các mục tiêu trong map&mldr;</li><li><strong>Tip & Trick:</strong> Khi một client mới kết nối vào giữa trận, GameState là thứ đầu tiên họ nhận được để &ldquo;bắt kịp&rdquo;
trạng thái hiện tại của game. Hãy đặt mọi thông tin công khai, toàn cục vào đây.</li></ul></li><li><p><strong><code>APlayerState</code> (PlayerState): &ldquo;Căn cước công dân&rdquo; của người chơi</strong></p><ul><li><strong>Nó là gì?</strong> Một Actor đi kèm với mỗi người chơi, tồn tại trên server và được sao chép đến tất cả client. Nó chứa
trạng thái <strong>cá nhân</strong> của một người chơi, tách biệt với nhân vật mà họ đang điều khiển.</li><li><strong>Tại sao cần?</strong> Đây là nơi lưu trữ các thông tin bền vững của người chơi trong suốt phiên chơi, ngay cả khi họ
chết và hồi sinh (nhân vật cũ bị hủy, nhân vật mới được tạo ra). Ví dụ: tên người chơi, điểm số, số mạng giết
được, ping, đội&mldr;</li><li><strong>Tip & Trick:</strong> Đừng bao giờ lưu điểm số hay tên người chơi trực tiếp trong lớp <code>Character</code>. Hãy lưu chúng trong
<code>PlayerState</code>. <code>Character</code> chỉ nên chứa các thông tin tạm thời như máu, đạn.</li></ul></li><li><p><strong><code>APlayerController</code> (PlayerController): Linh hồn của người chơi</strong></p><ul><li><strong>Nó là gì?</strong> Là đại diện cho người chơi con người trong game. Nó tồn tại trên server và client sở hữu nó. Nó nhận
input và &ldquo;chiếm hữu&rdquo; (possess) một <code>Pawn</code> (như <code>Character</code>) để điều khiển.</li><li><strong>Tại sao cần?</strong> Đây là kênh giao tiếp chính từ client lên server. Các RPCs yêu cầu hành động (bắn súng, dùng kỹ
năng) thường được đặt ở đây hoặc trong <code>Character</code>. Các logic không liên quan đến hình thể nhân vật (như hiển thị
UI, quản lý menu) nên nằm ở <code>PlayerController</code>.</li></ul></li></ul><h4 id=2-gameplay-ability-system-gas-bộ-lego-technic-cho-kỹ-năng-và-thuộc-tính><strong>2. Gameplay Ability System (GAS): Bộ Lego Technic cho Kỹ năng và Thuộc tính</strong><a hidden class=anchor aria-hidden=true href=#2-gameplay-ability-system-gas-bộ-lego-technic-cho-kỹ-năng-và-thuộc-tính>#</a></h4><ul><li><strong>Nó là gì?</strong> Một framework cực kỳ mạnh mẽ và phức tạp do chính Epic Games phát triển và sử dụng trong các game như
Fortnite, Paragon. Nó cung cấp sẵn một bộ khung hoàn chỉnh để tạo ra các kỹ năng, hiệu ứng (buff/debuff), và thuộc
tính (máu, mana, sức mạnh&mldr;).</li><li><strong>Tại sao nên dùng?</strong><ul><li><strong>Tối ưu cho mạng:</strong> GAS được thiết kế từ đầu cho game multiplayer, xử lý sẵn các vấn đề về dự đoán (prediction)
trên client, giúp kỹ năng có cảm giác phản hồi ngay lập tức.</li><li><strong>Dễ mở rộng:</strong> Thay vì hard-code các kỹ năng, chúng ta có thể tạo ra chúng dưới dạng các asset riêng biệt. Game
designer có thể tự do tạo và chỉnh sửa kỹ năng mà không cần đụng đến code.</li><li><strong>Quản lý phức tạp:</strong> Dễ dàng xử lý các tương tác phức tạp như: &ldquo;Kỹ năng này gây 50 sát thương lửa, làm chậm 30%
trong 5 giây, và hồi 10 mana cho người dùng nếu mục tiêu đang bị đóng băng.&rdquo;</li></ul></li><li><strong>Tip & Trick:</strong> Học GAS là một khoản đầu tư lớn nhưng cực kỳ xứng đáng cho các game có hệ thống combat phức tạp (RPG,
MOBA, Action). Hãy bắt đầu tìm hiểu nó sớm.</li></ul><h4 id=3-lag-compensation-bắn-trúng><strong>3. Lag Compensation: Bắn trúng &ldquo;bóng ma&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#3-lag-compensation-bắn-trúng>#</a></h4><ul><li><strong>Vấn đề là gì?</strong> Khi chúng ta (Client A) bắn vào địch (Client B), chúng ta bắn vào vị trí chúng ta <em>nhìn thấy</em> trên
màn hình. Nhưng do ping, vị trí đó là vị trí của Client B cách đây 50ms. Khi gói tin của chúng ta đến server, Client B
đã di chuyển đến một vị trí khác. Server sẽ nói chúng ta bắn trượt. Cảm giác cực kỳ khó chịu.</li><li><strong>Giải pháp (Lag Compensation):</strong><ul><li>Khi Server nhận được yêu cầu bắn từ Client A, nó sẽ không kiểm tra ngay lập tức.</li><li>Nó sẽ &ldquo;quay ngược thời gian&rdquo; của thế giới game lại một khoảng bằng đúng ping của Client A.</li><li>Nó sẽ tạm thời di chuyển tất cả các nhân vật khác về vị trí của họ tại thời điểm đó.</li><li><em>Bây giờ</em>, nó mới thực hiện việc kiểm tra bắn. Kết quả sẽ khớp với những gì Client A đã thấy.</li><li>Sau đó, nó trả thế giới game về lại thời điểm hiện tại.</li></ul></li><li><strong>Tip & Trick:</strong><ul><li>May mắn là <code>CharacterMovementComponent</code> đã tự động xử lý việc này cho chuyển động.</li><li>Tuy nhiên, đối với việc bắn súng (line trace) hoặc các kỹ năng có mục tiêu, chúng ta phải <strong>tự mình xây dựng hệ
thống này</strong>. Đây là một trong những kỹ thuật khó nhưng bắt buộc phải có cho các game hành động bắn súng. Hãy
nghiên cứu sâu về nó.</li></ul></li></ul><hr><h3 id=3-cấu-hình-project-settings-chỉ-dẫn-cho-server-hoạt-động>3. Cấu hình Project Settings: Chỉ dẫn cho Server hoạt động<a hidden class=anchor aria-hidden=true href=#3-cấu-hình-project-settings-chỉ-dẫn-cho-server-hoạt-động>#</a></h3><ul><li><p><strong>Làm như thế nào?</strong></p><ol><li><strong>Server Default Map:</strong> Mở <code>Edit > Project Settings > Maps & Modes</code>. Tìm đến mục <code>Server Default Map</code> và chọn bản
đồ mà chúng ta muốn server tự động tải khi nó khởi động. Thường đây sẽ là một bản đồ menu chính hoặc một &ldquo;lobby
map&rdquo;.</li><li><strong>Packaging Maps:</strong> Trong <code>Project Settings > Packaging</code>, cuộn xuống và nhấn vào mũi tên mở rộng ở dưới cùng để
hiển thị các cài đặt nâng cao. Trong mục <code>List of Maps to Include in a Packaged Build</code>, thêm vào tất cả các bản
đồ mà game của chúng ta sẽ sử dụng, bao gồm cả bản đồ default của server và tất cả các bản đồ gameplay khác.</li></ol></li><li><p><strong>Tại sao lại làm như thế?</strong></p><ul><li><strong>Tự động hóa khởi động server:</strong> Việc thiết lập <code>Server Default Map</code> cho phép chúng ta khởi động server mà không
cần truyền thêm tham số dòng lệnh chỉ định bản đồ. Server sẽ tự biết phải tải bản đồ nào đầu tiên.</li><li><strong>Đảm bảo tài sản (assets) được đóng gói:</strong> Quá trình đóng gói (packaging) của Unreal chỉ tự động &ldquo;nấu&rdquo; (cook) và
đưa vào bản build các assets được tham chiếu từ một &ldquo;root&rdquo; nào đó (thường là các bản đồ). Nếu chúng ta không thêm
các bản đồ vào danh sách này, các assets chỉ được sử dụng trong bản đồ đó có thể sẽ không được đóng gói, dẫn đến
lỗi " Can&rsquo;t find file for package&mldr;" khi server cố gắng chuyển đến bản đồ đó.</li></ul></li><li><p><strong>Tip & Trick cho Team:</strong></p><ul><li><strong>Tạo một bản đồ &ldquo;dummy&rdquo; cho server:</strong> Đôi khi, chúng ta không muốn server khởi động ngay vào một bản đồ gameplay
nặng nề. Hãy tạo một bản đồ trống, siêu nhẹ, đặt tên là <code>Entry</code> hoặc <code>ServerEntry</code> và đặt nó làm
<code>Server Default Map</code>.
Từ bản đồ này, server có thể thực hiện các tác vụ khởi tạo ban đầu trước khi chuyển sang bản đồ gameplay thực sự.</li><li><strong>Sử dụng Primary Asset Labels:</strong> Đối với các dự án lớn, việc quản lý danh sách map thủ công có thể trở nên khó
khăn. Hãy tìm hiểu về hệ thống &ldquo;Primary Asset Labels&rdquo; trong <code>Project Settings > Asset Manager</code>. Nó cho phép chúng
ta tự động đưa các assets (bao gồm cả map) vào bản build dựa trên các quy tắc và nhãn mà chúng ta định nghĩa, thay
vì phải thêm từng cái một vào danh sách.</li></ul></li></ul><h3 id=phần-4-git-submodule---nghệ-thuật-lắp-ghép-lego-cho-dự-án>Phần 4: Git Submodule - Nghệ thuật lắp ghép &ldquo;Lego&rdquo; cho Dự án<a hidden class=anchor aria-hidden=true href=#phần-4-git-submodule---nghệ-thuật-lắp-ghép-lego-cho-dự-án>#</a></h3><p>Hãy tưởng tượng dự án Unreal Engine của chúng ta là một công trình Lego phức tạp. Phần mã nguồn C++ và các assets chính
củachúng ta là những viên gạch nền cơ bản. Các plugin và thư viện bên ngoài (ví dụ: plugin về AI, hệ thống UI nâng cao,
OnlineSubsystem&mldr;) chính là những bộ Lego chuyên biệt, độc đáo mà chúng ta muốn gắn vào công trình của mình.</p><p><strong>Git Submodule không sao chép</strong> những bộ Lego đó vào thùng gạch của chúng ta. Thay vào đó, nó ghi lại một tờ giấy
nhớ: &ldquo;Tạivị trí này, hãy lấy bộ Lego &lsquo;AwesomePlugin&rsquo; phiên bản 1.2 (chính xác là mảnh ghép có mã số <code>abc1234</code>) và lắp nó
vào đây&rdquo;.</p><p>Phiên bản <code>1.2</code> hay mã số <code>abc1234</code> chính là <strong>commit hash</strong> của repository plugin đó.</p><p>Đây là nguyên tắc cốt lõi: <strong>Repo chính chỉ lưu trữ một con trỏ (pointer) đến một commit cụ thể của submodule, chứ không
phải toàn bộ lịch sử của nó.</strong></p><hr><h4 id=1-nền-tảng-không-thể-thiếu-git-lfs-và-gitignore>1. Nền tảng không thể thiếu: Git LFS và <code>.gitignore</code><a hidden class=anchor aria-hidden=true href=#1-nền-tảng-không-thể-thiếu-git-lfs-và-gitignore>#</a></h4><p>Trước khi lắp ghép, sàn nhà của chúng ta phải sạch sẽ.</p><ul><li><p><strong>Tại sao Git LFS là bắt buộc?</strong></p><ul><li>Git được sinh ra để quản lý code (file text), nó sẽ lưu lại mọi thay đổi nhỏ nhất của file. Với các file nhị phân
lớn như <code>.uasset</code>, <code>.fbx</code>, <code>.png</code>, chỉ cần thay đổi 1 pixel, Git sẽ coi đó là một file hoàn toàn mới và lưu trữ
một bản sao đầy đủ. Điều này khiến repository phình to lên hàng chục, hàng trăm GB một cách chóng mặt, việc clone
hay pull trở thành cực hình.</li><li>Git LFS giải quyết bằng cách: Thay vì lưu file lớn vào Git, nó lưu file đó lên một server riêng và chỉ để lại một
file text &ldquo;con trỏ&rdquo; vài trăm byte trong repository. Khi chúng ta checkout, LFS sẽ tự động tải file lớn đó về.</li></ul></li><li><p><strong>Tại sao <code>.gitignore</code> lại quan trọng?</strong></p><ul><li>Unreal Engine tự động sinh ra rất nhiều file và thư mục tạm thời trong quá trình làm việc (như <code>Intermediate</code>,
<code>Saved</code>, <code>DerivedDataCache</code>). Các file này có dung lượng rất lớn, đặc thù cho từng máy và không nên được đưa vào
quản lý phiên bản.</li><li>Một file <code>.gitignore</code> chuẩn sẽ yêu cầu Git &ldquo;làm lơ&rdquo; các thư mục này, giữ cho repository của chúng ta gọn nhẹ và
chỉ chứa những gì thực sự cần thiết.</li></ul></li></ul><p><strong>Tip Trick cho Team:</strong></p><ul><li><strong>Thiết lập một lần:</strong> Lead của team nên là người thiết lập file <code>.gitattributes</code> (cho LFS) và <code>.gitignore</code> chuẩn ngay
từ đầu. Mọi thành viên chỉ việc clone và làm theo.</li><li><strong>Kiểm tra trước khi commit:</strong> Luôn chạy <code>git status</code> trước khi commit để đảm bảo không có file rác nào (như các file
trong thư mục <code>Saved</code>) vô tình được thêm vào.</li></ul><hr><h4 id=2-chiến-lược-sử-dụng-submodule-tối-ưu>2. Chiến lược sử dụng Submodule tối ưu<a hidden class=anchor aria-hidden=true href=#2-chiến-lược-sử-dụng-submodule-tối-ưu>#</a></h4><p>Đây là phần nâng cao, giúp team của chúng ta không bị rối khi dự án phình to.</p><h5 id=chiến-lược-1-fork-first---luôn-làm-chủ-các-dependency-của-chúng-ta>Chiến lược 1: &ldquo;Fork First&rdquo; - Luôn làm chủ các dependency của chúng ta<a hidden class=anchor aria-hidden=true href=#chiến-lược-1-fork-first---luôn-làm-chủ-các-dependency-của-chúng-ta>#</a></h5><p>Không bao giờ thêm submodule trực tiếp từ repository gốc của một plugin bên thứ ba. Hãy luôn <strong>fork</strong> nó về organisation
GitHub/GitLab của team chúng ta trước.</p><ul><li><p><strong>Làm như thế nào?</strong></p><ol><li>Vào trang GitHub của plugin, nhấn nút &ldquo;Fork&rdquo;.</li><li>Khi thêm submodule, hãy dùng URL của repository chúng ta vừa fork:
<code>git submodule add https://github.com/MyTeam/AwesomePlugin_Fork.git Plugins/AwesomePlugin</code></li></ol></li><li><p><strong>Tại sao lại làm như thế?</strong></p><ul><li><strong>Toàn quyền kiểm soát:</strong> Điều gì xảy ra nếu plugin gốc có lỗi nghiêm trọng ảnh hưởng đến game của chúng ta, nhưng
tác giả lại không sửa? Với bản fork, team chúng ta có thể tự mình vào sửa lỗi, commit và push lên bản fork đó.</li><li><strong>An toàn khi cập nhật:</strong> chúng ta có thể thoải mái kéo các cập nhật mới nhất từ repository gốc (<code>upstream</code>) về
bản
fork của mình, kiểm thử cẩn thận trước khi quyết định tích hợp vào dự án chính. chúng ta không bị ép phải cập nhật
ngay lập tức.</li><li><strong>Tùy biến:</strong> chúng ta có thể thêm các tính năng riêng cho plugin để phù hợp với game của mình mà không ảnh hưởng
đến ai.</li></ul></li></ul><h5 id=chiến-lược-2-plugin-meta-repo---tạo-một-hộp-dụng-cụ-plugin>Chiến lược 2: &ldquo;Plugin Meta-Repo&rdquo; - Tạo một &ldquo;Hộp dụng cụ&rdquo; Plugin<a hidden class=anchor aria-hidden=true href=#chiến-lược-2-plugin-meta-repo---tạo-một-hộp-dụng-cụ-plugin>#</a></h5><p>Khi dự án sử dụng 5-10 plugin trở lên, việc quản lý từng cái một trong repo chính sẽ rất lộn xộn. Giải pháp là tạo ra
một repository trung gian.</p><ul><li><p><strong>Làm như thế nào?</strong></p><ol><li>Tạo một repository mới, đặt tên là <code>MyGame-Plugins</code>.</li><li>Trong repository này, <strong>hãy thêm tất cả các plugin chúng ta cần dưới dạng submodule của nó</strong>.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Bên trong repo MyGame-Plugins</span>
</span></span><span style=display:flex><span>git submodule add https://github.com/MyTeam/AwesomePlugin_Fork.git AwesomePlugin
</span></span><span style=display:flex><span>git submodule add https://github.com/MyTeam/AnotherPlugin_Fork.git AnotherPlugin
</span></span><span style=display:flex><span>git commit -m <span style=color:#e6db74>&#34;Add required plugins&#34;</span>
</span></span></code></pre></div></li><li>Bây giờ, trong repository game chính, chúng ta chỉ cần thêm <strong>duy nhất một submodule</strong>:
<code>git submodule add https://github.com/MyTeam/MyGame-Plugins.git Plugins</code></li></ol></li><li><p><strong>Tại sao lại làm như thế?</strong></p><ul><li><strong>Gọn gàng:</strong> Repository chính của game sẽ cực kỳ sạch sẽ, chỉ có một submodule <code>Plugins</code> thay vì một danh sách
dài.</li><li><strong>Quản lý tập trung:</strong> Một người (ví dụ Tech Lead) có thể chịu trách nhiệm quản lý repository <code>MyGame-Plugins</code>.
Khi cần cập nhật một plugin nào đó, họ sẽ cập nhật trong &ldquo;hộp dụng cụ&rdquo; này, kiểm thử, rồi commit. Team dev chỉ cần
cập nhật một submodule duy nhất là <code>Plugins</code>.</li><li><strong>Tái sử dụng:</strong> Nếu công ty chúng ta có nhiều dự án game, &ldquo;hộp dụng cụ&rdquo; plugin này có thể được tái sử dụng cho
tất cả các dự án.</li></ul></li></ul><h5 id=chiến-lược-3-cấu-trúc-repo-cho-dev-và-artist---monorepo-là-lựa-chọn-hàng-đầu>Chiến lược 3: Cấu trúc Repo cho Dev và Artist - Monorepo là lựa chọn hàng đầu<a hidden class=anchor aria-hidden=true href=#chiến-lược-3-cấu-trúc-repo-cho-dev-và-artist---monorepo-là-lựa-chọn-hàng-đầu>#</a></h5><ul><li><p><strong>Phân chia folder như thế nào?</strong></p><ul><li>Cách tiếp cận hiệu quả nhất cho hầu hết các team làm game Unreal là <strong>Monorepo</strong> - tức là tất cả mọi thứ (code,
art, sound&mldr;) đều nằm chung trong một repository lớn.</li><li>Sự phân chia nên nằm ở cấp độ thư mục, với quy tắc rõ ràng:<ul><li><code>Content/Art/Characters</code>: Chứa các model, texture, material của nhân vật.</li><li><code>Content/Art/Environments</code>: Chứa các assets môi trường.</li><li><code>Content/Blueprints/Characters</code>: Chứa các Blueprint liên quan đến nhân vật.</li><li><code>Source/MyGame/Public</code>: Chứa các file header C++.</li><li><code>Source/MyGame/Private</code>: Chứa các file cpp C++.</li></ul></li></ul></li><li><p><strong>Tại sao Monorepo lại hiệu quả?</strong></p><ul><li><strong>Atomic Commits (Commit nguyên tử):</strong> Một tính năng mới thường đòi hỏi cả sự thay đổi về code (dev) và art (
artist). Monorepo cho phép chúng ta thực hiện một commit duy nhất bao gồm cả hai thay đổi này. Điều này giúp lịch
sử dự án cực kỳ dễ theo dõi. Khi cần revert một tính năng, chúng ta chỉ cần revert một commit là xong.</li><li><strong>Dễ dàng đồng bộ:</strong> Mọi người luôn ở trên cùng một phiên bản của tất cả mọi thứ. Không có chuyện code chạy được
nhưng art lại là phiên bản cũ và gây lỗi.</li><li><strong>Submodule chỉ dành cho bên thứ ba:</strong> Trong mô hình này, submodule chỉ nên được sử dụng cho các code/thư
viện/plugin từ bên ngoài, không phải để phân tách các phần nội bộ của dự án.</li></ul></li></ul><hr><h4 id=3-quy-trình-làm-việc-workflow-hàng-ngày-với-submodule>3. Quy trình làm việc (Workflow) hàng ngày với Submodule<a hidden class=anchor aria-hidden=true href=#3-quy-trình-làm-việc-workflow-hàng-ngày-với-submodule>#</a></h4><p>Đây là kim chỉ nam cho mọi thành viên trong team.</p><ul><li><p><strong>A. Lần đầu tiên lấy dự án về:</strong>
<code>git clone --recurse-submodules &lt;URL_repo_chính></code>
<em>Lệnh này sẽ clone repo chính, sau đó tự động clone tất cả các submodule được đăng ký.</em></p></li><li><p><strong>B. Bắt đầu một ngày làm việc (lấy code mới nhất về):</strong></p><ol><li><code>git pull</code> <em>(Lấy code mới nhất của repo chính. Có thể con trỏ submodule đã bị thay đổi bởi người khác).</em></li><li><code>git submodule update --recursive</code> <em>(Đọc con trỏ mới và cập nhật code của submodule cho khớp).</em>
<em>Đây là quy trình 2 bước bắt buộc. Nếu chỉ <code>git pull</code>, code submodule của chúng ta sẽ bị cũ và gây lỗi biên
dịch.</em></li></ol></li><li><p><strong>C. Cập nhật một plugin lên phiên bản mới (Dành cho Lead):</strong></p><ol><li><code>cd Plugins/AwesomePlugin</code> <em>(Đi vào thư mục của submodule).</em></li><li><code>git checkout main</code> <em>(Chuyển sang nhánh chính).</em></li><li><code>git pull</code> <em>(Kéo code mới nhất của plugin về).</em></li><li><code>cd ../..</code> <em>(Quay trở lại thư mục gốc của dự án chính).</em></li><li><code>git status</code> <em>(chúng ta sẽ thấy dòng <code>modified: Plugins/AwesomePlugin (new commits)</code>).</em></li><li><code>git add Plugins/AwesomePlugin</code></li><li><code>git commit -m "Feat: Update AwesomePlugin to version 2.0 for new feature X"</code></li><li><code>git push</code> <em>(Đẩy &ldquo;tờ giấy nhớ&rdquo; mới lên cho cả team).</em>
<em>Sau khi Lead push, các thành viên khác sẽ thực hiện quy trình B để nhận bản cập nhật.</em></li></ol></li><li><p><strong>D. Sửa lỗi/thêm tính năng tùy chỉnh vào plugin (Dành cho Dev):</strong></p><ol><li><code>cd Plugins/AwesomePlugin</code> <em>(Đi vào thư mục của submodule đã fork).</em></li><li><em>Thực hiện các thay đổi code&mldr;</em></li><li><code>git add .</code></li><li><code>git commit -m "Fix: Fixed a critical crash when..."</code></li><li><code>git push</code> <em>(Push thay đổi lên repository fork của plugin).</em></li><li><em>Làm theo các bước từ 4 đến 8 của quy trình C để cập nhật con trỏ trong repo chính.</em></li></ol></li></ul><h3 id=giai-đoạn-2-xây-dựng-và-phát-triển---lắp-ráp-các-khối-lego-gameplay>Giai đoạn 2: Xây dựng và Phát triển - Lắp ráp các khối Lego Gameplay<a hidden class=anchor aria-hidden=true href=#giai-đoạn-2-xây-dựng-và-phát-triển---lắp-ráp-các-khối-lego-gameplay>#</a></h3><p>Nếu Giai đoạn 1 là việc chuẩn bị &ldquo;xưởng lắp ráp&rdquo; và &ldquo;bản thiết kế&rdquo; (Project Setup, Git), thì Giai đoạn 2 chính là lúc
chúng ta thực sự lắp ráp các cỗ máy phức tạp từ những viên gạch Lego cơ bản. Mỗi tính năng, từ việc di chuyển, bắn súng,
đến nhặt đồ, đều là một cỗ máy nhỏ được lắp ráp từ 3 loại &ldquo;gạch Lego&rdquo; mạng cốt lõi: <strong>Replication</strong>, <strong>Network Roles</strong>,
và <strong>RPCs</strong>.</p><hr><h3 id=1-lập-trình-gameplay-cho-multiplayer-bộ-gạch-lego-nền-tảng>1. Lập trình Gameplay cho Multiplayer: Bộ gạch Lego nền tảng<a hidden class=anchor aria-hidden=true href=#1-lập-trình-gameplay-cho-multiplayer-bộ-gạch-lego-nền-tảng>#</a></h3><p>Hãy tưởng tượng <strong>Server là người Thợ Cả (Master Builder)</strong>, người duy nhất có bản thiết kế gốc và quyền quyết định cuối
cùng. <strong>Mỗi Client là một người Học Việc</strong>, đang cố gắng xây một bản sao y hệt mô hình của Thợ Cả.</p><h4 id=a-replication-sao-chép><strong>A. Replication (Sao chép): &ldquo;Thợ Cả thông báo sự thay đổi&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#a-replication-sao-chép>#</a></h4><p>Đây là loại gạch Lego cơ bản nhất, dùng để đồng bộ hóa <strong>trạng thái</strong> (state) của các vật thể.</p><ul><li><p><strong>Phép loại suy Lego:</strong> Khi Thợ Cả (Server) thay đổi màu của một viên gạch trên mô hình gốc từ xanh sang đỏ, họ sẽ hô
lên cho tất cả Học Việc (Clients): &ldquo;Viên gạch ở vị trí XYZ giờ là màu đỏ!&rdquo;. Mọi người Học Việc nghe thấy và thay đổi
viên gạch tương ứng trên bản sao của họ.</p></li><li><p><strong>Tại sao nó quan trọng?</strong></p><ul><li>Nó đảm bảo rằng thế giới game của mọi người chơi trông giống nhau. Máu của một nhân vật, số đạn trong băng, vị trí
của một cánh cửa&mldr; tất cả đều là &ldquo;trạng thái&rdquo; cần được đồng bộ.</li><li>Đây là cách hiệu quả nhất để giữ cho dữ liệu nhất quán mà không cần gửi tin nhắn liên tục.</li></ul></li><li><p><strong>Làm như thế nào trong C++?</strong></p><ol><li>Trong file <code>.h</code> của Actor, chúng ta phải bật chế độ replication: <code>bReplicates = true;</code> trong Constructor.</li><li>Đánh dấu các biến cần đồng bộ bằng <code>UPROPERTY(Replicated)</code> hoặc <code>UPROPERTY(ReplicatedUsing=FunctionName)</code>.</li><li>Override hàm <code>GetLifetimeReplicatedProps</code>.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// MyCharacter.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#pragma once
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;GameFramework/Character.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;MyCharacter.generated.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>UCLASS()
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MYGAME_API</span> AMyCharacter : <span style=color:#66d9ef>public</span> ACharacter
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    GENERATED_BODY()
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    AMyCharacter();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Biến này sẽ được đồng bộ từ Server xuống các Client
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    UPROPERTY(ReplicatedUsing <span style=color:#f92672>=</span> OnRep_CurrentHealth)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> CurrentHealth;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    UFUNCTION()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> OnRep_CurrentHealth(); <span style=color:#75715e>// Hàm này sẽ được gọi trên Client mỗi khi CurrentHealth thay đổi
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> GetLifetimeReplicatedProps(TArray<span style=color:#f92672>&lt;</span>FLifetimeProperty<span style=color:#f92672>&gt;&amp;</span> OutLifetimeProps) <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>override</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// MyCharacter.cpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;Net/UnrealNetwork.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>AMyCharacter<span style=color:#f92672>::</span>AMyCharacter()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    bReplicates <span style=color:#f92672>=</span> true; <span style=color:#75715e>// Bật chức năng &#34;Lego&#34; cho Actor này
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> AMyCharacter<span style=color:#f92672>::</span>GetLifetimeReplicatedProps(TArray<span style=color:#f92672>&lt;</span>FLifetimeProperty<span style=color:#f92672>&gt;&amp;</span> OutLifetimeProps) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Super<span style=color:#f92672>::</span>GetLifetimeReplicatedProps(OutLifetimeProps);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Đăng ký biến CurrentHealth vào hệ thống replication
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    DOREPLIFETIME(AMyCharacter, CurrentHealth);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> AMyCharacter<span style=color:#f92672>::</span>OnRep_CurrentHealth()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Đây là nơi hoàn hảo để cập nhật thanh máu trên UI của Client
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Vì nó chỉ chạy trên Client khi máu thực sự thay đổi.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></li><li><p><strong>OOP & Tip Trick:</strong></p><ul><li><strong>Nguyên tắc Đóng gói (Encapsulation):</strong> Không bao giờ để Client trực tiếp thay đổi các biến Replicated. Hãy làm
cho <code>CurrentHealth</code> thành <code>private</code> hoặc <code>protected</code> và tạo ra một hàm public như <code>TakeDamage(float Damage)</code> để xử
lý. Việc thay đổi máu thực sự chỉ nên xảy ra trên Server.</li><li><strong><code>ReplicatedUsing</code> là người chúng ta tốt nhất của chúng ta:</strong> Dùng nó để kích hoạt các hiệu ứng hình ảnh/âm thanh
trên
Client (như cập nhật UI, chạy hiệu ứng máu bắn ra) ngay khi một biến được cập nhật. Điều này giúp tách biệt logic
gameplay (trên server) và logic hiển thị (trên client).</li></ul></li></ul><h4 id=b-network-roles-vai-trò-mạng><strong>B. Network Roles (Vai trò mạng): &ldquo;Ai là Thợ Cả?&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#b-network-roles-vai-trò-mạng>#</a></h4><p>Hệ thống này xác định quyền hạn của mỗi máy tính đối với một Actor cụ thể.</p><ul><li><p><strong>Phép loại suy Lego:</strong></p><ul><li><strong>Authority (Thợ Cả):</strong> Máy tính có bản thiết kế gốc của một Actor (luôn là Server cho các Actor trong thế giới
game). Chỉ nó mới có quyền thay đổi Actor đó.</li><li><strong>Autonomous Proxy (Học Việc tự chủ):</strong> Client đang điều khiển trực tiếp Actor đó (ví dụ: nhân vật của chính chúng
ta).
Client này có thể gửi <strong>yêu cầu</strong> cho Thợ Cả nhanh hơn.</li><li><strong>Simulated Proxy (Học Việc quan sát):</strong> Client chỉ đang nhìn thấy một Actor do người khác điều khiển. Họ chỉ nhận
thông tin cập nhật từ Thợ Cả.</li></ul></li><li><p><strong>Tại sao nó quan trọng?</strong></p><ul><li><strong>Chống gian lận (Anti-Cheat):</strong> Đây là nền tảng của mô hình Server-Authoritative. Một Client không thể tự quyết
định &ldquo;OK, máu của tôi bây giờ là 1000&rdquo; vì nó không có <code>Authority</code>. Mọi quyết định quan trọng về gameplay (trừ máu,
tính sát thương, cho vật phẩm) đều phải được kiểm tra qua <code>HasAuthority()</code>.</li><li><strong>Tối ưu hóa:</strong> Logic AI, các tính toán phức tạp chỉ cần chạy trên Server (<code>Authority</code>), không cần chạy trên
Client.</li></ul></li><li><p><strong>Làm như thế nào?</strong></p><ul><li>Sử dụng <code>if (HasAuthority())</code> hoặc <code>if (GetLocalRole() == ROLE_Authority)</code> để bao bọc các đoạn code chỉ Server mới
được phép thực thi.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> AMyCharacter<span style=color:#f92672>::</span>TakeDamage(<span style=color:#66d9ef>float</span> DamageAmount)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Chỉ Thợ Cả (Server) mới có quyền trừ máu
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (HasAuthority())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        CurrentHealth <span style=color:#f92672>=</span> FMath<span style=color:#f92672>::</span>Max(<span style=color:#ae81ff>0.0f</span>, CurrentHealth <span style=color:#f92672>-</span> DamageAmount);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Server thay đổi giá trị. Sau đó, hệ thống Replication sẽ tự động
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// gửi giá trị CurrentHealth mới này xuống cho tất cả các Client.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>OOP & Tip Trick:</strong></p><ul><li><strong>Authority Pattern:</strong> Đây là một Design Pattern cơ bản trong lập trình mạng. Hãy tập thói quen luôn tự hỏi: &ldquo;Đoạn
code này có thay đổi trạng thái của game không? Nếu có, nó có đang được bọc trong <code>if (HasAuthority())</code> không?&rdquo;.</li><li>Trong Blueprint, chúng ta có thể dùng node <code>Switch Has Authority</code>.</li></ul></li></ul><h4 id=c-remote-procedure-calls-rpcs><strong>C. Remote Procedure Calls (RPCs): &ldquo;Kênh giao tiếp giữa Thợ Cả và Học Việc&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#c-remote-procedure-calls-rpcs>#</a></h4><p>RPCs là các &ldquo;mệnh lệnh&rdquo; hoặc &ldquo;yêu cầu&rdquo; dưới dạng hàm được gọi qua mạng. Chúng dùng cho các <strong>sự kiện</strong> (events), không
phải trạng thái.</p><ul><li><p><strong>Phép loại suy Lego:</strong></p><ul><li><strong>Server RPC (Yêu cầu lên Thợ Cả):</strong> Người Học Việc (Client) nói với Thợ Cả (Server): &ldquo;Thưa ngài, tôi muốn bắn
khẩu súng này!&rdquo;.</li><li><strong>Client RPC (Mệnh lệnh cho một Học Việc):</strong> Thợ Cả nói riêng với người Học Việc vừa yêu cầu: &ldquo;OK, khẩu súng của
cậu bị giật mạnh, hãy hiển thị hiệu ứng đó trên màn hình của cậu đi!&rdquo;.</li><li><strong>Multicast RPC (Thông báo cho tất cả):</strong> Thợ Cả hô to cho tất cả mọi người: &ldquo;Mọi người chú ý! Vừa có một tiếng
súng nổ ở vị trí XYZ, hãy chạy hiệu ứng và âm thanh!&rdquo;.</li></ul></li><li><p><strong>Tại sao nó quan trọng?</strong></p><ul><li>Đây là cách duy nhất để Client có thể yêu cầu Server thực hiện một hành động. Client không thể tự mình bắn súng,
họ phải &ldquo;xin phép&rdquo; Server.</li><li>Dùng để kích hoạt các hiệu ứng tức thời, không đáng tin cậy (unreliable) như tiếng bước chân, hoặc các sự kiện
quan trọng, đáng tin cậy (reliable) như sử dụng một kỹ năng.</li></ul></li><li><p><strong>Làm như thế nào?</strong></p><ul><li>Sử dụng các macro <code>UFUNCTION</code> đặc biệt trong file <code>.h</code>.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// MyCharacter.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Client gọi hàm này, nhưng nó sẽ thực thi trên Server
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>UFUNCTION(Server, Reliable, WithValidation)
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Server_FireWeapon();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Server gọi hàm này, nó sẽ thực thi trên tất cả các Client
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>UFUNCTION(NetMulticast, Unreliable)
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Multicast_PlayFireFX();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// MyCharacter.cpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Hàm kiểm tra xem yêu cầu từ Client có hợp lệ không
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> AMyCharacter<span style=color:#f92672>::</span>Server_FireWeapon_Validate() { <span style=color:#66d9ef>return</span> true; <span style=color:#75715e>/* Thêm logic kiểm tra chống spam ở đây */</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Logic thực thi trên Server sau khi Client yêu cầu
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> AMyCharacter<span style=color:#f92672>::</span>Server_FireWeapon_Implementation()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Kiểm tra xem nhân vật có đủ đạn, có đang bị khống chế không...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// -&gt; Logic gameplay cốt lõi chỉ chạy trên Server
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (CanFire())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Bắn một tia đạn (line trace)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Trừ đạn
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Gây sát thương nếu trúng đích
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Sau khi xử lý xong, thông báo cho tất cả mọi người
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Multicast_PlayFireFX();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> AMyCharacter<span style=color:#f92672>::</span>Multicast_PlayFireFX_Implementation()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Chạy hiệu ứng tia lửa đầu nòng, âm thanh súng nổ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Đoạn code này sẽ chạy trên Server VÀ tất cả các Client
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> AMyCharacter<span style=color:#f92672>::</span>Fire() <span style=color:#75715e>// Hàm này được gọi từ input của người chơi
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Người chơi (Client) không trực tiếp bắn.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Họ gửi yêu cầu lên Server.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Server_FireWeapon();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>OOP & Tip Trick:</strong></p><ul><li><strong>Command Pattern:</strong> RPCs, đặc biệt là Server RPC, hoạt động rất giống Command Pattern. Client đóng gói một "
lệnh" (bắn súng, dùng item) và gửi nó đi, Server là người nhận và thực thi lệnh đó.</li><li><strong><code>Reliable</code> vs <code>Unreliable</code>:</strong> Chỉ sử dụng <code>Reliable</code> cho những gì <strong>bắt buộc</strong> phải đến nơi (bắn súng, dùng kỹ
năng). Sử dụng <code>Unreliable</code> cho các hiệu ứng phụ, không quan trọng (tiếng bước chân, tia lửa&mldr;). Gửi quá nhiều
RPC <code>Reliable</code> có thể làm nghẽn mạng.</li></ul></li></ul><hr><h3 id=2-các-plugin-cần-thiết-những-bộ-lego-technic-chuyên-dụng>2. Các Plugin cần thiết: Những bộ Lego Technic chuyên dụng<a hidden class=anchor aria-hidden=true href=#2-các-plugin-cần-thiết-những-bộ-lego-technic-chuyên-dụng>#</a></h3><p>Đây là những &ldquo;bộ Lego&rdquo; làm sẵn, cực kỳ phức tạp mà chúng ta không muốn tự mình xây dựng từ đầu.</p><ul><li><p><strong>Online Subsystem (OSS):</strong></p><ul><li><strong>Nó là gì?</strong> Một lớp trừu tượng (Interface) của Unreal Engine, hoạt động như một &ldquo;đầu cắm Lego đa năng&rdquo;. chúng ta
chỉ
cần lập trình với đầu cắm này, nó sẽ tự động tương thích với các &ldquo;ổ cắm&rdquo; khác nhau như Steam, Epic Online
Services, Xbox Live&mldr;</li><li><strong>Tại sao cần?</strong> Để chúng ta không phải viết code riêng cho từng nền tảng. Viết code tạo phòng chờ (session) một
lần,
chạy được cả trên Steam và Epic Games Store.</li><li><strong>Lưu ý:</strong> Việc cấu hình OSS trong file <code>DefaultEngine.ini</code> khá phức tạp và đặc thù cho từng nền tảng. Hãy đọc kỹ
tài liệu của Epic và nền tảng chúng ta chọn.</li></ul></li><li><p><strong>Advanced Sessions Plugin:</strong></p><ul><li><strong>Nó là gì?</strong> Một plugin miễn phí giúp việc sử dụng OSS trở nên đơn giản hơn rất nhiều bằng cách cung cấp các node
Blueprint tiện lợi.</li><li><strong>Tại sao cần?</strong> Nó là một &ldquo;bộ chuyển đổi&rdquo; giúp việc cắm các &ldquo;đầu cắm Lego&rdquo; trở nên dễ dàng hơn, đặc biệt nếu
chúng ta
muốn các game designer có thể tự tạo logic phòng chờ bằng Blueprint.</li></ul></li><li><p><strong>Voice Chat / Anti-Cheat:</strong></p><ul><li>Đây là những &ldquo;bộ Lego&rdquo; chuyên dụng khác. Việc tích hợp chúng thường đòi hỏi làm việc với SDK riêng của nhà cung
cấp (Vivox, EAC&mldr;). Hãy coi chúng như những submodule riêng biệt trong dự án.</li></ul></li></ul><hr><h3 id=3-biên-dịch-build-và-đóng-gói-package-tạo-ra-hai-bộ-lego-để-bán>3. Biên dịch (Build) và Đóng gói (Package): Tạo ra hai bộ Lego để bán<a hidden class=anchor aria-hidden=true href=#3-biên-dịch-build-và-đóng-gói-package-tạo-ra-hai-bộ-lego-để-bán>#</a></h3><p>Sau khi lắp ráp xong mô hình, chúng ta cần tạo ra hai phiên bản &ldquo;hộp sản phẩm&rdquo; khác nhau.</p><ul><li><p><strong>Biên dịch Server:</strong></p><ul><li><strong>Nó là gì?</strong> Là quá trình tạo ra một file <code>.exe</code> chỉ chứa logic gameplay, không có đồ họa, âm thanh.</li><li><strong>Tại sao?</strong> Vì server không cần render thế giới game, nó chỉ cần tính toán. File <code>.exe</code> này siêu nhẹ, giúp chúng
ta
chạy nhiều phòng game trên một máy chủ vật lý để tiết kiệm chi phí.</li><li><strong>Làm như thế nào?</strong> Trong Visual Studio, ở thanh dropdown Solution Configurations, thay vì chọn
<code>Development Editor</code>, hãy chọn <code>Development Server</code> và nhấn Build.</li></ul></li><li><p><strong>Đóng gói (Packaging):</strong></p><ul><li><strong>Nó là gì?</strong> Là quá trình &ldquo;nấu&rdquo; (cook) tất cả các assets của chúng ta (model, texture, map&mldr;) thành định dạng
tối ưu
và đóng gói chúng cùng với file <code>.exe</code> để tạo ra một sản phẩm hoàn chỉnh có thể phân phối.</li><li><strong>Sự khác biệt cốt lõi:</strong><ul><li><strong>Đóng gói Client:</strong> <code>File > Package Project > Windows</code>. Đây là phiên bản đầy đủ cho người chơi, chứa cả đồ
họa và gameplay.</li><li><strong>Đóng gói Server:</strong> <code>File > Package Project > Build Target > [TênDựÁn] Server</code>. Thao tác này sẽ tạo ra một
thư mục riêng (ví dụ <code>WindowsServer</code>) chỉ chứa những gì server cần. Nó sẽ không có các texture 4K hay các file
âm thanh nặng nề.</li></ul></li></ul></li><li><p><strong>Tip & Trick cho Team:</strong></p><ul><li><strong>Tự động hóa:</strong> Viết một file script <code>.bat</code> đơn giản sử dụng <code>RunUAT.bat</code> của Unreal để tự động hóa toàn bộ quá
trình đóng gói cho cả Client và Server. Điều này đảm bảo tính nhất quán và tiết kiệm thời gian, đặc biệt khi chúng
ta
cần build thường xuyên. Mỗi lần cần build mới, chỉ cần chạy một file batch là xong.</li></ul></li></ul><p>Tuyệt vời! Chúng ta sẽ đi sâu vào hai giai đoạn cuối cùng, tập trung vào việc biến sản phẩm trong môi trường phát triển
thành một hệ thống hoạt động thực tế, ổn định và có thể mở rộng. Đây là lúc công trình Lego của chúng ta được kiểm tra
độ bền
và đưa ra thế giới.</p><hr><h3 id=giai-đoạn-3-kiểm-thử-và-tối-ưu-hóa---thử-nghiệm-và-gia-cố-công-trình-lego>Giai đoạn 3: Kiểm thử và Tối ưu hóa - Thử nghiệm và Gia cố công trình Lego<a hidden class=anchor aria-hidden=true href=#giai-đoạn-3-kiểm-thử-và-tối-ưu-hóa---thử-nghiệm-và-gia-cố-công-trình-lego>#</a></h3><p>Đây là giai đoạn chúng ta &ldquo;lắc mạnh&rdquo; công trình Lego của mình để xem có mảnh nào rơi ra không, và tìm cách gia cố những
điểm
yếu trước khi giao cho người khác chơi.</p><h4 id=1-chạy-và-kiểm-thử-dedicated-server-cục-bộ-sân-chơi-thử-nghiệm-tại-nhà>1. Chạy và kiểm thử Dedicated Server cục bộ: Sân chơi thử nghiệm tại nhà<a hidden class=anchor aria-hidden=true href=#1-chạy-và-kiểm-thử-dedicated-server-cục-bộ-sân-chơi-thử-nghiệm-tại-nhà>#</a></h4><p>Trước khi đưa server lên mây, việc kiểm thử tại chính máy của chúng ta là bước nhanh nhất và hiệu quả nhất để tìm ra các
lỗi
gameplay.</p><ul><li><p><strong>Làm như thế nào?</strong></p><ol><li><strong>Tạo file Batch (.bat) để tự động hóa:</strong> Thay vì tạo shortcut và chỉnh tay, hãy tạo các file <code>.bat</code>. Đây là
một &ldquo;Tip & Trick&rdquo; cực kỳ tiết kiệm thời gian cho cả team.<ul><li><strong><code>StartServer.bat</code>:</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-batch data-lang=batch><span style=display:flex><span>@<span style=color:#66d9ef>echo</span> off
</span></span><span style=display:flex><span><span style=color:#66d9ef>echo</span> Starting Server...
</span></span><span style=display:flex><span><span style=color:#66d9ef>start</span> Binaries\Win64\[TênDựÁn]Server.exe /Game/Maps/TenMap_Gameplay?listen -log
</span></span><span style=display:flex><span><span style=color:#66d9ef>exit</span>
</span></span></code></pre></div><ul><li><code>?listen</code>: Báo cho server biết nó cần mở cổng và lắng nghe kết nối từ client.</li><li><code>-log</code>: Mở một cửa sổ console riêng để chúng ta có thể xem log của server theo thời gian thực.</li></ul></li><li><strong><code>StartClient.bat</code>:</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-batch data-lang=batch><span style=display:flex><span>@<span style=color:#66d9ef>echo</span> off
</span></span><span style=display:flex><span><span style=color:#66d9ef>echo</span> Starting Client...
</span></span><span style=display:flex><span><span style=color:#66d9ef>start</span> Binaries\Win64\[TênDựÁn].exe 127.0.0.1 -game
</span></span><span style=display:flex><span><span style=color:#66d9ef>exit</span>
</span></span></code></pre></div><ul><li><code>127.0.0.1</code>: Địa chỉ IP &ldquo;localhost&rdquo;, tức là kết nối đến server đang chạy trên cùng máy.</li><li><code>-game</code>: Chạy game ở chế độ cửa sổ độc lập thay vì mở editor.</li></ul></li></ul></li><li><strong>Kiểm thử trong Editor:</strong> Để debug nhanh hơn, hãy vào <code>Play > Advanced Settings...</code>. Tại đây, chúng ta có thể
thiết
lập:<ul><li><code>Number of Players</code>: Đặt là 2 hoặc hơn.</li><li><code>Multiplayer Options > Run Dedicated Server</code>: Đánh dấu tick vào đây.</li><li>Khi chúng ta nhấn Play, Unreal Editor sẽ tự động khởi chạy một server và nhiều client, cho phép chúng ta đặt
breakpoint
và debug trực tiếp.</li></ul></li></ol></li><li><p><strong>Tại sao lại làm như thế?</strong></p><ul><li><strong>Vòng lặp nhanh (Fast Iteration):</strong> Việc chạy và kiểm thử cục bộ cho phép chúng ta tìm và sửa lỗi logic
gameplay (
replication, RPCs&mldr;) trong vài phút, thay vì mất hàng giờ để build, tải lên server đám mây rồi mới phát hiện lỗi.</li><li><strong>Tách biệt vấn đề:</strong> Nếu game chạy đúng ở local nhưng lỗi khi lên server, chúng ta biết vấn đề nằm ở môi trường
mạng
hoặc cấu hình máy chủ, chứ không phải ở code gameplay.</li></ul></li><li><p><strong>Tip & Trick cần thiết:</strong></p><ul><li><strong>Giả lập mạng kém:</strong> Mạng ở local luôn hoàn hảo. Để kiểm thử game trong điều kiện thực tế, hãy sử dụng các lệnh
console trong client để giả lập lag và mất gói tin:<ul><li><code>Net PktLag=[miligiây]</code>: Ví dụ <code>Net PktLag=100</code> để giả lập ping 100ms.</li><li><code>Net PktLoss=[phần trăm]</code>: Ví dụ <code>Net PktLoss=5</code> để giả lập mất 5% gói tin.</li><li>Đây là bước <strong>bắt buộc</strong> để tìm ra các lỗi liên quan đến dự đoán chuyển động (movement prediction) và các sự
kiện không đáng tin cậy (unreliable RPCs).</li></ul></li><li><strong>Sử dụng nhiều file <code>.bat</code>:</strong> Tạo nhiều file <code>StartClient_Player2.bat</code>, <code>StartClient_Player3.bat</code>&mldr; để nhanh
chóng mở nhiều client cho một lần test.</li></ul></li></ul><h4 id=2-tối-ưu-hóa-hiệu-năng-đảm-bảo-công-trình-lego-không-bị-sập-khi-có-nhiều-người-chơi>2. Tối ưu hóa hiệu năng: Đảm bảo công trình Lego không bị sập khi có nhiều người chơi<a hidden class=anchor aria-hidden=true href=#2-tối-ưu-hóa-hiệu-năng-đảm-bảo-công-trình-lego-không-bị-sập-khi-có-nhiều-người-chơi>#</a></h4><ul><li><p><strong>Network Relevancy and Culling: &ldquo;Chỉ gửi những viên Lego mà người chơi nhìn thấy&rdquo;</strong></p><ul><li><strong>Nó là gì?</strong> Theo mặc định, Unreal sẽ không gửi cập nhật về một Actor cho một người chơi nếu Actor đó ở quá xa.
Đây là &ldquo;Distance-based culling&rdquo;. Tuy nhiên, chúng ta có thể kiểm soát nó một cách tinh vi hơn.</li><li><strong>Làm như thế nào?</strong> Override hàm <code>bool AActor::IsNetRelevantFor(const FRealViewer& RealViewer)</code> trong Actor của
chúng ta.</li><li><strong>Tại sao nó quan trọng?</strong> Tưởng tượng một game battle royale 100 người. Nếu server gửi thông tin của tất cả 99
người chơi khác đến máy chúng ta, băng thông sẽ tắc nghẽn ngay lập tức. Bằng cách chỉ gửi thông tin của 5-10 người
chơi
gần nhất, chúng ta đã giảm tải mạng xuống hơn 90%.</li><li><strong>Tip & Trick:</strong><ul><li><strong>Ví dụ thực tế:</strong> Một đơn vị tàng hình (invisible). Hàm <code>IsNetRelevantFor</code> của nó nên được viết để trả về
<code>false</code> đối với những người chơi thuộc đội đối phương (trừ khi họ có item phát hiện tàng hình).</li><li><strong>Tần suất cập nhật:</strong> Tinh chỉnh biến <code>NetUpdateFrequency</code> của Actor. Các Actor di chuyển nhanh (như nhân
vật) cần tần suất cao (ví dụ: 100 lần/giây), nhưng các Actor tĩnh hoặc ít thay đổi (như một cánh cửa) chỉ cần
tần suất rất thấp (ví dụ: 2 lần/giây).</li></ul></li></ul></li><li><p><strong>Server-side Optimization: &ldquo;Thợ Cả không cần quan tâm đến màu sắc&rdquo;</strong></p><ul><li><strong>Nó là gì?</strong> Server chỉ quan tâm đến logic: Vị trí ở đâu? Máu bao nhiêu? Có bắn trúng không? Nó không cần biết
hiệu ứng cháy nổ trông đẹp thế nào, hay âm thanh nghe ra sao.</li><li><strong>Làm như thế nào?</strong> Sử dụng preprocessor directive một cách triệt để.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> AMyProjectile<span style=color:#f92672>::</span>OnHit(...)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Logic gây sát thương luôn chạy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ApplyDamage(...);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Logic hiệu ứng chỉ chạy trên các máy có thể &#34;thấy&#34; được
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>#if !UE_SERVER
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        UGameplayStatics<span style=color:#f92672>::</span>SpawnEmitterAtLocation(GetWorld(), HitFX, GetActorLocation());
</span></span><span style=display:flex><span>        UGameplayStatics<span style=color:#f92672>::</span>PlaySoundAtLocation(GetWorld(), HitSound, GetActorLocation());
</span></span><span style=display:flex><span>    <span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></li><li><strong>Tại sao?</strong> Mỗi chu kỳ CPU được tiết kiệm trên server có nghĩa là server có thể xử lý nhiều người chơi hơn, hoặc
chạy các thuật toán AI phức tạp hơn. Việc loại bỏ các tác vụ đồ họa/âm thanh là cách tiết kiệm tài nguyên hiệu quả
nhất.</li></ul></li><li><p><strong>Profiling: &ldquo;Dùng kính lúp soi từng viên gạch&rdquo;</strong></p><ul><li><strong>Nó là gì?</strong> Là quá trình đo lường để tìm ra chính xác phần nào của game đang gây chậm.</li><li><strong>Làm như thế nào?</strong><ul><li><strong>Unreal Insights:</strong> Đây là công cụ mạnh nhất. chúng ta chạy nó song song với game, nó sẽ ghi lại mọi thứ, từ
thời
gian thực thi của từng hàm C++, dữ liệu mạng được gửi đi, đến việc tải assets.</li><li><strong>Lệnh Console:</strong><ul><li><code>Stat Unit</code>: Hiển thị thời gian xử lý của Frame, Game Thread, Render Thread, GPU. Trên server, Game Thread
là quan trọng nhất.</li><li><code>Stat Net</code>: Hiển thị chi tiết thông tin mạng đang được gửi/nhận.</li></ul></li></ul></li><li><strong>Tại sao?</strong> &ldquo;Phỏng đoán là nguồn gốc của mọi sai lầm trong tối ưu hóa&rdquo;. Đừng đoán xem cái gì đang chậm, hãy đo
lường nó. chúng ta có thể ngạc nhiên khi thấy một hàm tưởng chừng vô hại lại đang chiếm 30% tài nguyên CPU của
server.</li></ul></li></ul><hr><h3 id=giai-đoạn-4-triển-khai-và-vận-hành---đóng-hộp-và-vận-chuyển-lego-đi-khắp-thế-giới>Giai đoạn 4: Triển khai và Vận hành - Đóng hộp và vận chuyển Lego đi khắp thế giới<a hidden class=anchor aria-hidden=true href=#giai-đoạn-4-triển-khai-và-vận-hành---đóng-hộp-và-vận-chuyển-lego-đi-khắp-thế-giới>#</a></h3><p>Đây là giai đoạn biến game của chúng ta từ một sản phẩm chạy trên máy cá nhân thành một dịch vụ toàn cầu.</p><h4 id=1-chuẩn-bị-cho-việc-triển-khai-xây-dựng-dây-chuyền-sản-xuất>1. Chuẩn bị cho việc triển khai: Xây dựng dây chuyền sản xuất<a hidden class=anchor aria-hidden=true href=#1-chuẩn-bị-cho-việc-triển-khai-xây-dựng-dây-chuyền-sản-xuất>#</a></h4><ul><li><p><strong>Cross-Compilation (Biên dịch chéo cho Linux):</strong></p><ul><li><strong>Nó là gì?</strong> Sử dụng Visual Studio trên Windows để tạo ra một file thực thi có thể chạy trên Linux.</li><li><strong>Làm như thế nào?</strong><ol><li>Mở Epic Games Launcher, tìm đến phiên bản Engine của chúng ta, chọn <code>Options</code>.</li><li>Trong <code>Target Platforms</code>, tick vào <code>Linux</code>. Launcher sẽ tải về bộ công cụ (toolchain) cần thiết.</li><li>Sau khi cài xong, chúng ta chỉ cần mở Visual Studio, chọn cấu hình <code>Development Server</code> và nền tảng <code>Linux</code>
để
biên dịch.</li></ol></li><li><strong>Tại sao?</strong> Chi phí thuê máy chủ Windows thường cao hơn đáng kể so với máy chủ Linux do chi phí bản quyền. Linux
cũng được coi là ổn định và hiệu quả hơn cho các tác vụ máy chủ. Hầu hết các nhà cung cấp dịch vụ game server đều
chạy trên Linux.</li></ul></li><li><p><strong>Containerization (Đóng gói bằng Docker): &ldquo;Đóng gói Lego vào hộp tiêu chuẩn&rdquo;</strong></p><ul><li><strong>Nó là gì?</strong> Docker gói ứng dụng server của chúng ta và tất cả những gì nó cần để chạy (thư viện, file cấu
hình&mldr;)
vào một &ldquo;container&rdquo; duy nhất. Container này giống như một máy ảo siêu nhẹ.</li><li><strong>Làm như thế nào?</strong> Tạo một file tên là <code>Dockerfile</code> trong thư mục dự án của chúng ta.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#75715e># Sử dụng một ảnh Linux cơ bản</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span> <span style=color:#e6db74>ubuntu:20.04</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Đặt thư mục làm việc bên trong container</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span> <span style=color:#e6db74>/app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Sao chép thư mục server đã được đóng gói từ máy của chúng ta vào container</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> ./LinuxServer ./<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Mở cổng 7777 cho kết nối game (giao thức UDP)</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>EXPOSE</span> <span style=color:#e6db74>7777/udp</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Lệnh sẽ được chạy khi container khởi động</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Thêm cờ -nohomedir để tránh lỗi ghi log vào thư mục không tồn tại</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;./MyGame/Binaries/Linux/MyGameServer-Linux-Shipping&#34;</span>, <span style=color:#e6db74>&#34;MyMap?listen&#34;</span>, <span style=color:#e6db74>&#34;-log&#34;</span>, <span style=color:#e6db74>&#34;-nohomedir&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li><li><strong>Tại sao?</strong><ul><li><strong>Tính nhất quán:</strong> Container đảm bảo server của chúng ta sẽ chạy y hệt trên máy của dev, trên server thử
nghiệm,
và trên server sản phẩm. Loại bỏ hoàn toàn lỗi &ldquo;Ủa, trên máy em chạy được mà!&rdquo;.</li><li><strong>Khả năng mở rộng:</strong> Các công cụ quản lý đám mây như Kubernetes và Agones được thiết kế để làm việc với
container. Chúng có thể tự động tạo ra, khởi động, và xóa đi hàng trăm container server của chúng ta dựa trên
nhu
cầu của người chơi.</li></ul></li></ul></li></ul><h4 id=2-triển-khai-lên-các-nền-tảng-đám-mây-chọn-nhà-kho-và-hệ-thống-vận-chuyển>2. Triển khai lên các nền tảng đám mây: Chọn nhà kho và hệ thống vận chuyển<a hidden class=anchor aria-hidden=true href=#2-triển-khai-lên-các-nền-tảng-đám-mây-chọn-nhà-kho-và-hệ-thống-vận-chuyển>#</a></h4><ul><li><strong>Các lựa chọn:</strong><ul><li><strong>Cơ bản (IaaS - Infrastructure as a Service):</strong> Thuê máy ảo (VM) trên AWS EC2, Google Cloud Compute Engine, Azure
VMs. chúng ta sẽ phải tự cài đặt mọi thứ, tự quản lý việc khởi động server, cập nhật phiên bản. Phù hợp để bắt đầu
và
học hỏi.</li><li><strong>Nâng cao (PaaS - Platform as a Service / Fleet Management):</strong> Sử dụng các dịch vụ chuyên dụng như **AWS Gamelift
** hoặc <strong>Google Cloud Agones</strong> (trên nền Kubernetes).</li></ul></li><li><strong>Tại sao nên dùng Fleet Management?</strong><ul><li>chúng ta chỉ cần đưa cho chúng container server của mình.</li><li>Chúng sẽ tự động:<ul><li><strong>Tự động co giãn (Autoscaling):</strong> Khi có nhiều người chơi, chúng tự tạo thêm server. Khi người chơi nghỉ,
chúng tự động xóa bớt để tiết kiệm tiền.</li><li><strong>Phân phối toàn cầu:</strong> Đặt server ở gần người chơi (ví dụ: người chơi ở châu Âu sẽ kết nối tới server ở
Frankfurt) để giảm ping.</li><li><strong>Kiểm tra sức khỏe (Health Checks):</strong> Tự động khởi động lại các server bị treo.</li></ul></li></ul></li><li><strong>Tip & Trick:</strong> Đừng cố tự xây dựng một hệ thống quản lý server (fleet management). Đó là một công việc cực kỳ phức
tạp. Hãy tận dụng các giải pháp đã có sẵn như Agones (mã nguồn mở) hoặc Gamelift.</li></ul><h4 id=3-tích-hợp-và-deploy-lên-store-ví-dụ-steam-đưa-sản-phẩm-lên-kệ>3. Tích hợp và Deploy lên Store (Ví dụ: Steam): Đưa sản phẩm lên kệ<a hidden class=anchor aria-hidden=true href=#3-tích-hợp-và-deploy-lên-store-ví-dụ-steam-đưa-sản-phẩm-lên-kệ>#</a></h4><ul><li><p><strong>Cấu hình App và Depot: &ldquo;Hai hộp sản phẩm khác nhau&rdquo;</strong></p><ul><li>chúng ta cần liên hệ với Valve để yêu cầu tạo <strong>hai App ID</strong>:<ol><li><strong>App ID chính (Type: Game):</strong> Đây là game mà người chơi sẽ mua.</li><li><strong>App ID phụ (Type: Tool):</strong> Đây là &ldquo;Dedicated Server&rdquo; của chúng ta, nó sẽ miễn phí.</li></ol></li><li>Trong mỗi App, chúng ta tạo &ldquo;Depot&rdquo; (kho chứa file):<ul><li>Depot của game sẽ chứa các bản build cho Windows, Mac, Linux của <strong>client</strong>.</li><li>Depot của server sẽ chỉ chứa bản build <strong>Linux server</strong>.</li></ul></li><li><strong>Tại sao?</strong> Điều này cho phép người chơi chỉ tải về client (khoảng 20GB), và những người muốn host server (hoặc
chính chúng ta) chỉ cần tải về server (khoảng 500MB).</li></ul></li><li><p><strong>SteamPipe: &ldquo;Cỗ máy đóng gói và dán nhãn&rdquo;</strong></p><ul><li>Nó là một công cụ dòng lệnh để tải các file build của chúng ta lên các depot tương ứng.</li><li>chúng ta sẽ tạo các file kịch bản <code>.vdf</code> để chỉ định &ldquo;thư mục build client&rdquo; sẽ được tải lên &ldquo;depot client&rdquo;, và "
thư mục
build server" sẽ được tải lên &ldquo;depot server&rdquo;.</li><li><strong>Tip & Trick (Quan trọng):</strong> Sử dụng các nhánh (branch) khác nhau trong Steamworks.<ul><li><strong><code>development</code> branch:</strong> Tải các bản build hàng ngày lên đây để team nội bộ và QA kiểm thử.</li><li><strong><code>public</code> branch (mặc định):</strong> Chỉ khi bản build ở nhánh <code>development</code> đã ổn định, chúng ta mới &ldquo;promote&rdquo; nó
sang
nhánh này cho tất cả người chơi. Đây là quy trình phát hành an toàn, tránh việc đẩy một bản build lỗi ra cho
toàn bộ cộng đồng.</li></ul></li></ul></li><li><p><strong>Kịch bản cài đặt (Install Script):</strong></p><ul><li>Trong cấu hình depot của server trên Steamworks, chúng ta cần thêm một kịch bản cài đặt.</li><li>Nó sẽ chạy khi ai đó tải server của chúng ta qua SteamCMD, đảm bảo các thư viện cần thiết trên Linux được cài đặt.</li></ul></li></ul><hr><h3 id=giai-đoạn-5-vận-hành-chuyên-nghiệp---dây-chuyền-lắp-ráp-tự-động-và-trung-tâm-điều-khiển><strong>Giai đoạn 5: Vận hành Chuyên nghiệp - Dây chuyền lắp ráp tự động và Trung tâm điều khiển</strong><a hidden class=anchor aria-hidden=true href=#giai-đoạn-5-vận-hành-chuyên-nghiệp---dây-chuyền-lắp-ráp-tự-động-và-trung-tâm-điều-khiển>#</a></h3><p>Ra mắt game mới chỉ là sự khởi đầu. Để vận hành một game online thành công, chúng ta cần các quy trình tự động hóa và
các
công cụ giám sát mạnh mẽ.</p><h4 id=1-cicd-continuous-integrationcontinuous-deployment-dây-chuyền-lắp-ráp-tự-động><strong>1. CI/CD (Continuous Integration/Continuous Deployment): Dây chuyền lắp ráp tự động</strong><a hidden class=anchor aria-hidden=true href=#1-cicd-continuous-integrationcontinuous-deployment-dây-chuyền-lắp-ráp-tự-động>#</a></h4><ul><li><strong>Nó là gì?</strong> CI/CD là một phương pháp mà mỗi khi một lập trình viên đẩy code lên một nhánh nhất định (ví dụ:
<code>develop</code>), một hệ thống tự động sẽ:<ol><li><strong>CI (Tích hợp liên tục):</strong> Lấy code mới về, biên dịch game, chạy các bài test tự động để đảm bảo không có lỗi
nào mới được thêm vào.</li><li><strong>CD (Triển khai liên tục):</strong> Nếu CI thành công, nó sẽ tự động đóng gói (package) bản build Client và Server, sau
đó tải chúng lên Steam (vào nhánh <code>development</code>) và triển khai container server mới lên môi trường thử nghiệm (
staging environment) trên đám mây.</li></ol></li><li><strong>Tại sao nó là chân lý?</strong><ul><li><strong>Loại bỏ sai sót con người:</strong> Không còn cảnh &ldquo;quên build server&rdquo; hay &ldquo;đóng gói nhầm phiên bản&rdquo;. Mọi thứ đều tự
động và nhất quán.</li><li><strong>Tăng tốc độ phát triển:</strong> Team có thể có bản build mới để test mỗi ngày, thậm chí mỗi giờ, thay vì chờ đợi một
người build thủ công.</li><li><strong>An toàn:</strong> Các bài test tự động hoạt động như một lớp bảo vệ, ngăn chặn lỗi nghiêm trọng được đưa vào game.</li></ul></li><li><strong>Làm như thế nào?</strong><ul><li>Sử dụng các dịch vụ như <strong>GitHub Actions</strong> (tích hợp sẵn với GitHub), <strong>Jenkins</strong>, hoặc <strong>GitLab CI/CD</strong>.</li><li>chúng ta sẽ viết các file kịch bản (ví dụ <code>.yml</code> cho GitHub Actions) để định nghĩa các bước trên.</li></ul></li></ul><h4 id=2-backend-services-và-matchmaking-bộ-não-đằng-sau-cuộc-vui><strong>2. Backend Services và Matchmaking: Bộ não đằng sau cuộc vui</strong><a hidden class=anchor aria-hidden=true href=#2-backend-services-và-matchmaking-bộ-não-đằng-sau-cuộc-vui>#</a></h4><ul><li><strong>Game Server vs. Backend Server:</strong><ul><li><strong>Game Server (Dedicated Server):</strong> Xử lý logic game thời gian thực (real-time). Vòng đời của nó ngắn, chỉ tồn tại
trong một trận đấu.</li><li><strong>Backend Services:</strong> Một tập hợp các dịch vụ chạy 24/7, không xử lý real-time. Chúng là nơi lưu trữ dữ liệu bền
vững và xử lý các logic meta-game.</li></ul></li><li><strong>Các dịch vụ Backend cốt lõi:</strong><ul><li><strong>Identity/Account Service:</strong> Quản lý tài khoản, đăng nhập, liên kết với Steam/Epic.</li><li><strong>Player Data Storage:</strong> Lưu trữ kho đồ, tiền tệ, tiến trình của người chơi trong một cơ sở dữ liệu (Database).</li><li><strong>Matchmaking Service:</strong> Đây là dịch vụ &ldquo;mai mối&rdquo;. Người chơi gửi yêu cầu &ldquo;tìm trận&rdquo; đến đây. Matchmaker sẽ dựa
trên các quy tắc (ping, rank/skill, chế độ chơi) để tập hợp một nhóm người chơi và ra lệnh cho hệ thống Fleet
Management (như Agones) khởi động một Game Server mới cho họ.</li></ul></li><li><strong>Tip & Trick:</strong><ul><li>Đừng cố tự xây dựng tất cả từ đầu. Hãy xem xét các giải pháp &ldquo;Backend-as-a-Service&rdquo; (BaaS) như <strong>AccelByte</strong>, *
<em>Pragma Platform</em>*, hoặc <strong>Amazon GameSparks</strong>. Chúng cung cấp sẵn các dịch vụ trên.</li><li>Đối với matchmaking, <strong>Open Match</strong> của Google là một framework mã nguồn mở mạnh mẽ.</li></ul></li></ul><h4 id=3-ghi-log-giám-sát-và-vận-hành-trực-tiếp-live-ops-trung-tâm-điều-khiển><strong>3. Ghi log, Giám sát và Vận hành trực tiếp (Live Ops): Trung tâm điều khiển</strong><a hidden class=anchor aria-hidden=true href=#3-ghi-log-giám-sát-và-vận-hành-trực-tiếp-live-ops-trung-tâm-điều-khiển>#</a></h4><ul><li><p><strong>Structured Logging (Ghi log có cấu trúc):</strong></p><ul><li>Đừng chỉ ghi log dưới dạng text thông thường: <code>Player John connected.</code>.</li><li>Hãy ghi log dưới dạng JSON:
<code>{"timestamp": "...", "event": "PlayerConnect", "playerId": "12345", "playerName": "John", "serverIp": "..."}</code>.</li><li><strong>Tại sao?</strong> Log có cấu trúc có thể được tự động thu thập và đưa vào các hệ thống phân tích. chúng ta có thể dễ
dàng
truy vấn: &ldquo;Cho tôi xem tất cả các sự kiện <code>PlayerConnect</code> trong 24 giờ qua&rdquo; hoặc &ldquo;Vẽ biểu đồ số lượng người chơi
trên từng server&rdquo;.</li></ul></li><li><p><strong>Monitoring & Alerting (Giám sát & Cảnh báo):</strong></p><ul><li>Sử dụng các công cụ như <strong>Prometheus</strong> (thu thập số liệu), <strong>Grafana</strong> (vẽ biểu đồ), và <strong>Alertmanager</strong>.</li><li>Thiết lập các <strong>Dashboard</strong> để theo dõi sức khỏe của toàn bộ hệ thống theo thời gian thực:<ul><li>Số lượng người chơi đang online (CCU).</li><li>Số lượng server đang hoạt động.</li><li>CPU/RAM trung bình của các server.</li><li>Thời gian tìm trận trung bình.</li></ul></li><li>Thiết lập các <strong>Cảnh báo (Alerts)</strong> tự động gửi tin nhắn vào Slack/Email cho team khi có sự cố: &ldquo;Cảnh báo: Server
X có CPU đạt 95% trong 5 phút!&rdquo; hoặc &ldquo;Số lượng server bị crash tăng đột biến!&rdquo;.</li></ul></li><li><p><strong>Live Ops:</strong></p><ul><li>Đây là tư duy vận hành game như một dịch vụ. Team của chúng ta có thể:<ul><li>Theo dõi các chỉ số để hiểu hành vi người chơi.</li><li>Phát hiện và xử lý sự cố nhanh chóng nhờ hệ thống giám sát.</li><li>Bật/tắt các sự kiện trong game, thay đổi các thông số (ví dụ: sát thương của một khẩu súng) mà không cần
deploy bản build mới, thông qua một hệ thống quản lý từ xa.</li></ul></li></ul></li></ul><p>Chắc chắn rồi! Để biến tài liệu này thành một cẩm nang &ldquo;từ A đến Á&rdquo; thực thụ, việc bổ sung các &ldquo;Tip & Trick&rdquo; chuyên sâu,
được đúc kết từ kinh nghiệm thực chiến của các nhà phát triển đi trước, là vô cùng cần thiết.</p><p>Dưới đây là một danh sách các mẹo và thủ thuật quan trọng, được sắp xếp theo từng giai đoạn, mà chúng ta nên thêm vào
tài
liệu của mình.</p><hr><h3 id=các-tip--trick-nâng-cao-cho-team-chuyên-nghiệp><strong>Các Tip & Trick Nâng cao cho Team Chuyên nghiệp</strong><a hidden class=anchor aria-hidden=true href=#các-tip--trick-nâng-cao-cho-team-chuyên-nghiệp>#</a></h3><p>Những kỹ thuật này là sự khác biệt giữa một game multiplayer &ldquo;chạy được&rdquo; và một game multiplayer &ldquo;chạy tốt&rdquo; - ổn định,
dễ bảo trì, và có khả năng mở rộng.</p><h4 id=i-mẹo-về-kiến-trúc--thiết-kế-giai-đoạn-1--2><strong>I. Mẹo về Kiến trúc & Thiết kế (Giai đoạn 1 & 2)</strong><a hidden class=anchor aria-hidden=true href=#i-mẹo-về-kiến-trúc--thiết-kế-giai-đoạn-1--2>#</a></h4><h5 id=1><strong>1. &ldquo;Gầy&rdquo; Character, &ldquo;Béo&rdquo; Component (Lean Character, Fat Components)</strong><a hidden class=anchor aria-hidden=true href=#1>#</a></h5><ul><li><strong>Vấn đề:</strong> Rất nhiều người mới bắt đầu có xu hướng nhồi nhét tất cả logic vào lớp <code>ACharacter</code>: logic túi đồ, hệ
thống kỹ năng, quản lý máu, năng lượng&mldr; Điều này tạo ra một &ldquo;God Class&rdquo; khổng lồ, khó đọc, khó bảo trì và không thể
tái sử dụng.</li><li><strong>Giải pháp:</strong> Áp dụng triệt để kiến trúc Component.<ul><li>Tạo các <code>UActorComponent</code> riêng biệt cho từng hệ thống: <code>UInventoryComponent</code>, <code>UHealthComponent</code>,
<code>UAbilityComponent</code>&mldr;</li><li>Trong <code>ACharacter</code>, chỉ cần thêm các component này vào. <code>ACharacter</code> chỉ nên chịu trách nhiệm về những gì cốt lõi
của một nhân vật: di chuyển và hoạt hình.</li></ul></li><li><strong>Tại sao lại là &ldquo;Trick&rdquo; hay?</strong><ul><li><strong>Tính Module:</strong> chúng ta có thể dễ dàng thêm hoặc bớt <code>UInventoryComponent</code> cho bất kỳ Actor nào (ví dụ: một cái
rương).</li><li><strong>Dễ Test:</strong> chúng ta có thể kiểm thử <code>UHealthComponent</code> một cách độc lập mà không cần tạo ra cả một <code>ACharacter</code>
hoàn
chỉnh.</li><li><strong>Làm việc nhóm:</strong> Team A làm <code>InventoryComponent</code>, team B làm <code>AbilityComponent</code> mà không sợ đụng code của nhau.</li></ul></li></ul><h5 id=2-sử-dụng-interfaces-cho-tương-tác-interfaces-for-interaction><strong>2. Sử dụng Interfaces cho Tương tác (Interfaces for Interaction)</strong><a hidden class=anchor aria-hidden=true href=#2-sử-dụng-interfaces-cho-tương-tác-interfaces-for-interaction>#</a></h5><ul><li><strong>Vấn đề:</strong> Làm thế nào để nhân vật có thể tương tác với nhiều loại vật thể khác nhau (cửa, item, NPC) mà không cần
phải kiểm tra kiểu (<code>cast</code>) liên tục?</li><li><strong>Giải pháp:</strong> Tạo một C++ Interface, ví dụ <code>UInteractableInterface</code>.<ul><li>Interface này định nghĩa các hàm như <code>OnInteract(AController* Interactor)</code> và <code>GetInteractionText()</code>.</li><li>Bất kỳ Actor nào (cửa, item&mldr;) muốn có thể tương tác được chỉ cần implement Interface này.</li><li>Khi nhân vật nhìn vào một vật thể, họ chỉ cần kiểm tra: <code>if (LookAtActor->Implements&lt;UInteractableInterface>())</code>,
sau đó gọi hàm <code>IInteractableInterface::Execute_OnInteract(LookAtActor, GetController());</code> mà không cần quan tâm
Actor đó là loại gì.</li></ul></li><li><strong>Tại sao lại là &ldquo;Trick&rdquo; hay?</strong> Nó giúp <strong>tách biệt hoàn toàn (decoupling)</strong> logic tương tác khỏi các lớp cụ thể, giúp
code của chúng ta sạch sẽ, linh hoạt và cực kỳ dễ mở rộng.</li></ul><h5 id=3-data-driven-design-với-data-assets-và-curve-tables><strong>3. Data-Driven Design với Data Assets và Curve Tables</strong><a hidden class=anchor aria-hidden=true href=#3-data-driven-design-với-data-assets-và-curve-tables>#</a></h5><ul><li><strong>Vấn đề:</strong> Các thông số game (sát thương súng, máu của quái vật, lượng kinh nghiệm cần để lên cấp) bị hard-code trong
C++ hoặc trong từng Blueprint riêng lẻ, khiến việc cân bằng game trở thành một cơn ác mộng.</li><li><strong>Giải pháp:</strong><ul><li><strong><code>UDataAsset</code>:</strong> Tạo một lớp C++ kế thừa từ <code>UDataAsset</code>, ví dụ <code>UWeaponDataAsset</code>. Lớp này chứa tất cả các thuộc
tính của một vũ khí (sát thương, tốc độ bắn, số đạn&mldr;). Sau đó, trong Editor, các designer có thể tạo ra vô số
asset <code>DA_AK47</code>, <code>DA_Pistol</code>&mldr; từ lớp này. <code>ABaseWeapon</code> của chúng ta chỉ cần một con trỏ <code>UPROPERTY</code> đến
<code>UWeaponDataAsset</code> là có thể lấy toàn bộ thông tin.</li><li><strong><code>UCurveTable</code>:</strong> Sử dụng Curve Table để định nghĩa sự phát triển của các chỉ số theo cấp độ. Ví dụ, tạo một
Curve Table cho &ldquo;HealthPerLevel&rdquo;. Cấp 1 có 100 máu, cấp 2 có 110 máu&mldr; Code C++ chỉ cần đọc giá trị từ bảng này
dựa trên cấp độ hiện tại.</li></ul></li><li><strong>Tại sao lại là &ldquo;Trick&rdquo; hay?</strong> Nó chuyển quyền cân bằng game từ lập trình viên sang cho game designer. Họ có thể tinh
chỉnh hàng trăm vật phẩm mà không cần một dòng code nào, tăng tốc độ phát triển và thử nghiệm lên gấp nhiều lần.</li></ul><h4 id=ii-mẹo-về-workflow--debugging-giai-đoạn-2--3><strong>II. Mẹo về Workflow & Debugging (Giai đoạn 2 & 3)</strong><a hidden class=anchor aria-hidden=true href=#ii-mẹo-về-workflow--debugging-giai-đoạn-2--3>#</a></h4><h5 id=1-bậc-thầy-debug-mạng-network-debugging-mastery><strong>1. Bậc thầy Debug Mạng (Network Debugging Mastery)</strong><a hidden class=anchor aria-hidden=true href=#1-bậc-thầy-debug-mạng-network-debugging-mastery>#</a></h5><ul><li>Việc debug mạng không chỉ là <code>print string</code>. Hãy sử dụng các công cụ chuyên dụng:<ul><li><strong>Các lệnh Console cốt lõi:</strong><ul><li><code>showdebug abilitysystem</code>: Hiển thị thông tin debug của GAS ngay trên màn hình.</li><li><code>showdebug animation</code>: Hiển thị trạng thái của Animation Blueprint.</li><li><code>Net PktLag=[ms], Net PktLoss=[%], Net PktOrder=[0|1]</code>: Các lệnh &ldquo;thần thánh&rdquo; để giả lập môi trường mạng xấu
ngay trong Editor.</li></ul></li><li><strong>Network Profiler:</strong> Mở <code>Unreal Insights</code> (<code>Shift+Alt+I</code>) và chạy game. Tab &ldquo;Networking&rdquo; sẽ cho chúng ta thấy
chính
xác từng packet được gửi đi, chứa thông tin gì, thuộc tính nào được replicate, RPC nào được gọi, và chúng tốn bao
nhiêu băng thông. Đây là công cụ tối thượng để tìm ra nguyên nhân gây lag.</li></ul></li></ul><h5 id=2-tận-dụng-gameplay-debugger><strong>2. Tận dụng Gameplay Debugger</strong><a hidden class=anchor aria-hidden=true href=#2-tận-dụng-gameplay-debugger>#</a></h5><ul><li><strong>Vấn đề:</strong> Làm sao để xem trạng thái của một Actor (đặc biệt là AI) một cách nhanh chóng mà không cần đặt breakpoint?</li><li><strong>Giải pháp:</strong> Bật Gameplay Debugger (<code>Project Settings > Gameplay Debugger > Bật </code>). Trong game, nhấn phím
<code>Apostrophe (')</code>. Một giao diện sẽ hiện ra, cung cấp vô số thông tin về Actor chúng ta đang nhìn vào: trạng thái
Behavior
Tree của AI, các Gameplay Tag đang active, thông tin của Ability System&mldr;</li><li><strong>Tại sao lại là &ldquo;Trick&rdquo; hay?</strong> Nó cho phép chúng ta debug &ldquo;sống&rdquo; (live) mà không cần dừng game, cực kỳ hữu ích khi
debug
các hệ thống phức tạp như AI và GAS.</li></ul><h5 id=3-hot-reload-và-live-coding><strong>3. Hot Reload và Live Coding</strong><a hidden class=anchor aria-hidden=true href=#3-hot-reload-và-live-coding>#</a></h5><ul><li>Đừng tắt Editor mỗi khi chúng ta thay đổi một dòng code C++.<ul><li><strong>Hot Reload (Cũ):</strong> Nhấn <code>Ctrl+Alt+F11</code> trong Editor. Nó sẽ biên dịch lại code và &ldquo;vá&rdquo; vào phiên Editor đang
chạy.</li><li><strong>Live Coding (Mới & Tốt hơn):</strong> Nhấn <code>Ctrl+Alt+F11</code>. Live Coding là một hệ thống mới hơn, ổn định và nhanh hơn
Hot Reload. Hãy đảm bảo nó được bật trong <code>Editor Preferences > Live Coding</code>.</li></ul></li><li><strong>Tại sao lại là &ldquo;Trick&rdquo; hay?</strong> Nó giảm thời gian chờ đợi biên dịch từ vài phút xuống còn vài giây, giúp chúng ta duy
trì
dòng chảy công việc và tăng năng suất lập trình C++ lên đáng kể.</li></ul><h4 id=iii-mẹo-về-tối-ưu-hóa-mạng-giai-đoạn-3--4><strong>III. Mẹo về Tối ưu hóa Mạng (Giai đoạn 3 & 4)</strong><a hidden class=anchor aria-hidden=true href=#iii-mẹo-về-tối-ưu-hóa-mạng-giai-đoạn-3--4>#</a></h4><h5 id=1-1><strong>1. <code>AActor::NetDormancy</code> - &ldquo;Ru ngủ&rdquo; các Actor</strong><a hidden class=anchor aria-hidden=true href=#1-1>#</a></h5><ul><li><strong>Vấn đề:</strong> Có những Actor ít khi thay đổi (ví dụ: một item nằm trên đất). Việc server liên tục kiểm tra và gửi cập
nhật (dù không có gì thay đổi) cho chúng là một sự lãng phí.</li><li><strong>Giải pháp:</strong> Sử dụng <code>NetDormancy</code>. chúng ta có thể đặt trạng thái của một Actor thành &ldquo;ngủ đông&rdquo;. Khi ở trạng thái
này,
server sẽ hoàn toàn không gửi bất kỳ cập nhật nào về nó nữa cho đến khi có một sự kiện &ldquo;đánh thức&rdquo; nó dậy (ví dụ: một
người chơi đi lại gần).</li><li><strong>Tại sao lại là &ldquo;Trick&rdquo; hay?</strong> Trong một map có hàng ngàn vật thể, việc &ldquo;ru ngủ&rdquo; 90% trong số chúng có thể giảm tải
băng thông của server một cách đáng kinh ngạc.</li></ul><h5 id=2-nén-dữ-liệu-trong-rpcs-rpc-data-quantization><strong>2. Nén dữ liệu trong RPCs (RPC Data Quantization)</strong><a hidden class=anchor aria-hidden=true href=#2-nén-dữ-liệu-trong-rpcs-rpc-data-quantization>#</a></h5><ul><li><strong>Vấn đề:</strong> Gửi các RPC với nhiều tham số <code>FVector</code> hoặc <code>FRotator</code> (mỗi <code>float</code> là 4 byte) có thể rất tốn băng thông.</li><li><strong>Giải pháp:</strong> Nén dữ liệu (Quantization). Thay vì gửi một giá trị <code>float</code> đầy đủ, hãy gửi một phiên bản nén của nó.<ul><li><strong>Vị trí:</strong> chúng ta có thực sự cần độ chính xác đến 6 chữ số thập phân? Có thể chúng ta chỉ cần gửi 3 số nguyên
<code>int16</code> và
tính toán lại ở phía nhận.</li><li><strong>Hướng (Rotation):</strong> Một <code>FRotator</code> tốn 12 byte. Nhưng chúng ta có thể nén nó xuống chỉ còn 2-4 byte bằng cách
chỉ gửi
1 hoặc 2 thành phần và tính toán lại phần còn lại, hoặc sử dụng các kỹ thuật nén Quaternion.</li></ul></li><li><strong>Tại sao lại là &ldquo;Trick&rdquo; hay?</strong> Đây là một kỹ thuật tối ưu hóa nâng cao, giúp giảm kích thước của các RPC quan trọng (
như bắn súng), cho phép server xử lý nhiều hành động hơn mỗi giây.</li></ul><h5 id=3><strong>3. <code>FNetSerialize</code> và <code>Fast TArray Replication</code></strong><a hidden class=anchor aria-hidden=true href=#3>#</a></h5><ul><li><strong>Vấn đề:</strong> Làm sao để replicate một <code>TArray</code> chứa các <code>UObject*</code> hoặc các <code>struct</code> phức tạp một cách hiệu quả?</li><li><strong>Giải pháp:</strong><ul><li><strong><code>Fast TArray Replication</code>:</strong> Đối với <code>TArray</code> chứa các <code>struct</code>, hãy sử dụng
<code>TArray&lt;FMyStruct, TFastArrayAllocator&lt;FMyStruct>></code>. Bằng cách implement <code>FNetDeltaSerialize</code> cho <code>struct</code> của
chúng ta, hệ thống replication sẽ chỉ gửi những phần tử đã thay đổi trong mảng, thay vì gửi lại toàn bộ mảng mỗi
khi có
thay đổi.</li><li><strong><code>FNetSerialize</code>:</strong> Đối với các <code>struct</code> phức tạp, hãy implement hàm <code>NetSerialize</code> cho chúng. Hàm này cho chúng
ta
toàn quyền kiểm soát việc đọc/ghi dữ liệu vào luồng packet, cho phép chúng ta áp dụng các kỹ thuật nén tùy chỉnh.</li></ul></li><li><strong>Tại sao lại là &ldquo;Trick&rdquo; hay?</strong> Đây là cấp độ kiểm soát cao nhất đối với việc tuần tự hóa dữ liệu mạng, cần thiết cho
các hệ thống như túi đồ hoặc danh sách hiệu ứng trạng thái.</li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://oaiba.github.io/dev/vi/>Nhật ký phát triển của Bob Phạm</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Sao chép";function s(){t.innerHTML="Đã sao chép!",setTimeout(()=>{t.innerHTML="Sao chép"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>