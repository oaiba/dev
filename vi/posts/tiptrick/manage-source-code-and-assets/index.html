<!doctype html><html lang=vi dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Series: Phát triển và Vận hành Unreal Engine Multiplayer C++: Quản lý source code và assets | Nhật ký phát triển của Bob Phạm</title><meta name=keywords content="hướng dẫn,markdown,hugo"><meta name=description content="Cung cấp một lộ trình đào tạo toàn diện, có hệ thống cho các lập trình viên C++ về việc thiết kế, xây dựng, triển khai và vận hành các game multiplayer sử dụng kiến trúc dedicated server trên Unreal Engine"><meta name=author content="Bob"><link rel=canonical href=https://oaiba.github.io/dev/vi/posts/tiptrick/manage-source-code-and-assets/><link crossorigin=anonymous href=/dev/assets/css/stylesheet.2c98de55bd3fc6df1bb365f4fd08052c7377847525222e274b197419de218394.css integrity="sha256-LJjeVb0/xt8bs2X0/QgFLHN3hHUlIi4nSxl0Gd4hg5Q=" rel="preload stylesheet" as=style><link rel=icon href=https://oaiba.github.io/dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://oaiba.github.io/dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://oaiba.github.io/dev/favicon-32x32.png><link rel=apple-touch-icon href=https://oaiba.github.io/dev/apple-touch-icon.png><link rel=mask-icon href=https://oaiba.github.io/dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=vi href=https://oaiba.github.io/dev/vi/posts/tiptrick/manage-source-code-and-assets/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://oaiba.github.io/dev/vi/posts/tiptrick/manage-source-code-and-assets/"><meta property="og:site_name" content="Nhật ký phát triển của Bob Phạm"><meta property="og:title" content="Series: Phát triển và Vận hành Unreal Engine Multiplayer C++: Quản lý source code và assets"><meta property="og:description" content="Cung cấp một lộ trình đào tạo toàn diện, có hệ thống cho các lập trình viên C++ về việc thiết kế, xây dựng, triển khai và vận hành các game multiplayer sử dụng kiến trúc dedicated server trên Unreal Engine"><meta property="og:locale" content="vi"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-14T10:14:42+07:00"><meta property="article:modified_time" content="2025-11-14T10:14:42+07:00"><meta property="article:tag" content="Hướng Dẫn"><meta property="article:tag" content="Markdown"><meta property="article:tag" content="Hugo"><meta name=twitter:card content="summary"><meta name=twitter:title content="Series: Phát triển và Vận hành Unreal Engine Multiplayer C++: Quản lý source code và assets"><meta name=twitter:description content="Cung cấp một lộ trình đào tạo toàn diện, có hệ thống cho các lập trình viên C++ về việc thiết kế, xây dựng, triển khai và vận hành các game multiplayer sử dụng kiến trúc dedicated server trên Unreal Engine"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://oaiba.github.io/dev/vi/posts/"},{"@type":"ListItem","position":2,"name":"Series: Phát triển và Vận hành Unreal Engine Multiplayer C++: Quản lý source code và assets","item":"https://oaiba.github.io/dev/vi/posts/tiptrick/manage-source-code-and-assets/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Series: Phát triển và Vận hành Unreal Engine Multiplayer C++: Quản lý source code và assets","name":"Series: Phát triển và Vận hành Unreal Engine Multiplayer C\u002b\u002b: Quản lý source code và assets","description":"Cung cấp một lộ trình đào tạo toàn diện, có hệ thống cho các lập trình viên C++ về việc thiết kế, xây dựng, triển khai và vận hành các game multiplayer sử dụng kiến trúc dedicated server trên Unreal Engine","keywords":["hướng dẫn","markdown","hugo"],"articleBody":" Dự án C++: Xây dựng một “Siêu đô thị” có Quy hoạch và Luật lệ Rõ ràng Việc lựa chọn C++ và cấu trúc dự án không chỉ là xây dựng một “bộ khung xương”; nó là việc thiết lập bản quy hoạch tổng thể và bộ luật xây dựng cho toàn bộ “siêu đô thị” game của chúng ta. Một bản quy hoạch tốt kết hợp với luật lệ nghiêm ngặt sẽ đảm bảo thành phố có thể phát triển bền vững, dễ dàng nâng cấp, và không bao giờ chìm trong hỗn loạn.\n“Allar’s UE5 Style Guide” chính là bộ luật xây dựng đó.\nHai Triết lý Quy hoạch “Siêu đô thị” Unreal Khi bắt đầu một dự án, chúng ta đứng trước một ngã rẽ quan trọng về cách tổ chức hàng ngàn, thậm chí hàng triệu file assets và code. Có hai trường phái tư duy chính, hai “bản quy hoạch tổng thể” khác biệt hoàn toàn.\nPhương pháp 1: Quy hoạch theo Chức năng (Functional-First Approach) Hãy tưởng tượng một thành phố được quy hoạch một cách tuyệt đối theo ngành nghề và chức năng. Tất cả các ngân hàng nằm ở “Quận Tài chính”, tất cả các nhà máy nằm ở “Khu Công nghiệp”, tất cả các trường đại học nằm ở “Làng Đại học”. Nếu chúng ta muốn tìm một thứ gì đó, chúng ta chỉ cần biết “nó là loại gì” để đi đến đúng khu vực.\nTrong Unreal, triết lý này có nghĩa là tất cả các asset cùng loại sẽ được nhóm lại với nhau, bất kể chúng thuộc về tính năng hay nhân vật nào.\nCấu trúc thư mục Content sẽ được tổ chức theo loại asset:\nContent/ ├── Blueprints/ │ ├── Pawns/ │ │ ├── BP_PlayerCharacter.uasset │ │ └── BP_Enemy_Grunt.uasset │ ├── Actors/ │ │ ├── BP_Door.uasset │ │ └── BP_HealthPack.uasset │ └── Weapons/ │ └── BP_AK47.uasset │ ├── Maps/ │ ├── MainMenu.umap │ └── Jungle.umap │ ├── Materials/ │ ├── M_PlayerCharacter.uasset │ ├── M_Enemy_Grunt.uasset │ └── M_AK47.uasset │ ├── Meshes/ │ ├── StaticMeshes/ │ │ └── SM_HealthPack.uasset │ └── SkeletalMeshes/ │ ├── SK_PlayerCharacter.uasset │ ├── SK_Enemy_Grunt.uasset │ └── SK_AK47.uasset │ ├── Textures/ │ ├── T_PlayerCharacter_D.uasset │ ├── T_Enemy_Grunt_D.uasset │ └── T_AK47_D.uasset │ └── ... (Sounds, Particles, etc.) Ưu điểm (Pros) Dễ tìm theo loại: Nếu chúng ta cần tìm bất kỳ Material nào trong dự án, chúng ta biết chính xác phải vào thư mục Content/Materials. Điều này rất hữu ích cho các Technical Artist khi họ muốn kiểm tra và tối ưu hóa tất cả các material trong game. Thúc đẩy Tái sử dụng: Khi tất cả các texture được đặt chung một nơi, artist sẽ có xu hướng tìm kiếm một texture kim loại đã có sẵn trước khi tạo ra một cái mới, giúp giảm sự trùng lặp và tiết kiệm dung lượng. Rõ ràng cho Lập trình viên (Ban đầu): Cấu trúc này ban đầu có vẻ rất logic và sạch sẽ, đặc biệt đối với những người có tư duy lập trình, vì nó phân tách rõ ràng các “lớp” khác nhau của một thực thể (model, material, logic). Nhược điểm (Cons) Cơn ác mộng cho việc Di chuyển \u0026 Xóa bỏ: Đây là nhược điểm lớn nhất. Để xóa hoàn toàn nhân vật “Enemy Grunt”, chúng ta phải đi lùng sục trong ít nhất 5 thư mục khác nhau (Blueprints, Materials, Meshes, Textures, Animations) để xóa từng file một. Nguy cơ để lại các file “mồ côi” (orphan files) làm rác dự án là cực kỳ cao. Workflow rời rạc cho Artist \u0026 Designer: Để lắp ráp hoàn chỉnh một nhân vật, một artist phải liên tục nhảy giữa nhiều thư mục khác nhau để gán mesh, material, texture… Điều này làm gián đoạn dòng chảy công việc và tốn thời gian. Không thân thiện với DLC và Đóng gói (Chunking): Khi chúng ta muốn đóng gói một bản DLC chỉ chứa map “Desert” và các asset liên quan, làm thế nào chúng ta có thể chỉ định cho Unreal Build Tool biết file nào thuộc về map đó? Gần như là không thể một cách tự động. Chúng ta sẽ phải tạo danh sách thủ công, một công việc dễ sai sót và không có khả năng mở rộng. Phương pháp 2: Quy hoạch theo Nội dung (Content-First Approach) Hãy tưởng tượng một thành phố được xây dựng như một tập hợp các “khu đô thị” hoặc “công viên chủ đề” hoàn toàn tự chủ. Mọi thứ chúng ta cần cho “Công viên Kỷ Jura” (khủng long, cây cối, xe jeep, hàng rào điện) đều nằm gọn bên trong bức tường của công viên đó. Nếu chúng ta muốn di chuyển cả công viên sang một địa điểm mới, chúng ta chỉ cần bứng cả khu đất đó đi.\nTrong Unreal, triết lý này có nghĩa là tất cả các asset liên quan đến một tính năng hoặc một thực thể cụ thể sẽ được nhóm lại với nhau trong một thư mục duy nhất.\nCấu trúc thư mục Content sẽ được tổ chức theo tính năng/thực thể:\nContent/ ├── Characters/ │ ├── Player/ │ │ ├── BP_PlayerCharacter.uasset │ │ ├── Meshes/ │ │ │ └── SK_PlayerCharacter.uasset │ │ ├── Materials/ │ │ │ └── M_PlayerCharacter.uasset │ │ └── Textures/ │ │ └── T_PlayerCharacter_D.uasset │ └── Enemies/ │ └── Grunt/ │ ├── BP_Enemy_Grunt.uasset │ ├── Meshes/ │ │ └── SK_Enemy_Grunt.uasset │ └── ... │ ├── Weapons/ │ └── Rifles/ │ └── AK47/ │ ├── BP_AK47.uasset │ ├── Meshes/ │ │ └── SK_AK47.uasset │ └── ... │ ├── Props/ │ └── HealthPack/ │ ├── BP_HealthPack.uasset │ ├── Meshes/ │ │ └── SM_HealthPack.uasset │ └── ... │ └── Maps/ ├── MainMenu/ │ └── Map_MainMenu.umap └── Jungle/ ├── Map_Jungle.umap ├── Meshes/ # Các mesh chỉ dùng trong map Jungle └── Materials/ # Các material chỉ dùng trong map Jungle Ưu điểm (Pros) Tính tự chứa và Di động (Self-Contained \u0026 Portable): Đây là ưu điểm tuyệt đối. Chúng ta có thể di chuyển toàn bộ nhân vật Player sang một dự án khác chỉ bằng cách sao chép thư mục Content/Characters/Player. Mọi thứ sẽ hoạt động vì tất cả các tham chiếu (references) đều nằm trong đó. Thiên đường cho DLC và Đóng gói (Chunking): Đây là cách duy nhất để quản lý các gói nội dung một cách hiệu quả. Chúng ta có thể dễ dàng nói với Unreal: “Hãy đóng gói toàn bộ thư mục Content/Maps/Jungle thành Chunk 10.” Khi người chơi muốn tải map này, game chỉ cần tải về file .pak của Chunk 10. Workflow liền mạch cho Artist \u0026 Designer: Khi làm việc trên nhân vật Player, mọi file họ cần đều nằm ngay trong một thư mục. Họ có thể dễ dàng duyệt qua, chỉnh sửa và liên kết các asset với nhau mà không cần rời khỏi “khu vực làm việc” của mình. Nhược điểm (Cons) Vấn đề nan giải về Asset dùng chung (The Shared Asset Dilemma): Đây là điểm yếu chí mạng. Một Material Master, một texture kim loại trầy xước, một bộ animation di chuyển cơ bản… được dùng cho TẤT CẢ các nhân vật sẽ được đặt ở đâu? Điều này thường dẫn đến sự ra đời của một thư mục Content/Shared, và nếu không được quản lý chặt chẽ, nó có thể trở thành một “bãi rác” chứa mọi thứ, làm phá vỡ triết lý ban đầu. Nguy cơ Trùng lặp cao: Vì sự tiện lợi, một artist có thể sẽ sao chép một texture từ thư mục Shared vào thư mục nhân vật của họ thay vì tạo một Material Instance. Điều này dẫn đến việc asset bị trùng lặp, làm tăng đáng kể kích thước của game. Có thể gây xung đột cho Lập trình viên: Nếu các lớp C++ cụ thể cho từng tính năng cũng được đặt trong các thư mục nội dung này, nó có thể làm xáo trộn cấu trúc Source và gây khó khăn cho việc quản lý code. I. Triết lý cốt lõi: Quy hoạch Thư mục là Luật! Trước khi đi vào chi tiết, nguyên tắc tối cao mà Allar’s Style Guide đặt ra là: Sự nhất quán và có tổ chức trong cấu trúc thư mục và quy tắc đặt tên là không thể thương lượng.\nTại sao? Khả năng dự đoán: Bất kỳ thành viên nào trong team, dù mới hay cũ, đều có thể tìm thấy một asset họ cần một cách nhanh chóng mà không cần phải hỏi ai. Họ biết rằng một Material sẽ nằm trong thư mục Materials và có tiền tố M_. Hiệu quả tìm kiếm: Content Browser của Unreal trở thành một công cụ cực kỳ mạnh mẽ khi chúng ta có thể lọc chính xác theo tiền tố (BP_, T_, M_…). Tránh sự hỗn loạn: Nó ngăn chặn việc các asset tạm thời, thử nghiệm, hoặc trùng lặp làm ô nhiễm dự án chính. II. Cấu trúc Lai Tối ưu - Phiên bản “Allar’s Certified” Chúng ta sẽ áp dụng mô hình “Hybrid City” nhưng với các quy tắc và tên thư mục cụ thể từ Allar’s Style Guide.\nA. Hạ tầng Ngầm (Code - Source/) - Nền móng Kỹ thuật Phần này vẫn tuân thủ nguyên tắc Quy hoạch theo Chức năng. Đây là nền móng C++ vững chắc, ít khi bị thay đổi bởi artist hay designer.\nSource/MyGameCore: Các hệ thống toàn cục, interfaces, các lớp helper. Source/MyGameFramework: Các lớp C++ cơ sở cho gameplay (CharacterBase, WeaponBase, GameStateBase…). Đây là cầu nối sang Content/Core. Source/GameFeatures/: Mỗi hệ thống gameplay lớn nên là một module riêng. Source/GameFeatures/Inventory Source/GameFeatures/AbilitySystem Source/GameFeatures/AI B. Bề nổi (Assets - Content/) - Các Khu phố và Tòa nhà Đây là nơi chúng ta áp dụng triệt để các quy tắc của Allar, kết hợp giữa Quy hoạch theo Chức năng và Quy hoạch theo Nội dung.\nContent/Core/: “Trung tâm Hành chính \u0026 Hạ tầng Chung”\nĐây là nơi chứa các asset nền tảng, được sử dụng trên toàn bộ dự án. Nó tương ứng trực tiếp với Source/MyGameFramework. Core/Blueprints/: Chứa các Blueprint cơ sở kế thừa trực tiếp từ C++ (BP_CharacterBase, BP_WeaponBase). Các designer sẽ tạo các Blueprint con từ những lớp này. Core/Data/: Chứa các Data Table và Data Asset định nghĩa các quy tắc game cơ bản. Core/Materials/: Chứa các Master Material, Material Function mà tất cả các asset khác sẽ tạo instance từ đó. Core/Input/: Chứa các Input Action và Input Mapping Context của hệ thống Enhanced Input. Content/Shared/: Sẽ được đặt ở cấp cao nhất của Content, và bản thân nó cũng cần có một cấu trúc bên trong rõ ràng, thường là theo chức năng:\nQuy tắc đóng gói: Khi thiết lập các quy tắc đóng gói (Packaging Rules) và Primary Asset Labels, toàn bộ thư mục Content/Shared sẽ được gán cho Chunk 0. Điều này đảm bảo rằng khi người chơi tải game lần đầu, họ sẽ có tất cả các asset nền tảng cần thiết để mọi gói nội dung khác (DLC, map mới) có thể hoạt động chính xác khi được tải về sau này.\nĐể giảm thiểu rủi ro, team phải tuân thủ các quy tắc nghiêm ngặt:\nQuy tắc #1: Phải có “Strict Gatekeeping”: Không ai được phép tự ý thêm asset vào Content/Shared. Phải có một hoặc vài người (thường là Art Director, Technical Art Lead, hoặc Lead Engineer) chịu trách nhiệm phê duyệt mọi thứ được đưa vào đây. Quy tắc #2: “The Rule of Three”: Một asset chỉ nên được xem xét để đưa vào Shared khi nó được yêu cầu sử dụng ở ba hoặc nhiều nơi khác nhau và riêng biệt. Nếu nó chỉ được dùng cho hai nhân vật, có thể tốt hơn là giữ nó ở một trong hai thư mục nhân vật đó và tham chiếu chéo. Quy tắc #3: Shared là “Chỉ đọc” với Hầu hết mọi người: Đối với đa số thành viên trong team, các asset trong Shared nên được coi là “read-only”. Họ chỉ nên tạo instance hoặc tham chiếu đến chúng. Việc chỉnh sửa một asset trong Shared phải là một quy trình có kiểm soát, có thể yêu cầu một buổi họp review ngắn. Quy tắc #4: Regular Audits: Cứ mỗi một hoặc hai tháng, Senior nên rà soát lại thư mục Shared để tìm và loại bỏ các asset không còn được sử dụng hoặc những asset được thêm vào không đúng quy cách. Content/Characters/, Content/Weapons/, Content/Environments/, Content/Props/: “Các Khu Dân cư và Công trình Chuyên dụng”\nĐây là phần Quy hoạch theo Nội dung. Mỗi thư mục này chứa tất cả mọi thứ liên quan đến một thực thể cụ thể. Ví dụ với Content/Characters/CyberNinja/: BP_CyberNinja (kế thừa từ Core/Blueprints/BP_CharacterBase) Meshes/SK_CyberNinja Textures/T_CyberNinja_D, T_CyberNinja_N Materials/MI_CyberNinja (một instance của Core/Materials/M_Character_Master) Animations/A_CyberNinja_Attack Lợi ích cho Pak/Chunk: Cấu trúc tự chứa này làm cho việc đóng gói trở nên cực kỳ đơn giản. chúng ta có thể tạo một chunk ID cho toàn bộ thư mục Characters/CyberNinja. Nếu nhân vật này là một DLC, người chơi có thể tải về chỉ gói đó mà không ảnh hưởng đến phần còn lại của game. Tương tự với Maps/Jungle/. Content/Developers/: “Khu vực Thử nghiệm \u0026 Sandbox Cá nhân”\nĐây là một trong những quy tắc thiên tài nhất của Allar. Mỗi thành viên trong team sẽ có một thư mục con riêng trong này (ví dụ: Developers/JohnDoe/). Mục đích: Đây là nơi an toàn để mỗi người thử nghiệm, tạo các asset tạm thời, “chọc ngoáy” mà không làm ô nhiễm dự án chính. Quy tắc tối cao: Thư mục Content/Developers/ phải được thêm vào file .gitignore (hoặc các file ignore của Perforce). Nội dung trong này không bao giờ được commit lên version control. C. Sơ đồ Quy hoạch Tổng thể Đây là hình dung về cấu trúc lai cuối cùng của chúng ta:\n├── Source/ │ ├── MyGameCore/ │ └── GameFeatures/ │ └── Inventory/ │ └── Content/ ├── Core/ │ ├── Blueprints/ │ └── Materials/ │ ├── Characters/ │ └── CyberNinja/ │ ├── BP_CyberNinja.uasset │ ├── Meshes/ │ └── Textures/ │ ├── Maps/ │ └── Jungle/ │ ├── Map_Jungle.umap │ ├── Meshes/ │ └── Materials/ │ ├── GameFeatures/ │ └── Inventory/ │ ├── Data/ │ └── UI/ │ ├── Developers/ │ ├── JohnDoe/ (NEVER COMMIT) │ └── JaneSmith/ (NEVER COMMIT) │ └── _External/ # Chứa các asset từ bên ngoài (ví dụ: Megascans) │ ├── _Shared/ III. Ưu điểm Vượt trội của Mô hình Quy hoạch Lai này Tối ưu cho mọi vai trò: Lập trình viên có một cấu trúc code module hóa, sạch sẽ trong Source/. Artist/Designer có một cấu trúc nội dung trực quan, tự chứa trong Content/, cho phép họ làm việc độc lập. Technical Director có thể dễ dàng quản lý và tự động hóa quy trình đóng gói (packaging) dựa trên cấu trúc này. Sẵn sàng cho Tương lai (Future-Proof): DLC \u0026 Cập nhật: Việc thêm một gói nội dung mới (nhân vật, map) chỉ đơn giản là tạo một thư mục mới theo đúng quy chuẩn mà không cần tái cấu trúc lại toàn bộ dự án. Tối ưu hóa Phân phối: Cấu trúc này là nền tảng để chúng ta có thể phân phối game dưới dạng các “chunk” nhỏ. Người chơi có thể tải phần chơi chính trước, và tải các gói ngôn ngữ, các map độ phân giải cao, hoặc các phần chơi khác sau. Vận hành và Hỗ trợ đa nền tảng: Khi một lỗi xảy ra chỉ trên Android liên quan đến nhân vật CyberNinja, chúng ta biết chính xác cần phải kiểm tra các file trong Content/Characters/CyberNinja và các lớp C++ cơ sở mà nó kế thừa. Việc quản lý các phiên bản (develop, staging, production) trở nên dễ dàng hơn vì cấu trúc nhất quán giúp các công cụ CI/CD (như TeamCity) xác định và đóng gói các thay đổi một cách đáng tin cậy. Khả năng Mở rộng, Bảo trì và làm việc với Version Control Đây là lợi ích chiến lược lớn nhất khi chọn C++, quyết định khả năng “sống sót” và phát triển của dự án trong dài hạn.\nKiến trúc linh hoạt: Kết hợp Kế thừa (OOP) và Tập hợp (Composition) C++ cho phép chúng ta tận dụng triệt để các nguyên tắc OOP. Ví dụ, chúng ta có thể tạo một lớp ABaseWeapon định nghĩa các hành vi chung (bắn, nạp đạn). Sau đó, các lớp con ARifle, APistol có thể kế thừa và chuyên biệt hóa các hành vi đó.\nTuy nhiên, một kiến trúc hiện đại và linh hoạt hơn là kết hợp Kế thừa với Composition (Kiến trúc tập hợp các thành phần).\nTriển khai gợi ý của chúng ta: Thay vì một ARifle kế thừa mọi thứ từ ABaseWeapon, chúng ta tạo ra một lớp AWeapon cơ bản. Các chức năng cụ thể như “bắn đạn ghém” (ShotgunFireComponent), “ngắm bắn qua ống ngắm” ( ScopeComponent), hay “bắn tia laser” (LaserBeamComponent) sẽ được xây dựng dưới dạng các Actor Component. Tại sao đây là phương pháp vượt trội? “Cắm và Chạy” (Plug-and-Play): chúng ta có thể tạo ra một khẩu súng hoàn toàn mới trong Blueprint chỉ bằng cách lắp ghép các Component này lại với nhau, giống như lắp ráp các module Lego. Một khẩu súng trường tấn công có thể được tạo từ AWeapon + AutomaticFireComponent + ScopeComponent. Tái sử dụng tối đa: ScopeComponent không chỉ dùng cho súng, nó có thể được gắn vào cả ống nhòm hoặc các công cụ khác. Tránh “Địa ngục Kế thừa”: chúng ta sẽ không bị rơi vào tình huống tạo ra một cây kế thừa phức tạp, đa tầng, khó quản lý chỉ để chia sẻ một vài chức năng nhỏ. Cấu trúc Module và Version Control (Git): Xây dựng một “Thành phố” có quy hoạch Việc chia dự án thành các module (MyGameCore, MyGameInventory, MyGameAI…) giống như việc quy hoạch một thành phố thành các quận chuyên biệt.\nGiảm thiểu xung đột (Merge Conflicts): Khi các team làm việc trong các “quận” (module) riêng của mình, khả năng họ “xây dựng” chồng chéo lên nhau và gây ra xung đột trên Git sẽ giảm đi đáng kể. Đây là yếu tố sống còn để duy trì hiệu suất làm việc của một team lớn. Tăng tốc độ biên dịch: Unreal Build Tool có thể biên dịch các module song song. Một dự án được module hóa tốt sẽ có thời gian biên dịch nhanh hơn. chúng ta cũng có thể thiết lập để chỉ biên dịch lại những module có thay đổi. Sở hữu Code rõ ràng (Code Ownership): Mỗi module có thể có một “chủ sở hữu” hoặc team chịu trách nhiệm chính. Khi có lỗi phát sinh trong hệ thống túi đồ, mọi người đều biết cần phải liên hệ với team Inventory. Điều này tạo ra sự rõ ràng và trách nhiệm trong tổ chức. Tip \u0026 Trick cho Team: Tối ưu hóa quy trình làm việc 1. Hybrid Approach: “C++ xây Siêu xa lộ, Blueprint xây Nhà dân” Đây là triết lý làm việc cốt lõi giúp cân bằng giữa hiệu năng và tốc độ phát triển.\nVai trò của Lập trình viên C++:\nXây dựng các hệ thống nền tảng vững chắc và các “đường cao tốc” truyền dữ liệu hiệu năng cao. Không chỉ “phơi bày” các hàm (UFUNCTION), các biến (UPROPERTY) với các meta, property, họ còn định nghĩa các \" kênh sự kiện\" bằng delegate ( UPROPERTY(BlueprintAssignable)) để Blueprint có thể “lắng nghe” và phản ứng lại các sự kiện từ C++ (ví dụ: OnHealthChanged, OnItemAddedToInventory). Họ tạo ra các “hợp đồng” dữ liệu thông qua UDataAsset và UDataTable. Triển khai gợi ý của chúng ta (Tách biệt Dữ liệu và Logic):\nLập trình viên C++ sẽ tạo ra các lớp cơ sở như UItemData (kế thừa từ UDataAsset). Game Designer, thay vì chỉnh sửa BP_HealthPotion, giờ đây sẽ tạo và chỉnh sửa một asset dữ liệu là DA_HealthPotion. Asset này chứa mọi thông số: tên, icon, số lượng máu hồi phục, hiệu ứng âm thanh khi sử dụng. Lớp AItemActor (trong C++) hoặc BP_ItemActor (trong Blueprint) sẽ chỉ có một biến duy nhất là ItemData (một con trỏ tới UItemData). Toàn bộ hành vi và hiển thị của nó sẽ được điều khiển bởi dữ liệu trong asset đó. Kết quả: Dev và Designer có thể làm việc song song. Designer có thể tạo ra hàng trăm item mà không cần sự can thiệp của dev, và dev có thể tối ưu hóa logic xử lý item mà không sợ làm hỏng dữ liệu của Designer. Xung đột trên version control gần như bằng không. ","wordCount":"3472","inLanguage":"vi","datePublished":"2025-11-14T10:14:42+07:00","dateModified":"2025-11-14T10:14:42+07:00","author":{"@type":"Person","name":"Bob"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://oaiba.github.io/dev/vi/posts/tiptrick/manage-source-code-and-assets/"},"publisher":{"@type":"Organization","name":"Nhật ký phát triển của Bob Phạm","logo":{"@type":"ImageObject","url":"https://oaiba.github.io/dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://oaiba.github.io/dev/vi/ accesskey=h title="Nhật ký phát triển của Bob Phạm (Alt + H)">Nhật ký phát triển của Bob Phạm</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://oaiba.github.io/dev/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://oaiba.github.io/dev/vi/gameroadmap/ title="Lộ trình Game"><span>Lộ trình Game</span></a></li><li><a href=https://oaiba.github.io/dev/vi/about/ title="Giới Thiệu"><span>Giới Thiệu</span></a></li><li><a href=https://oaiba.github.io/dev/vi/resume/ title="Hồ Sơ Năng Lực"><span>Hồ Sơ Năng Lực</span></a></li><li><a href=https://oaiba.github.io/dev/vi/posts/ title="Bài Viết"><span>Bài Viết</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Series: Phát triển và Vận hành Unreal Engine Multiplayer C++: Quản lý source code và assets</h1><div class=post-meta><span title='2025-11-14 10:14:42 +0700 +0700'>tháng 11 14, 2025</span>&nbsp;·&nbsp;17 phút&nbsp;·&nbsp;3472 từ&nbsp;·&nbsp;Bob</div></header><div class=post-content><hr><h3 id=dự-án-c-xây-dựng-một><strong>Dự án C++: Xây dựng một &ldquo;Siêu đô thị&rdquo; có Quy hoạch và Luật lệ Rõ ràng</strong><a hidden class=anchor aria-hidden=true href=#dự-án-c-xây-dựng-một>#</a></h3><p>Việc lựa chọn C++ và cấu trúc dự án không chỉ là xây dựng một &ldquo;bộ khung xương&rdquo;; nó là việc <strong>thiết lập bản quy hoạch
tổng thể và bộ luật xây dựng</strong> cho toàn bộ &ldquo;siêu đô thị&rdquo; game của chúng ta. Một bản quy hoạch tốt kết hợp với luật lệ
nghiêm ngặt sẽ đảm bảo thành phố có thể phát triển bền vững, dễ dàng nâng cấp, và không bao giờ chìm trong hỗn loạn.</p><p>&ldquo;Allar&rsquo;s UE5 Style Guide&rdquo; chính là bộ luật xây dựng đó.</p><hr><h3 id=hai-triết-lý-quy-hoạch><strong>Hai Triết lý Quy hoạch &ldquo;Siêu đô thị&rdquo; Unreal</strong><a hidden class=anchor aria-hidden=true href=#hai-triết-lý-quy-hoạch>#</a></h3><p>Khi bắt đầu một dự án, chúng ta đứng trước một ngã rẽ quan trọng về cách tổ chức hàng ngàn, thậm chí hàng triệu file
assets và code. Có hai trường phái tư duy chính, hai &ldquo;bản quy hoạch tổng thể&rdquo; khác biệt hoàn toàn.</p><hr><h3 id=phương-pháp-1-quy-hoạch-theo-chức-năng-functional-first-approach><strong>Phương pháp 1: Quy hoạch theo Chức năng (Functional-First Approach)</strong><a hidden class=anchor aria-hidden=true href=#phương-pháp-1-quy-hoạch-theo-chức-năng-functional-first-approach>#</a></h3><p>Hãy tưởng tượng một thành phố được quy hoạch một cách tuyệt đối theo ngành nghề và chức năng. Tất cả các ngân hàng nằm
ở &ldquo;Quận Tài chính&rdquo;, tất cả các nhà máy nằm ở &ldquo;Khu Công nghiệp&rdquo;, tất cả các trường đại học nằm ở &ldquo;Làng Đại học&rdquo;. Nếu
chúng ta muốn tìm một thứ gì đó, chúng ta chỉ cần biết &ldquo;nó là loại gì&rdquo; để đi đến đúng khu vực.</p><p>Trong Unreal, triết lý này có nghĩa là <strong>tất cả các asset cùng loại sẽ được nhóm lại với nhau, bất kể chúng thuộc về
tính năng hay nhân vật nào.</strong></p><p>Cấu trúc thư mục <code>Content</code> sẽ được tổ chức theo loại asset:</p><pre tabindex=0><code>Content/
├── Blueprints/
│   ├── Pawns/
│   │   ├── BP_PlayerCharacter.uasset
│   │   └── BP_Enemy_Grunt.uasset
│   ├── Actors/
│   │   ├── BP_Door.uasset
│   │   └── BP_HealthPack.uasset
│   └── Weapons/
│       └── BP_AK47.uasset
│
├── Maps/
│   ├── MainMenu.umap
│   └── Jungle.umap
│
├── Materials/
│   ├── M_PlayerCharacter.uasset
│   ├── M_Enemy_Grunt.uasset
│   └── M_AK47.uasset
│
├── Meshes/
│   ├── StaticMeshes/
│   │   └── SM_HealthPack.uasset
│   └── SkeletalMeshes/
│       ├── SK_PlayerCharacter.uasset
│       ├── SK_Enemy_Grunt.uasset
│       └── SK_AK47.uasset
│
├── Textures/
│   ├── T_PlayerCharacter_D.uasset
│   ├── T_Enemy_Grunt_D.uasset
│   └── T_AK47_D.uasset
│
└── ... (Sounds, Particles, etc.)
</code></pre><h4 id=ưu-điểm-pros><strong>Ưu điểm (Pros)</strong><a hidden class=anchor aria-hidden=true href=#ưu-điểm-pros>#</a></h4><ol><li><strong>Dễ tìm theo loại:</strong> Nếu chúng ta cần tìm <em>bất kỳ</em> Material nào trong dự án, chúng ta biết chính xác phải vào thư
mục <code>Content/Materials</code>. Điều này rất hữu ích cho các Technical Artist khi họ muốn kiểm tra và tối ưu hóa tất cả các
material trong game.</li><li><strong>Thúc đẩy Tái sử dụng:</strong> Khi tất cả các texture được đặt chung một nơi, artist sẽ có xu hướng tìm kiếm một texture
kim loại đã có sẵn trước khi tạo ra một cái mới, giúp giảm sự trùng lặp và tiết kiệm dung lượng.</li><li><strong>Rõ ràng cho Lập trình viên (Ban đầu):</strong> Cấu trúc này ban đầu có vẻ rất logic và sạch sẽ, đặc biệt đối với những
người có tư duy lập trình, vì nó phân tách rõ ràng các &ldquo;lớp&rdquo; khác nhau của một thực thể (model, material, logic).</li></ol><h4 id=nhược-điểm-cons><strong>Nhược điểm (Cons)</strong><a hidden class=anchor aria-hidden=true href=#nhược-điểm-cons>#</a></h4><ol><li><strong>Cơn ác mộng cho việc Di chuyển & Xóa bỏ:</strong> Đây là nhược điểm lớn nhất. Để xóa hoàn toàn nhân vật &ldquo;Enemy Grunt&rdquo;,
chúng ta phải đi lùng sục trong ít nhất 5 thư mục khác nhau (<code>Blueprints</code>, <code>Materials</code>, <code>Meshes</code>, <code>Textures</code>,
<code>Animations</code>) để xóa từng file một. Nguy cơ để lại các file &ldquo;mồ côi&rdquo; (orphan files) làm rác dự án là cực kỳ cao.</li><li><strong>Workflow rời rạc cho Artist & Designer:</strong> Để lắp ráp hoàn chỉnh một nhân vật, một artist phải liên tục nhảy giữa
nhiều thư mục khác nhau để gán mesh, material, texture&mldr; Điều này làm gián đoạn dòng chảy công việc và tốn thời
gian.</li><li><strong>Không thân thiện với DLC và Đóng gói (Chunking):</strong> Khi chúng ta muốn đóng gói một bản DLC chỉ chứa map &ldquo;Desert&rdquo; và
các asset liên quan, làm thế nào chúng ta có thể chỉ định cho Unreal Build Tool biết file nào thuộc về map đó? Gần
như là không thể một cách tự động. Chúng ta sẽ phải tạo danh sách thủ công, một công việc dễ sai sót và không có khả
năng mở rộng.</li></ol><hr><h3 id=phương-pháp-2-quy-hoạch-theo-nội-dung-content-first-approach><strong>Phương pháp 2: Quy hoạch theo Nội dung (Content-First Approach)</strong><a hidden class=anchor aria-hidden=true href=#phương-pháp-2-quy-hoạch-theo-nội-dung-content-first-approach>#</a></h3><p>Hãy tưởng tượng một thành phố được xây dựng như một tập hợp các &ldquo;khu đô thị&rdquo; hoặc &ldquo;công viên chủ đề&rdquo; hoàn toàn tự chủ.
Mọi thứ chúng ta cần cho &ldquo;Công viên Kỷ Jura&rdquo; (khủng long, cây cối, xe jeep, hàng rào điện) đều nằm gọn bên trong bức
tường của công viên đó. Nếu chúng ta muốn di chuyển cả công viên sang một địa điểm mới, chúng ta chỉ cần bứng cả khu đất
đó đi.</p><p>Trong Unreal, triết lý này có nghĩa là <strong>tất cả các asset liên quan đến một tính năng hoặc một thực thể cụ thể sẽ được
nhóm lại với nhau trong một thư mục duy nhất.</strong></p><p>Cấu trúc thư mục <code>Content</code> sẽ được tổ chức theo tính năng/thực thể:</p><pre tabindex=0><code>Content/
├── Characters/
│   ├── Player/
│   │   ├── BP_PlayerCharacter.uasset
│   │   ├── Meshes/
│   │   │   └── SK_PlayerCharacter.uasset
│   │   ├── Materials/
│   │   │   └── M_PlayerCharacter.uasset
│   │   └── Textures/
│   │       └── T_PlayerCharacter_D.uasset
│   └── Enemies/
│       └── Grunt/
│           ├── BP_Enemy_Grunt.uasset
│           ├── Meshes/
│           │   └── SK_Enemy_Grunt.uasset
│           └── ...
│
├── Weapons/
│   └── Rifles/
│       └── AK47/
│           ├── BP_AK47.uasset
│           ├── Meshes/
│           │   └── SK_AK47.uasset
│           └── ...
│
├── Props/
│   └── HealthPack/
│       ├── BP_HealthPack.uasset
│       ├── Meshes/
│       │   └── SM_HealthPack.uasset
│       └── ...
│
└── Maps/
    ├── MainMenu/
    │   └── Map_MainMenu.umap
    └── Jungle/
        ├── Map_Jungle.umap
        ├── Meshes/         # Các mesh chỉ dùng trong map Jungle
        └── Materials/      # Các material chỉ dùng trong map Jungle
</code></pre><h4 id=ưu-điểm-pros-1><strong>Ưu điểm (Pros)</strong><a hidden class=anchor aria-hidden=true href=#ưu-điểm-pros-1>#</a></h4><ol><li><strong>Tính tự chứa và Di động (Self-Contained & Portable):</strong> Đây là ưu điểm tuyệt đối. Chúng ta có thể <strong>di chuyển toàn
bộ nhân vật Player sang một dự án khác chỉ bằng cách sao chép thư mục <code>Content/Characters/Player</code></strong>. Mọi thứ sẽ hoạt
động vì tất cả các tham chiếu (references) đều nằm trong đó.</li><li><strong>Thiên đường cho DLC và Đóng gói (Chunking):</strong> Đây là cách duy nhất để quản lý các gói nội dung một cách hiệu quả.
Chúng ta có thể dễ dàng nói với Unreal: &ldquo;Hãy đóng gói toàn bộ thư mục <code>Content/Maps/Jungle</code> thành Chunk 10.&rdquo; Khi
người chơi muốn tải map này, game chỉ cần tải về file .pak của Chunk 10.</li><li><strong>Workflow liền mạch cho Artist & Designer:</strong> Khi làm việc trên nhân vật Player, mọi file họ cần đều nằm ngay trong
một thư mục. Họ có thể dễ dàng duyệt qua, chỉnh sửa và liên kết các asset với nhau mà không cần rời khỏi &ldquo;khu vực làm
việc&rdquo; của mình.</li></ol><h4 id=nhược-điểm-cons-1><strong>Nhược điểm (Cons)</strong><a hidden class=anchor aria-hidden=true href=#nhược-điểm-cons-1>#</a></h4><ol><li><strong>Vấn đề nan giải về Asset dùng chung (The Shared Asset Dilemma):</strong> Đây là điểm yếu chí mạng. Một Material Master,
một texture kim loại trầy xước, một bộ animation di chuyển cơ bản&mldr; được dùng cho TẤT CẢ các nhân vật sẽ được đặt ở
đâu? Điều này thường dẫn đến sự ra đời của một thư mục <code>Content/Shared</code>, và nếu không được quản lý chặt chẽ, nó có
thể trở thành một &ldquo;bãi rác&rdquo; chứa mọi thứ, làm phá vỡ triết lý ban đầu.</li><li><strong>Nguy cơ Trùng lặp cao:</strong> Vì sự tiện lợi, một artist có thể sẽ sao chép một texture từ thư mục <code>Shared</code> vào thư mục
nhân vật của họ thay vì tạo một Material Instance. Điều này dẫn đến việc asset bị trùng lặp, làm tăng đáng kể kích
thước của game.</li><li><strong>Có thể gây xung đột cho Lập trình viên:</strong> Nếu các lớp C++ cụ thể cho từng tính năng cũng được đặt trong các thư mục
nội dung này, nó có thể làm xáo trộn cấu trúc <code>Source</code> và gây khó khăn cho việc quản lý code.</li></ol><h4 id=i-triết-lý-cốt-lõi-quy-hoạch-thư-mục-là-luật><strong>I. Triết lý cốt lõi: Quy hoạch Thư mục là Luật!</strong><a hidden class=anchor aria-hidden=true href=#i-triết-lý-cốt-lõi-quy-hoạch-thư-mục-là-luật>#</a></h4><p>Trước khi đi vào chi tiết, nguyên tắc tối cao mà Allar&rsquo;s Style Guide đặt ra là: <strong>Sự nhất quán và có tổ chức trong cấu
trúc thư mục và quy tắc đặt tên là không thể thương lượng.</strong></p><ul><li><strong>Tại sao?</strong><ul><li><strong>Khả năng dự đoán:</strong> Bất kỳ thành viên nào trong team, dù mới hay cũ, đều có thể tìm thấy một asset họ cần một
cách nhanh chóng mà không cần phải hỏi ai. Họ biết rằng một Material sẽ nằm trong thư mục <code>Materials</code> và có tiền
tố <code>M_</code>.</li><li><strong>Hiệu quả tìm kiếm:</strong> Content Browser của Unreal trở thành một công cụ cực kỳ mạnh mẽ khi chúng ta có thể lọc
chính xác theo tiền tố (<code>BP_</code>, <code>T_</code>, <code>M_</code>&mldr;).</li><li><strong>Tránh sự hỗn loạn:</strong> Nó ngăn chặn việc các asset tạm thời, thử nghiệm, hoặc trùng lặp làm ô nhiễm dự án chính.</li></ul></li></ul><h4 id=ii-cấu-trúc-lai-tối-ưu---phiên-bản><strong>II. Cấu trúc Lai Tối ưu - Phiên bản &ldquo;Allar&rsquo;s Certified&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#ii-cấu-trúc-lai-tối-ưu---phiên-bản>#</a></h4><p>Chúng ta sẽ áp dụng mô hình &ldquo;Hybrid City&rdquo; nhưng với các quy tắc và tên thư mục cụ thể từ Allar&rsquo;s Style Guide.</p><h5 id=a-hạ-tầng-ngầm-code--><strong>A. Hạ tầng Ngầm (Code - <code>Source/</code>) - Nền móng Kỹ thuật</strong><a hidden class=anchor aria-hidden=true href=#a-hạ-tầng-ngầm-code-->#</a></h5><p>Phần này vẫn tuân thủ nguyên tắc <strong>Quy hoạch theo Chức năng</strong>. Đây là nền móng C++ vững chắc, ít khi bị thay đổi bởi
artist hay designer.</p><ul><li><code>Source/MyGameCore</code>: Các hệ thống toàn cục, interfaces, các lớp helper.</li><li><code>Source/MyGameFramework</code>: Các lớp C++ cơ sở cho gameplay (<code>CharacterBase</code>, <code>WeaponBase</code>, <code>GameStateBase</code>&mldr;). Đây là
cầu nối sang <code>Content/Core</code>.</li><li><code>Source/GameFeatures/</code>: Mỗi hệ thống gameplay lớn nên là một module riêng.<ul><li><code>Source/GameFeatures/Inventory</code></li><li><code>Source/GameFeatures/AbilitySystem</code></li><li><code>Source/GameFeatures/AI</code></li></ul></li></ul><h5 id=b-bề-nổi-assets--><strong>B. Bề nổi (Assets - <code>Content/</code>) - Các Khu phố và Tòa nhà</strong><a hidden class=anchor aria-hidden=true href=#b-bề-nổi-assets-->#</a></h5><p>Đây là nơi chúng ta áp dụng triệt để các quy tắc của Allar, kết hợp giữa <strong>Quy hoạch theo Chức năng</strong> và <strong>Quy hoạch
theo Nội dung</strong>.</p><ul><li><p><code>Content/Core/</code>: <strong>&ldquo;Trung tâm Hành chính & Hạ tầng Chung&rdquo;</strong></p><ul><li>Đây là nơi chứa các asset nền tảng, được sử dụng trên toàn bộ dự án. Nó tương ứng trực tiếp với
<code>Source/MyGameFramework</code>.</li><li><code>Core/Blueprints/</code>: Chứa các Blueprint cơ sở kế thừa trực tiếp từ C++ (<code>BP_CharacterBase</code>, <code>BP_WeaponBase</code>). Các
designer sẽ tạo các Blueprint con từ những lớp này.</li><li><code>Core/Data/</code>: Chứa các Data Table và Data Asset định nghĩa các quy tắc game cơ bản.</li><li><code>Core/Materials/</code>: Chứa các Master Material, Material Function mà tất cả các asset khác sẽ tạo instance từ đó.</li><li><code>Core/Input/</code>: Chứa các Input Action và Input Mapping Context của hệ thống Enhanced Input.</li></ul></li><li><p><code>Content/Shared/</code>: Sẽ được đặt ở cấp cao nhất của Content, và bản thân nó cũng cần có một cấu trúc bên trong rõ
ràng, thường là theo chức năng:</p><ul><li><p><strong>Quy tắc đóng gói:</strong> Khi thiết lập các quy tắc đóng gói (Packaging Rules) và Primary Asset Labels, toàn bộ thư
mục <code>Content/Shared</code> sẽ được gán cho <strong>Chunk 0</strong>. Điều này đảm bảo rằng khi người chơi tải game lần đầu, họ sẽ có
tất cả các asset nền tảng cần thiết để mọi gói nội dung khác (DLC, map mới) có thể hoạt động chính xác khi được
tải về sau này.</p></li><li><p><strong>Để giảm thiểu rủi ro, team phải tuân thủ các quy tắc nghiêm ngặt:</strong></p><ul><li><strong>Quy tắc #1: Phải có &ldquo;Strict Gatekeeping&rdquo;:</strong> Không ai được phép tự ý thêm asset vào
<code>Content/Shared</code>. Phải có một hoặc vài người (thường là Art Director, Technical Art Lead, hoặc Lead Engineer)
chịu trách nhiệm phê duyệt mọi thứ được đưa vào đây.</li><li><strong>Quy tắc #2: &ldquo;The Rule of Three&rdquo;:</strong> Một asset chỉ nên được xem xét để đưa vào <code>Shared</code> khi
nó được yêu cầu sử dụng ở <strong>ba hoặc nhiều nơi khác nhau và riêng biệt</strong>. Nếu nó chỉ được dùng cho hai nhân
vật, có thể tốt hơn là giữ nó ở một trong hai thư mục nhân vật đó và tham chiếu chéo.</li><li><strong>Quy tắc #3: <code>Shared</code> là &ldquo;Chỉ đọc&rdquo; với Hầu hết mọi người:</strong> Đối với đa số thành viên trong team, các asset
trong <code>Shared</code> nên được coi là &ldquo;read-only&rdquo;. Họ chỉ nên tạo instance hoặc tham chiếu đến chúng. Việc
chỉnh sửa một asset trong <code>Shared</code> phải là một quy trình có kiểm soát, có thể yêu cầu một buổi họp review
ngắn.</li><li><strong>Quy tắc #4: Regular Audits:</strong> Cứ mỗi một hoặc hai tháng, Senior nên rà soát lại thư mục <code>Shared</code> để tìm và
loại bỏ các asset không còn được sử dụng hoặc những asset được thêm vào không đúng quy cách.</li></ul></li></ul></li><li><p><code>Content/Characters/</code>, <code>Content/Weapons/</code>, <code>Content/Environments/</code>, <code>Content/Props/</code>: <strong>&ldquo;Các Khu Dân cư và Công trình
Chuyên dụng&rdquo;</strong></p><ul><li>Đây là phần <strong>Quy hoạch theo Nội dung</strong>. Mỗi thư mục này chứa tất cả mọi thứ liên quan đến một thực thể cụ thể.</li><li><em>Ví dụ với <code>Content/Characters/CyberNinja/</code></em>:<ul><li><code>BP_CyberNinja</code> (kế thừa từ <code>Core/Blueprints/BP_CharacterBase</code>)</li><li><code>Meshes/SK_CyberNinja</code></li><li><code>Textures/T_CyberNinja_D</code>, <code>T_CyberNinja_N</code></li><li><code>Materials/MI_CyberNinja</code> (một instance của <code>Core/Materials/M_Character_Master</code>)</li><li><code>Animations/A_CyberNinja_Attack</code></li></ul></li><li><strong>Lợi ích cho Pak/Chunk:</strong> Cấu trúc tự chứa này làm cho việc đóng gói trở nên cực kỳ đơn giản. chúng ta có thể tạo
một chunk ID cho toàn bộ thư mục <code>Characters/CyberNinja</code>. Nếu nhân vật này là một DLC, người chơi có thể tải về
chỉ gói đó mà không ảnh hưởng đến phần còn lại của game. Tương tự với <code>Maps/Jungle/</code>.</li></ul></li><li><p><code>Content/Developers/</code>: <strong>&ldquo;Khu vực Thử nghiệm & Sandbox Cá nhân&rdquo;</strong></p><ul><li>Đây là một trong những quy tắc thiên tài nhất của Allar. Mỗi thành viên trong team sẽ có một thư mục con riêng
trong này (ví dụ: <code>Developers/JohnDoe/</code>).</li><li><strong>Mục đích:</strong> Đây là nơi an toàn để mỗi người thử nghiệm, tạo các asset tạm thời, &ldquo;chọc ngoáy&rdquo; mà <strong>không làm ô
nhiễm</strong> dự án chính.</li><li><strong>Quy tắc tối cao:</strong> Thư mục <code>Content/Developers/</code> phải được thêm vào file <code>.gitignore</code> (hoặc các file ignore của
Perforce). <strong>Nội dung trong này không bao giờ được commit lên version control.</strong></li></ul></li></ul><h5 id=c-sơ-đồ-quy-hoạch-tổng-thể><strong>C. Sơ đồ Quy hoạch Tổng thể</strong><a hidden class=anchor aria-hidden=true href=#c-sơ-đồ-quy-hoạch-tổng-thể>#</a></h5><p>Đây là hình dung về cấu trúc lai cuối cùng của chúng ta:</p><pre tabindex=0><code>├── Source/
│   ├── MyGameCore/
│   └── GameFeatures/
│       └── Inventory/
│
└── Content/
    ├── Core/
    │   ├── Blueprints/
    │   └── Materials/
    │
    ├── Characters/
    │   └── CyberNinja/
    │       ├── BP_CyberNinja.uasset
    │       ├── Meshes/
    │       └── Textures/
    │
    ├── Maps/
    │   └── Jungle/
    │       ├── Map_Jungle.umap
    │       ├── Meshes/
    │       └── Materials/
    │
    ├── GameFeatures/
    │   └── Inventory/
    │       ├── Data/
    │       └── UI/
    │
    ├── Developers/
    │   ├── JohnDoe/    (NEVER COMMIT)
    │   └── JaneSmith/  (NEVER COMMIT)
    │
    └── _External/      # Chứa các asset từ bên ngoài (ví dụ: Megascans)
    │
    ├── _Shared/
    
</code></pre><h4 id=iii-ưu-điểm-vượt-trội-của-mô-hình-quy-hoạch-lai-này><strong>III. Ưu điểm Vượt trội của Mô hình Quy hoạch Lai này</strong><a hidden class=anchor aria-hidden=true href=#iii-ưu-điểm-vượt-trội-của-mô-hình-quy-hoạch-lai-này>#</a></h4><ul><li><strong>Tối ưu cho mọi vai trò:</strong><ul><li><strong>Lập trình viên</strong> có một cấu trúc code module hóa, sạch sẽ trong <code>Source/</code>.</li><li><strong>Artist/Designer</strong> có một cấu trúc nội dung trực quan, tự chứa trong <code>Content/</code>, cho phép họ làm việc độc lập.</li><li><strong>Technical Director</strong> có thể dễ dàng quản lý và tự động hóa quy trình đóng gói (packaging) dựa trên cấu trúc này.</li></ul></li><li><strong>Sẵn sàng cho Tương lai (Future-Proof):</strong><ul><li><strong>DLC & Cập nhật:</strong> Việc thêm một gói nội dung mới (nhân vật, map) chỉ đơn giản là tạo một thư mục mới theo đúng
quy chuẩn mà không cần tái cấu trúc lại toàn bộ dự án.</li><li><strong>Tối ưu hóa Phân phối:</strong> Cấu trúc này là nền tảng để chúng ta có thể phân phối game dưới dạng các &ldquo;chunk&rdquo; nhỏ.
Người chơi có thể tải phần chơi chính trước, và tải các gói ngôn ngữ, các map độ phân giải cao, hoặc các phần chơi
khác sau.</li></ul></li><li><strong>Vận hành và Hỗ trợ đa nền tảng:</strong><ul><li>Khi một lỗi xảy ra chỉ trên Android liên quan đến nhân vật CyberNinja, chúng ta biết chính xác cần phải kiểm tra
các file trong <code>Content/Characters/CyberNinja</code> và các lớp C++ cơ sở mà nó kế thừa.</li><li>Việc quản lý các phiên bản (develop, staging, production) trở nên dễ dàng hơn vì cấu trúc nhất quán giúp các công
cụ CI/CD (như TeamCity) xác định và đóng gói các thay đổi một cách đáng tin cậy.</li></ul></li></ul><hr><h3 id=khả-năng-mở-rộng-bảo-trì-và-làm-việc-với-version-control><strong>Khả năng Mở rộng, Bảo trì và làm việc với Version Control</strong><a hidden class=anchor aria-hidden=true href=#khả-năng-mở-rộng-bảo-trì-và-làm-việc-với-version-control>#</a></h3><p>Đây là lợi ích chiến lược lớn nhất khi chọn C++, quyết định khả năng &ldquo;sống sót&rdquo; và phát triển của dự án trong dài hạn.</p><h4 id=kiến-trúc-linh-hoạt-kết-hợp-kế-thừa-oop-và-tập-hợp-composition><strong>Kiến trúc linh hoạt: Kết hợp Kế thừa (OOP) và Tập hợp (Composition)</strong><a hidden class=anchor aria-hidden=true href=#kiến-trúc-linh-hoạt-kết-hợp-kế-thừa-oop-và-tập-hợp-composition>#</a></h4><p>C++ cho phép chúng ta tận dụng triệt để các nguyên tắc OOP. Ví dụ, chúng ta có thể tạo một lớp <code>ABaseWeapon</code> định nghĩa
các hành vi chung (bắn, nạp đạn). Sau đó, các lớp con <code>ARifle</code>, <code>APistol</code> có thể kế thừa và chuyên biệt hóa các hành vi
đó.</p><p>Tuy nhiên, một kiến trúc hiện đại và linh hoạt hơn là kết hợp Kế thừa với <strong>Composition (Kiến trúc tập hợp các thành
phần)</strong>.</p><ul><li><strong>Triển khai gợi ý của chúng ta:</strong> Thay vì một <code>ARifle</code> kế thừa mọi thứ từ <code>ABaseWeapon</code>, chúng ta tạo ra một lớp
<code>AWeapon</code> cơ bản. Các chức năng cụ thể như &ldquo;bắn đạn ghém&rdquo; (<code>ShotgunFireComponent</code>), &ldquo;ngắm bắn qua ống ngắm&rdquo; (
<code>ScopeComponent</code>), hay &ldquo;bắn tia laser&rdquo; (<code>LaserBeamComponent</code>) sẽ được xây dựng dưới dạng các <strong>Actor Component</strong>.</li><li><strong>Tại sao đây là phương pháp vượt trội?</strong><ul><li><strong>&ldquo;Cắm và Chạy&rdquo; (Plug-and-Play):</strong> chúng ta có thể tạo ra một khẩu súng hoàn toàn mới trong Blueprint chỉ bằng
cách lắp ghép các Component này lại với nhau, giống như lắp ráp các module Lego. Một khẩu súng trường tấn công có
thể được tạo từ <code>AWeapon</code> + <code>AutomaticFireComponent</code> + <code>ScopeComponent</code>.</li><li><strong>Tái sử dụng tối đa:</strong> <code>ScopeComponent</code> không chỉ dùng cho súng, nó có thể được gắn vào cả ống nhòm hoặc các công
cụ khác.</li><li><strong>Tránh &ldquo;Địa ngục Kế thừa&rdquo;:</strong> chúng ta sẽ không bị rơi vào tình huống tạo ra một cây kế thừa phức tạp, đa tầng,
khó quản lý chỉ để chia sẻ một vài chức năng nhỏ.</li></ul></li></ul><h4 id=cấu-trúc-module-và-version-control-git-xây-dựng-một><strong>Cấu trúc Module và Version Control (Git): Xây dựng một &ldquo;Thành phố&rdquo; có quy hoạch</strong><a hidden class=anchor aria-hidden=true href=#cấu-trúc-module-và-version-control-git-xây-dựng-một>#</a></h4><p>Việc chia dự án thành các module (<code>MyGameCore</code>, <code>MyGameInventory</code>, <code>MyGameAI</code>&mldr;) giống như việc quy hoạch một thành phố
thành các quận chuyên biệt.</p><ul><li><strong>Giảm thiểu xung đột (Merge Conflicts):</strong> Khi các team làm việc trong các &ldquo;quận&rdquo; (module) riêng của mình, khả năng
họ &ldquo;xây dựng&rdquo; chồng chéo lên nhau và gây ra xung đột trên Git sẽ giảm đi đáng kể. Đây là yếu tố sống còn để duy trì
hiệu suất làm việc của một team lớn.</li><li><strong>Tăng tốc độ biên dịch:</strong> Unreal Build Tool có thể biên dịch các module song song. Một dự án được module hóa tốt sẽ
có thời gian biên dịch nhanh hơn. chúng ta cũng có thể thiết lập để chỉ biên dịch lại những module có thay đổi.</li><li><strong>Sở hữu Code rõ ràng (Code Ownership):</strong> Mỗi module có thể có một &ldquo;chủ sở hữu&rdquo; hoặc team chịu trách nhiệm chính. Khi
có lỗi phát sinh trong hệ thống túi đồ, mọi người đều biết cần phải liên hệ với team <code>Inventory</code>. Điều này tạo ra sự
rõ ràng và trách nhiệm trong tổ chức.</li></ul><hr><h3 id=tip--trick-cho-team-tối-ưu-hóa-quy-trình-làm-việc><strong>Tip & Trick cho Team: Tối ưu hóa quy trình làm việc</strong><a hidden class=anchor aria-hidden=true href=#tip--trick-cho-team-tối-ưu-hóa-quy-trình-làm-việc>#</a></h3><h4 id=1-hybrid-approach><strong>1. Hybrid Approach: &ldquo;C++ xây Siêu xa lộ, Blueprint xây Nhà dân&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#1-hybrid-approach>#</a></h4><p>Đây là triết lý làm việc cốt lõi giúp cân bằng giữa hiệu năng và tốc độ phát triển.</p><ul><li><p><strong>Vai trò của Lập trình viên C++:</strong></p><ul><li>Xây dựng các hệ thống nền tảng vững chắc và các &ldquo;đường cao tốc&rdquo; truyền dữ liệu hiệu năng cao.</li><li>Không chỉ &ldquo;phơi bày&rdquo; các hàm (<code>UFUNCTION</code>), các biến (<code>UPROPERTY</code>) với các meta, property, họ còn định nghĩa các "
kênh sự kiện" bằng delegate (
<code>UPROPERTY(BlueprintAssignable)</code>) để Blueprint có thể &ldquo;lắng nghe&rdquo; và phản ứng lại các sự kiện từ C++ (ví dụ:
<code>OnHealthChanged</code>, <code>OnItemAddedToInventory</code>).</li><li>Họ tạo ra các &ldquo;hợp đồng&rdquo; dữ liệu thông qua <code>UDataAsset</code> và <code>UDataTable</code>.</li></ul></li><li><p><strong>Triển khai gợi ý của chúng ta (Tách biệt Dữ liệu và Logic):</strong></p><ul><li>Lập trình viên C++ sẽ tạo ra các lớp cơ sở như <code>UItemData</code> (kế thừa từ <code>UDataAsset</code>).</li><li>Game Designer, thay vì chỉnh sửa <code>BP_HealthPotion</code>, giờ đây sẽ tạo và chỉnh sửa một asset dữ liệu là
<code>DA_HealthPotion</code>. Asset này chứa mọi thông số: tên, icon, số lượng máu hồi phục, hiệu ứng âm thanh khi sử dụng.</li><li>Lớp <code>AItemActor</code> (trong C++) hoặc <code>BP_ItemActor</code> (trong Blueprint) sẽ chỉ có một biến duy nhất là <code>ItemData</code> (một
con trỏ tới <code>UItemData</code>). Toàn bộ hành vi và hiển thị của nó sẽ được điều khiển bởi dữ liệu trong asset đó.</li><li><strong>Kết quả:</strong> Dev và Designer có thể làm việc song song. Designer có thể tạo ra hàng trăm item mà không cần sự can
thiệp của dev, và dev có thể tối ưu hóa logic xử lý item mà không sợ làm hỏng dữ liệu của Designer. <strong>Xung đột
trên version control gần như bằng không.</strong></li></ul></li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://oaiba.github.io/dev/vi/tags/h%C6%B0%E1%BB%9Bng-d%E1%BA%ABn/>Hướng Dẫn</a></li><li><a href=https://oaiba.github.io/dev/vi/tags/markdown/>Markdown</a></li><li><a href=https://oaiba.github.io/dev/vi/tags/hugo/>Hugo</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://oaiba.github.io/dev/vi/>Nhật ký phát triển của Bob Phạm</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Sao chép";function s(){t.innerHTML="Đã sao chép!",setTimeout(()=>{t.innerHTML="Sao chép"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>