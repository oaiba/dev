<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DevLog: #3 Building Advanced 'Twin-Stick' Movement in C++ | Bob Pham's DevLog</title><meta name=keywords content="DevLog,Tutorial"><meta name=description content="In this article, we will build a robust and flexible omnidirectional movement system in C++. This system allows the character to move relative to the camera&rsquo;s perspective and to rotate their body to look or aim independently."><meta name=author content="Bob"><link rel=canonical href=https://oaiba.github.io/dev/en/posts/devlog-3-building-advanced-twin-stick-movement-in-c++/><link crossorigin=anonymous href=/dev/assets/css/stylesheet.2d34aa540016c110be7711e937b1408a15429e749480457ef136067433c3512d.css integrity="sha256-LTSqVAAWwRC+dxHpN7FAihVCnnSUgEV+8TYGdDPDUS0=" rel="preload stylesheet" as=style><link rel=icon href=https://oaiba.github.io/dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://oaiba.github.io/dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://oaiba.github.io/dev/favicon-32x32.png><link rel=apple-touch-icon href=https://oaiba.github.io/dev/apple-touch-icon.png><link rel=mask-icon href=https://oaiba.github.io/dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://oaiba.github.io/dev/en/posts/devlog-3-building-advanced-twin-stick-movement-in-c++/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://oaiba.github.io/dev/en/posts/devlog-3-building-advanced-twin-stick-movement-in-c++/"><meta property="og:site_name" content="Bob Pham's DevLog"><meta property="og:title" content="DevLog: #3 Building Advanced 'Twin-Stick' Movement in C++"><meta property="og:description" content="In this article, we will build a robust and flexible omnidirectional movement system in C++. This system allows the character to move relative to the camera‚Äôs perspective and to rotate their body to look or aim independently."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-31T10:13:42+07:00"><meta property="article:modified_time" content="2025-07-31T10:13:42+07:00"><meta property="article:tag" content="DevLog"><meta property="article:tag" content="Tutorial"><meta property="og:image" content="https://github.com/oaiba/dev-blog/blob/gh-pages/downloads/devlog-3/sample-out-put.gif?raw=true"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://github.com/oaiba/dev-blog/blob/gh-pages/downloads/devlog-3/sample-out-put.gif?raw=true"><meta name=twitter:title content="DevLog: #3 Building Advanced 'Twin-Stick' Movement in C++"><meta name=twitter:description content="In this article, we will build a robust and flexible omnidirectional movement system in C++. This system allows the character to move relative to the camera&rsquo;s perspective and to rotate their body to look or aim independently."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://oaiba.github.io/dev/en/posts/"},{"@type":"ListItem","position":2,"name":"DevLog: #3 Building Advanced 'Twin-Stick' Movement in C++","item":"https://oaiba.github.io/dev/en/posts/devlog-3-building-advanced-twin-stick-movement-in-c++/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"DevLog: #3 Building Advanced 'Twin-Stick' Movement in C++","name":"DevLog: #3 Building Advanced \u0027Twin-Stick\u0027 Movement in C\u002b\u002b","description":"In this article, we will build a robust and flexible omnidirectional movement system in C++. This system allows the character to move relative to the camera\u0026rsquo;s perspective and to rotate their body to look or aim independently.","keywords":["DevLog","Tutorial"],"articleBody":"üéØ The Problem \u0026 The Goal The Problem: After setting up a flexible top-down camera system in the previous two articles, we face a classic challenge: character movement. Unreal‚Äôs default movement system (bOrientRotationToMovement) often couples the movement direction with the character‚Äôs facing direction. This is great for third-person adventure games but is a major limitation for top-down games, twin-stick shooters, or MOBAs, where the player needs to run in one direction and aim or look in another. The Goal: In this article, we will build a robust and flexible omnidirectional movement system in C++. This system allows the character to move relative to the camera‚Äôs perspective and to rotate their body to look or aim independently. Most importantly, we will create a seamless state-switching mechanism between two modes: ‚Äúnormal movement‚Äù (facing the run direction) and ‚Äúaiming‚Äù (facing a specific direction). üìö Context \u0026 Theory The architecture of this solution revolves around controlling two critical boolean properties of the UCharacterMovementComponent. Our entire system is essentially a simple state machine that toggles them appropriately.\nbOrientRotationToMovement = true: This is our ‚Äúnormal movement‚Äù state. When enabled, the Engine automatically rotates the character to face its current velocity vector. This is the default behavior for ACharacter.\nbUseControllerDesiredRotation = true: This is our ‚Äúfree look/aim‚Äù state. When enabled, the Engine rotates the character to match the Controller‚Äôs ControlRotation. By manipulating this ControlRotation in code, we can make the character look in any direction we want, regardless of their movement.\nOur Key: Create a function to safely switch between these two states.\nüöÄ The Implementation Journey We will break down each part of the system, starting with the foundational state-switching function.\nStep 1: The Foundation‚ÄîThe Rotation State-Switching Function This is the heart of the system. A simple private function is responsible for toggling the flags on the CharacterMovementComponent. Encapsulating this logic into a single function keeps the code clean, readable, and avoids repetition. It also ensures that bOrientRotationToMovement and bUseControllerDesiredRotation are always in opposing states, preventing unexpected behavior.\nvoid ACharacterBase::SetShouldFollowMovement(const bool bShouldFollow) { bShouldFollowMovement = bShouldFollow; if (auto* Movement = GetCharacterMovement()) { // When bShouldFollow is true, we are in \"running\" mode. // When bShouldFollow is false, we are in \"aiming\" mode. const bool bIsInAimingMode = !bShouldFollowMovement; Movement-\u003ebUseControllerDesiredRotation = bIsInAimingMode; Movement-\u003ebOrientRotationToMovement = !bIsInAimingMode; } } Step 2: Camera-Relative Omnidirectional Movement This function takes 2D input (from WASD keys or a gamepad‚Äôs left stick) and translates it into movement in the game world. We don‚Äôt want the W key to always move the character along the world‚Äôs X-axis. We want W to move the character ‚Äúforward‚Äù relative to the camera‚Äôs view. To do this, we need to rotate the player‚Äôs input vector by an angle equal to the camera‚Äôs yaw.\nvoid ACharacterBase::HandleMovementTrigger(const FVector2D InputAxisVector) { // Guard clauses to prevent execution when not needed. if (!Controller || InputAxisVector.IsNearlyZero()) { return; } if (const auto* Movement = GetCharacterMovement()) { if (Movement-\u003eIsFalling()) { return; } } // The camera's rotation around the Z-axis (Yaw). const float CameraYawRadians = FMath::DegreesToRadians(CameraYawDegrees); // Rotate the input vector based on the camera's yaw using a 2D rotation matrix. const float CosAngle = FMath::Cos(CameraYawRadians); const float SinAngle = FMath::Sin(CameraYawRadians); const float X = InputAxisVector.X * CosAngle - InputAxisVector.Y * SinAngle; const float Y = InputAxisVector.X * SinAngle + InputAxisVector.Y * CosAngle; const FVector MoveDirection = FVector(Y, X, 0.f).GetSafeNormal(); // Apply the calculated movement input. AddMovementInput(MoveDirection); // If the character should face its movement direction, rotate it. if (bShouldFollowMovement) { const float TargetYaw = MoveDirection.Rotation().Yaw; RotateTowardsYaw(TargetYaw, 2.5f); // Use our helper for smooth rotation } } The Breakdown: The math section with CosAngle and SinAngle is the formula for a 2D rotation matrix. It transforms the input vector from ‚Äúscreen space‚Äù to ‚Äúcamera-relative world space.‚Äù When bShouldFollowMovement is true, we calculate the movement direction and use our helper function RotateTowardsYaw to turn the character accordingly. Step 3: Independent Looking \u0026 Aiming This system consists of three functions, corresponding to the Started, Triggered, and Completed events from the Enhanced Input system (typically for a gamepad‚Äôs right stick). When the player starts using the right stick ( HandleLookStarted), we switch to ‚Äúaiming mode‚Äù using SetShouldFollowMovement(false). When they release it (HandleLookCompleted), we return to ‚Äúmovement mode.‚Äù While they are holding it (HandleLookTriggered), we continuously update the character‚Äôs facing direction.\nvoid ACharacterBase::HandleLookStarted() { SetShouldFollowMovement(false); // Enter \"Aiming Mode\" } void ACharacterBase::HandleLookTriggered(const FVector2D InputAxisVector) { if (const auto* Movement = GetCharacterMovement()) { if (Movement-\u003eIsFalling()) { return; } } // Define the range for mapping the look input. constexpr float MinYaw = -90.0f; constexpr float MaxYaw = 90.0f; constexpr float MinPitch = -70.0f; constexpr float MaxPitch = 70.0f; // Scale the input from [-1, 1] to the defined min/max ranges. const float ScaledX = FMath::Lerp(MinYaw, MaxYaw, (InputAxisVector.X + 1.0f) / 2.0f); const float ScaledY = FMath::Lerp(MinPitch, MaxPitch, (InputAxisVector.Y + 1.0f) / 2.0f); // Calculate the target yaw relative to the screen/input axis (local yaw). // This is the direction the player is pushing the stick relative to the screen. const float LocalTargetYaw = FMath::RadiansToDegrees(FMath::Atan2(ScaledX, -ScaledY)); // *** KEY LOGIC CHANGE IS HERE *** // Add the camera's yaw to the local yaw to get the final world-space target yaw. // This makes the character's 'look' direction relative to the camera. const float WorldTargetYaw = FMath::UnwindDegrees(LocalTargetYaw + CameraYawDegrees); // Use the unified helper function to handle the rotation towards the new world-space target. RotateTowardsYaw(WorldTargetYaw, 5.0f); } void ACharacterBase::HandleLookCompleted() { SetShouldFollowMovement(true); // Return to \"Running Mode\" } The Breakdown: The line WorldTargetYaw = FMath::UnwindDegrees(TargetYawFromInput + CameraYawDegrees); is the most critical part. It ensures the player‚Äôs ‚Äúaim‚Äù direction is always consistent with the camera‚Äôs perspective, creating an intuitive control experience. Step 4: The Smooth Rotation Helper Function Rotating the character needs to be done smoothly and independently of the frame rate. This function allows us to reuse that logic for both movement and aiming modes.\n/** * @brief Helper function to smoothly rotate the controller towards a target yaw. */ void ACharacterBase::RotateTowardsYaw(const float TargetYaw, const float RotationSpeed) { const float CurrentYaw = GetControlRotation().Yaw; // Find the shortest angle to rotate. Avoids rotating 350 degrees when -10 is shorter. const float DeltaYaw = FMath::FindDeltaAngleDegrees(CurrentYaw, TargetYaw); const float DeltaTime = UGameplayStatics::GetWorldDeltaSeconds(this); // Add yaw input, scaled by speed and delta time for frame-rate independence. AddControllerYawInput(DeltaYaw * RotationSpeed * DeltaTime); } Step 5: Exposing and Calling Functions from the Player Character Blueprint Our C++ logic is ready, but it needs to be triggered by player input. This step connects everything. We will use the UFUNCTION(BlueprintCallable) macro to ‚Äúexpose‚Äù our C++ functions, allowing the Player Character Blueprint to see and call them. Then, we will connect the events from Enhanced Input to these corresponding functions. This is a classic Unreal workflow: Write complex, high-performance logic in C++ and use Blueprint for flexible ‚Äúwiring.‚Äù\nPart 1: Exposing Functions to Blueprint (C++ Header) In your character‚Äôs header file (ACharacterBase.h), add the UFUNCTION macro before the input handling functions.\n// In your character's header file (e.g., ACharacterBase.h) public: /** Handles movement input. Called from Blueprint. */ UFUNCTION(BlueprintCallable, Category = \"Character | Input\") void HandleMovementTrigger(const FVector2D InputAxisVector); /** Called when the look input action starts. */ UFUNCTION(BlueprintCallable, Category = \"Character | Input\") void HandleLookStarted(); /** Handles look input. Called every frame the input is active. */ UFUNCTION(BlueprintCallable, Category = \"Character | Input\") void HandleLookTriggered(const FVector2D InputAxisVector); /** Called when the look input action completes. */ UFUNCTION(BlueprintCallable, Category = \"Character | Input\") void HandleLookCompleted(); üí° Pro-Tip: Using a Category in the UFUNCTION macro organizes your functions neatly in the Blueprint‚Äôs right-click menu, making them easier for designers or yourself to find.\nPart 2: Calling the Functions from Blueprint After compiling the C++ code, open your Player Character Blueprint (this class must inherit from ACharacterBase). You can now call these C++ functions directly from the Enhanced Input event nodes.\nEvent Graph in BP_PlayerCharacter\nThe Breakdown:\nEvent IA_Move: This event fires every frame that there is movement input (WASD or Left Stick). We take its Action Value (which is an FVector2D) and pass it directly into our C++ function HandleMovementTrigger. Event IA_Look:\nThe Started pin fires once when the player begins moving the Right Stick. It calls the HandleLookStarted function to switch the character to ‚Äúaiming‚Äù mode. The Triggered pin fires every frame the Right Stick is held. It passes the Action Value into the HandleLookTriggered function to update the character‚Äôs rotation. The Completed pin fires once when the player releases the Right Stick. It calls HandleLookCompleted to return the character to the normal ‚Äúmovement‚Äù mode. With this setup, we have completed the full loop: Input -\u003e Blueprint Event -\u003e C++ Logic -\u003e Character Movement.\nüìä Visual Results \u0026 Analysis Visual Demo: Result Analysis: Functional: We have successfully created a complete, flexible, and intuitive twin-stick control system that meets the demands of modern top-down games. Technical: The system is driven by a simple state machine (bShouldFollowMovement), making the code easy to understand and manage. The use of helper functions like RotateTowardsYaw and SetShouldFollowMovement adheres to the DRY (Don‚Äôt Repeat Yourself) principle. Workflow: By connecting these Handle... functions to Input Actions in the Enhanced Input system, we have completely separated the processing logic from the input definition, allowing designers and programmers to work in parallel effectively. ‚ú® Conclusion \u0026 Key Takeaways Here‚Äôs what we learned today:\nLesson 1: The power of toggling between bOrientRotationToMovement and bUseControllerDesiredRotation to create different movement and rotation modes. Lesson 2: How to apply vector math (a 2D rotation matrix) to create camera-relative movement, a foundational technique for many game genres. Lesson 3: The importance of encapsulating repeated logic into helper functions to create cleaner and more maintainable code. üí° Challenge \u0026 Next Steps A Challenge for You: Currently, the transition between ‚Äúaiming‚Äù and ‚Äúmovement‚Äù modes is instant. Can you modify the SetShouldFollowMovement function to add a short transition time (e.g., 0.15 seconds) and interpolate the CharacterMovementComponent‚Äôs rotation rate settings for a smoother state change? ","wordCount":"1643","inLanguage":"en","image":"https://github.com/oaiba/dev-blog/blob/gh-pages/downloads/devlog-3/sample-out-put.gif?raw=true","datePublished":"2025-07-31T10:13:42+07:00","dateModified":"2025-07-31T10:13:42+07:00","author":{"@type":"Person","name":"Bob"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://oaiba.github.io/dev/en/posts/devlog-3-building-advanced-twin-stick-movement-in-c++/"},"publisher":{"@type":"Organization","name":"Bob Pham's DevLog","logo":{"@type":"ImageObject","url":"https://oaiba.github.io/dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://oaiba.github.io/dev/en/ accesskey=h title="Bob Pham's DevLog (Alt + H)">Bob Pham's DevLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://oaiba.github.io/dev/vi/ title="Ti·∫øng Vi·ªát" aria-label="Ti·∫øng Vi·ªát">Ti·∫øng Vi·ªát</a></li></ul></div></div><ul id=menu><li><a href=https://oaiba.github.io/dev/en/about/ title="About Me"><span>About Me</span></a></li><li><a href=https://oaiba.github.io/dev/en/resume/ title=Resume><span>Resume</span></a></li><li><a href=https://oaiba.github.io/dev/en/posts/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://oaiba.github.io/dev/en/>Home</a>&nbsp;¬ª&nbsp;<a href=https://oaiba.github.io/dev/en/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">DevLog: #3 Building Advanced 'Twin-Stick' Movement in C++</h1><div class=post-meta><span title='2025-07-31 10:13:42 +0700 +0700'>July 31, 2025</span>&nbsp;¬∑&nbsp;8 min&nbsp;¬∑&nbsp;1643 words&nbsp;¬∑&nbsp;Bob</div></header><figure class=entry-cover><img loading=eager src="https://github.com/oaiba/dev-blog/blob/gh-pages/downloads/devlog-3/sample-out-put.gif?raw=true" alt="this is alter cover"><figcaption>Building Advanced &ldquo;Twin-Stick&rdquo; Movement in C++</figcaption></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#-the-problem--the-goal aria-label="üéØ The Problem & The Goal">üéØ The Problem & The Goal</a></li><li><a href=#-context--theory aria-label="üìö Context & Theory">üìö Context & Theory</a></li><li><a href=#-the-implementation-journey aria-label="üöÄ The Implementation Journey">üöÄ The Implementation Journey</a><ul><li><a href=#step-1-the-foundationthe-rotation-state-switching-function aria-label="Step 1: The Foundation‚ÄîThe Rotation State-Switching Function">Step 1: The Foundation‚ÄîThe Rotation State-Switching Function</a></li><li><a href=#step-2-camera-relative-omnidirectional-movement aria-label="Step 2: Camera-Relative Omnidirectional Movement">Step 2: Camera-Relative Omnidirectional Movement</a></li><li><a href=#step-3-independent-looking--aiming aria-label="Step 3: Independent Looking & Aiming">Step 3: Independent Looking & Aiming</a></li><li><a href=#step-4-the-smooth-rotation-helper-function aria-label="Step 4: The Smooth Rotation Helper Function">Step 4: The Smooth Rotation Helper Function</a></li><li><a href=#step-5-exposing-and-calling-functions-from-the-player-character-blueprint aria-label="Step 5: Exposing and Calling Functions from the Player Character Blueprint">Step 5: Exposing and Calling Functions from the Player Character Blueprint</a></li></ul></li><li><a href=#-visual-results--analysis aria-label="üìä Visual Results & Analysis">üìä Visual Results & Analysis</a></li><li><a href=#-conclusion--key-takeaways aria-label="‚ú® Conclusion & Key Takeaways">‚ú® Conclusion & Key Takeaways</a></li><li><a href=#-challenge--next-steps aria-label="üí° Challenge & Next Steps">üí° Challenge & Next Steps</a></li></ul></div></details></div><div class=post-content><h3 id=-the-problem--the-goal>üéØ The Problem & The Goal<a hidden class=anchor aria-hidden=true href=#-the-problem--the-goal>#</a></h3><ul><li><strong>The Problem:</strong> After setting up a flexible top-down camera system in the previous two articles, we face a classic
challenge: character movement. Unreal&rsquo;s default movement system (<code>bOrientRotationToMovement</code>) often couples the
movement direction with the character&rsquo;s facing direction. This is great for third-person adventure games but is a
major limitation for top-down games, twin-stick shooters, or MOBAs, where the player needs to <strong>run in one direction
and aim or look in another</strong>.</li><li><strong>The Goal:</strong> In this article, we will build a robust and flexible omnidirectional movement system in C++. This system
allows the character to move relative to the camera&rsquo;s perspective and to rotate their body to look or aim
independently. Most importantly, we will create a seamless state-switching mechanism between two modes: &ldquo;normal
movement&rdquo; (facing the run direction) and &ldquo;aiming&rdquo; (facing a specific direction).</li></ul><hr><h3 id=-context--theory>üìö Context & Theory<a hidden class=anchor aria-hidden=true href=#-context--theory>#</a></h3><p>The architecture of this solution revolves around controlling two critical boolean properties of the
<code>UCharacterMovementComponent</code>. Our entire system is essentially a simple state machine that toggles them appropriately.</p><ol><li><p><strong><code>bOrientRotationToMovement = true</code></strong>: This is our &ldquo;normal movement&rdquo; state. When enabled, the Engine automatically
rotates the character to face its current velocity vector. This is the default behavior for <code>ACharacter</code>.</p></li><li><p><strong><code>bUseControllerDesiredRotation = true</code></strong>: This is our &ldquo;free look/aim&rdquo; state. When enabled, the Engine rotates the
character to match the <code>Controller</code>&rsquo;s <code>ControlRotation</code>. By manipulating this <code>ControlRotation</code> in code, we can make
the character look in any direction we want, regardless of their movement.</p></li></ol><blockquote><p><strong>Our Key:</strong> Create a function to safely switch between these two states.</p></blockquote><hr><h3 id=-the-implementation-journey>üöÄ The Implementation Journey<a hidden class=anchor aria-hidden=true href=#-the-implementation-journey>#</a></h3><p>We will break down each part of the system, starting with the foundational state-switching function.</p><h4 id=step-1-the-foundationthe-rotation-state-switching-function>Step 1: The Foundation‚ÄîThe Rotation State-Switching Function<a hidden class=anchor aria-hidden=true href=#step-1-the-foundationthe-rotation-state-switching-function>#</a></h4><p>This is the heart of the system. A simple <code>private</code> function is responsible for toggling the flags on the
<code>CharacterMovementComponent</code>. Encapsulating this logic into a single function keeps the code clean, readable, and avoids
repetition.
It also ensures that <code>bOrientRotationToMovement</code> and <code>bUseControllerDesiredRotation</code> are always in opposing states,
preventing unexpected behavior.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> ACharacterBase<span style=color:#f92672>::</span>SetShouldFollowMovement(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>bool</span> bShouldFollow)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  bShouldFollowMovement <span style=color:#f92672>=</span> bShouldFollow;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>*</span> Movement <span style=color:#f92672>=</span> GetCharacterMovement())
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// When bShouldFollow is true, we are in &#34;running&#34; mode.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// When bShouldFollow is false, we are in &#34;aiming&#34; mode.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>bool</span> bIsInAimingMode <span style=color:#f92672>=</span> <span style=color:#f92672>!</span>bShouldFollowMovement;
</span></span><span style=display:flex><span>      Movement<span style=color:#f92672>-&gt;</span>bUseControllerDesiredRotation <span style=color:#f92672>=</span> bIsInAimingMode;
</span></span><span style=display:flex><span>      Movement<span style=color:#f92672>-&gt;</span>bOrientRotationToMovement <span style=color:#f92672>=</span> <span style=color:#f92672>!</span>bIsInAimingMode;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=step-2-camera-relative-omnidirectional-movement>Step 2: Camera-Relative Omnidirectional Movement<a hidden class=anchor aria-hidden=true href=#step-2-camera-relative-omnidirectional-movement>#</a></h4><p>This function takes 2D input (from WASD keys or a gamepad&rsquo;s left stick) and translates it into movement in the game
world. We don&rsquo;t want the <code>W</code> key to always move the character along the world&rsquo;s X-axis. We want <code>W</code> to move
the character &ldquo;forward&rdquo; <em>relative to the camera&rsquo;s view</em>. To do this, we need to rotate the player&rsquo;s input vector by an
angle equal to the camera&rsquo;s yaw.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> ACharacterBase<span style=color:#f92672>::</span>HandleMovementTrigger(<span style=color:#66d9ef>const</span> FVector2D InputAxisVector)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Guard clauses to prevent execution when not needed.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>Controller <span style=color:#f92672>||</span> InputAxisVector.IsNearlyZero())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>*</span> Movement <span style=color:#f92672>=</span> GetCharacterMovement())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>if</span> (Movement<span style=color:#f92672>-&gt;</span>IsFalling())
</span></span><span style=display:flex><span>       {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The camera&#39;s rotation around the Z-axis (Yaw).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> CameraYawRadians <span style=color:#f92672>=</span> FMath<span style=color:#f92672>::</span>DegreesToRadians(CameraYawDegrees);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Rotate the input vector based on the camera&#39;s yaw using a 2D rotation matrix.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> CosAngle <span style=color:#f92672>=</span> FMath<span style=color:#f92672>::</span>Cos(CameraYawRadians);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> SinAngle <span style=color:#f92672>=</span> FMath<span style=color:#f92672>::</span>Sin(CameraYawRadians);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> X <span style=color:#f92672>=</span> InputAxisVector.X <span style=color:#f92672>*</span> CosAngle <span style=color:#f92672>-</span> InputAxisVector.Y <span style=color:#f92672>*</span> SinAngle;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> Y <span style=color:#f92672>=</span> InputAxisVector.X <span style=color:#f92672>*</span> SinAngle <span style=color:#f92672>+</span> InputAxisVector.Y <span style=color:#f92672>*</span> CosAngle;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> FVector MoveDirection <span style=color:#f92672>=</span> FVector(Y, X, <span style=color:#ae81ff>0.f</span>).GetSafeNormal();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Apply the calculated movement input.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    AddMovementInput(MoveDirection);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If the character should face its movement direction, rotate it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (bShouldFollowMovement)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> TargetYaw <span style=color:#f92672>=</span> MoveDirection.Rotation().Yaw;
</span></span><span style=display:flex><span>       RotateTowardsYaw(TargetYaw, <span style=color:#ae81ff>2.5f</span>); <span style=color:#75715e>// Use our helper for smooth rotation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><strong>The Breakdown:</strong><ul><li>The math section with <code>CosAngle</code> and <code>SinAngle</code> is the formula for a 2D rotation matrix. It transforms the input
vector from &ldquo;screen space&rdquo; to &ldquo;camera-relative world space.&rdquo;</li><li>When <code>bShouldFollowMovement</code> is <code>true</code>, we calculate the movement direction and use our helper function
<code>RotateTowardsYaw</code> to turn the character accordingly.</li></ul></li></ul><h4 id=step-3-independent-looking--aiming>Step 3: Independent Looking & Aiming<a hidden class=anchor aria-hidden=true href=#step-3-independent-looking--aiming>#</a></h4><p>This system consists of three functions, corresponding to the <code>Started</code>, <code>Triggered</code>, and <code>Completed</code> events from the
Enhanced Input system (typically for a gamepad&rsquo;s right stick). When the player starts using the right stick (
<code>HandleLookStarted</code>), we switch to &ldquo;aiming mode&rdquo; using
<code>SetShouldFollowMovement(false)</code>. When they release it (<code>HandleLookCompleted</code>), we return to &ldquo;movement mode.&rdquo; While
they are holding it (<code>HandleLookTriggered</code>), we continuously update the character&rsquo;s facing direction.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> ACharacterBase<span style=color:#f92672>::</span>HandleLookStarted()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    SetShouldFollowMovement(false); <span style=color:#75715e>// Enter &#34;Aiming Mode&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> ACharacterBase<span style=color:#f92672>::</span>HandleLookTriggered(<span style=color:#66d9ef>const</span> FVector2D InputAxisVector)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>*</span> Movement <span style=color:#f92672>=</span> GetCharacterMovement())
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>  	<span style=color:#66d9ef>if</span> (Movement<span style=color:#f92672>-&gt;</span>IsFalling())
</span></span><span style=display:flex><span>  	{
</span></span><span style=display:flex><span>  		<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  	}
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Define the range for mapping the look input.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>float</span> MinYaw <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>90.0f</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>float</span> MaxYaw <span style=color:#f92672>=</span> <span style=color:#ae81ff>90.0f</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>float</span> MinPitch <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>70.0f</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>float</span> MaxPitch <span style=color:#f92672>=</span> <span style=color:#ae81ff>70.0f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Scale the input from [-1, 1] to the defined min/max ranges.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> ScaledX <span style=color:#f92672>=</span> FMath<span style=color:#f92672>::</span>Lerp(MinYaw, MaxYaw, (InputAxisVector.X <span style=color:#f92672>+</span> <span style=color:#ae81ff>1.0f</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2.0f</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> ScaledY <span style=color:#f92672>=</span> FMath<span style=color:#f92672>::</span>Lerp(MinPitch, MaxPitch, (InputAxisVector.Y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1.0f</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2.0f</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Calculate the target yaw relative to the screen/input axis (local yaw).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// This is the direction the player is pushing the stick relative to the screen.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> LocalTargetYaw <span style=color:#f92672>=</span> FMath<span style=color:#f92672>::</span>RadiansToDegrees(FMath<span style=color:#f92672>::</span>Atan2(ScaledX, <span style=color:#f92672>-</span>ScaledY));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// *** KEY LOGIC CHANGE IS HERE ***
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// Add the camera&#39;s yaw to the local yaw to get the final world-space target yaw.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// This makes the character&#39;s &#39;look&#39; direction relative to the camera.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> WorldTargetYaw <span style=color:#f92672>=</span> FMath<span style=color:#f92672>::</span>UnwindDegrees(LocalTargetYaw <span style=color:#f92672>+</span> CameraYawDegrees);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Use the unified helper function to handle the rotation towards the new world-space target.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  RotateTowardsYaw(WorldTargetYaw, <span style=color:#ae81ff>5.0f</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> ACharacterBase<span style=color:#f92672>::</span>HandleLookCompleted()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    SetShouldFollowMovement(true); <span style=color:#75715e>// Return to &#34;Running Mode&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li><strong>The Breakdown:</strong><ul><li>The line <code>WorldTargetYaw = FMath::UnwindDegrees(TargetYawFromInput + CameraYawDegrees);</code> is the most critical
part. It ensures the player&rsquo;s &ldquo;aim&rdquo; direction is always consistent with the camera&rsquo;s perspective, creating an
intuitive control experience.</li></ul></li></ul><h4 id=step-4-the-smooth-rotation-helper-function>Step 4: The Smooth Rotation Helper Function<a hidden class=anchor aria-hidden=true href=#step-4-the-smooth-rotation-helper-function>#</a></h4><p>Rotating the character needs to be done smoothly and independently of the frame rate. This function
allows us to reuse that logic for both movement and aiming modes.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief Helper function to smoothly rotate the controller towards a target yaw.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> ACharacterBase<span style=color:#f92672>::</span>RotateTowardsYaw(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> TargetYaw, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> RotationSpeed)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> CurrentYaw <span style=color:#f92672>=</span> GetControlRotation().Yaw;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Find the shortest angle to rotate. Avoids rotating 350 degrees when -10 is shorter.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> DeltaYaw <span style=color:#f92672>=</span> FMath<span style=color:#f92672>::</span>FindDeltaAngleDegrees(CurrentYaw, TargetYaw);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> DeltaTime <span style=color:#f92672>=</span> UGameplayStatics<span style=color:#f92672>::</span>GetWorldDeltaSeconds(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Add yaw input, scaled by speed and delta time for frame-rate independence.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    AddControllerYawInput(DeltaYaw <span style=color:#f92672>*</span> RotationSpeed <span style=color:#f92672>*</span> DeltaTime);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=step-5-exposing-and-calling-functions-from-the-player-character-blueprint>Step 5: Exposing and Calling Functions from the Player Character Blueprint<a hidden class=anchor aria-hidden=true href=#step-5-exposing-and-calling-functions-from-the-player-character-blueprint>#</a></h4><p>Our C++ logic is ready, but it needs to be triggered by player input. This step connects everything. We will use the
<code>UFUNCTION(BlueprintCallable)</code> macro to &ldquo;expose&rdquo; our C++ functions, allowing the
<code>Player Character</code> Blueprint to see and call them. Then, we will connect the events from <code>Enhanced Input</code> to these
corresponding functions. This is a classic Unreal workflow: <strong>Write complex, high-performance logic in C++ and use
Blueprint for flexible &ldquo;wiring.&rdquo;</strong></p><ul><li><p><strong>Part 1: Exposing Functions to Blueprint (C++ Header)</strong> In your character&rsquo;s header file (<code>ACharacterBase.h</code>), add the
<code>UFUNCTION</code> macro before the input handling functions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>// In your character&#39;s header file (e.g., ACharacterBase.h)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** Handles movement input. Called from Blueprint. */</span>
</span></span><span style=display:flex><span>    UFUNCTION(BlueprintCallable, Category <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Character | Input&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> HandleMovementTrigger(<span style=color:#66d9ef>const</span> FVector2D InputAxisVector);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** Called when the look input action starts. */</span>
</span></span><span style=display:flex><span>    UFUNCTION(BlueprintCallable, Category <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Character | Input&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> HandleLookStarted();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** Handles look input. Called every frame the input is active. */</span>
</span></span><span style=display:flex><span>    UFUNCTION(BlueprintCallable, Category <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Character | Input&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> HandleLookTriggered(<span style=color:#66d9ef>const</span> FVector2D InputAxisVector);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** Called when the look input action completes. */</span>
</span></span><span style=display:flex><span>    UFUNCTION(BlueprintCallable, Category <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Character | Input&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> HandleLookCompleted();
</span></span></code></pre></div><blockquote><p><strong>üí° Pro-Tip:</strong> Using a <code>Category</code> in the <code>UFUNCTION</code> macro organizes your functions neatly in the Blueprint&rsquo;s
right-click menu, making them easier for designers or yourself to find.</p></blockquote></li><li><p><strong>Part 2: Calling the Functions from Blueprint</strong> After compiling the C++ code, open your <code>Player Character</code>
Blueprint (this class must inherit from <code>ACharacterBase</code>). You can now call these C++ functions directly from the
<code>Enhanced Input</code> event nodes.</p><p><strong>Event Graph in <code>BP_PlayerCharacter</code></strong></p></li><li><p><strong>The Breakdown:</strong></p><ol><li><p><strong>Event IA_Move:</strong> This event fires every frame that there is movement input (WASD or Left Stick). We take its
<code>Action Value</code> (which is an <code>FVector2D</code>) and pass it directly into our C++ function <code>HandleMovementTrigger</code>.
<img alt="ia move" loading=lazy src="https://github.com/oaiba/dev-blog/blob/gh-pages/downloads/devlog-3/ia_move.png?raw=true"></p></li><li><p><strong>Event IA_Look:</strong></p><ul><li>The <code>Started</code> pin fires once when the player begins moving the Right Stick. It calls the <code>HandleLookStarted</code>
function to switch the character to &ldquo;aiming&rdquo; mode.</li><li>The <code>Triggered</code> pin fires every frame the Right Stick is held. It passes the <code>Action Value</code> into the
<code>HandleLookTriggered</code> function to update the character&rsquo;s rotation.</li><li>The <code>Completed</code> pin fires once when the player releases the Right Stick. It calls <code>HandleLookCompleted</code> to
return the character to the normal &ldquo;movement&rdquo; mode.
<img alt="ia look" loading=lazy src="https://github.com/oaiba/dev-blog/blob/gh-pages/downloads/devlog-3/ia_look.png?raw=true"></li></ul></li></ol></li></ul><p>With this setup, we have completed the full loop: <strong>Input -> Blueprint Event -> C++ Logic -> Character Movement.</strong></p><hr><h3 id=-visual-results--analysis>üìä Visual Results & Analysis<a hidden class=anchor aria-hidden=true href=#-visual-results--analysis>#</a></h3><ul><li><strong>Visual Demo:</strong>
<img loading=lazy src="https://github.com/oaiba/dev-blog/blob/gh-pages/downloads/devlog-3/sample-out-put.gif?raw=true"></li><li><strong>Result Analysis:</strong><ul><li><strong>Functional:</strong> We have successfully created a complete, flexible, and intuitive twin-stick control system that
meets the demands of modern top-down games.</li><li><strong>Technical:</strong> The system is driven by a simple state machine (<code>bShouldFollowMovement</code>), making the code easy to
understand and manage. The use of helper functions like <code>RotateTowardsYaw</code> and <code>SetShouldFollowMovement</code> adheres
to the DRY (Don&rsquo;t Repeat Yourself) principle.</li><li><strong>Workflow:</strong> By connecting these <code>Handle...</code> functions to <code>Input Actions</code> in the Enhanced Input system, we have
completely separated the processing logic from the input definition, allowing designers and programmers to work in
parallel effectively.</li></ul></li></ul><hr><h3 id=-conclusion--key-takeaways>‚ú® Conclusion & Key Takeaways<a hidden class=anchor aria-hidden=true href=#-conclusion--key-takeaways>#</a></h3><p>Here&rsquo;s what we learned today:</p><ul><li><strong>Lesson 1:</strong> The power of toggling between <code>bOrientRotationToMovement</code> and <code>bUseControllerDesiredRotation</code> to create
different movement and rotation modes.</li><li><strong>Lesson 2:</strong> How to apply vector math (a 2D rotation matrix) to create camera-relative movement, a foundational
technique for many game genres.</li><li><strong>Lesson 3:</strong> The importance of encapsulating repeated logic into helper functions to create cleaner and more
maintainable code.</li></ul><hr><h3 id=-challenge--next-steps>üí° Challenge & Next Steps<a hidden class=anchor aria-hidden=true href=#-challenge--next-steps>#</a></h3><ul><li><strong>A Challenge for You:</strong> Currently, the transition between &ldquo;aiming&rdquo; and &ldquo;movement&rdquo; modes is instant. Can you modify
the <code>SetShouldFollowMovement</code> function to add a short transition time (e.g., 0.15 seconds) and interpolate the
<code>CharacterMovementComponent</code>&rsquo;s rotation rate settings for a smoother state change?</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://oaiba.github.io/dev/en/tags/devlog/>DevLog</a></li><li><a href=https://oaiba.github.io/dev/en/tags/tutorial/>Tutorial</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://oaiba.github.io/dev/en/>Bob Pham's DevLog</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>